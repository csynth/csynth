var savedMaterials = {"position":{"// CSynth ribbon\n//(gn, s, min, max, delta, step, help, tag, free, useuniform)\ngene('wigmult', 500., 0, 2000, 10, 1, 'multiplier for wig radius', 'geom', 1);\ngene('colmix', 0., 0, 1, 0.1, 0.01, 'proportion of rainbow to use', 'geom', 1);\ngene('scaleFactor', 30., 1., 100., 10, 1, 'scaling factor for 3d ribbon etc', 'geom', 1);\ngene('ribbonPickWidth', 0.04, 0,1, 0.01, 0.01, 'how much of ribbon will have increased radius around selected particles', 'geom', 1 );\ngene('ribbonPickExtra', 0, 0,40, 0.1, 0.1, 'amount by which to increase ribbon diameter around selected particles', 'geom', 1 );\n\ngene('endblobs', 3., 0., 20., 1, 1, 'number of blobs at endc', 'geom', 1);\ngene('endbloblen', 0.01, 0., 0.1, 0.001, 0.0001, 'length of blobby end', 'geom', 1);\n\ngene('killradwidth', 0, 0, 10, 1, 1, 'numer of particles to kill each side of killrad points', 'geom', 1);\n\n\n//gene('numSegs', 87, 0,1023, 1,1, 'number of segments, numInstances-1', 'system', 0);\n//gene('numInstancesP2', 87, 0,1023, 1,1, 'power of 2 to hold all instances', 'system', 0);\nhorn('R').ribs(20).radius(80)\n  .code('vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;') // nb, r set below in skerad\n  .code('#define SKELPICK')\n;\nmainhorn='R';\nonframe(checkvr, 5);\nonframe(checkvr, 25);\nextradefines = `\n  uniform sampler2D t_ribboncol, t_ribbonrad;\n  #define KILLRADLEN 4\n  uniform float killrads[KILLRADLEN];\n`;\noverrides= //gl //comment serves as a tag to start a glsl section\n`\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) { \\\n    float p = getPickC(i);\\\n    float xtra = 1. - abs(p-rp) / ribbonPickWidth;\\\n    rx = max(rx, xtra);\\\n  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n`; ///gl  //comment closes the glsl section\nCSynth.startdemo();\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nvarying float scaleVary;\nvoid main ()\n{\n  mediump vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.x = scaleVary;\n  tmpvar_1.y = -(scaleVary);\n  tmpvar_1.z = (scaleVary + 10000.0);\n  gl_FragColor = tmpvar_1;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform vec3 awayvec;\nuniform vec3 clearposA0;\nfloat ribs;\nfloat radius;\nuniform float time;\nuniform float nstar;\nuniform float stardepth;\nuniform float ribdepth;\nuniform float R_ribs;\nuniform float R_radius;\nuniform float cumcount3;\nuniform float scaleFactor;\nuniform mat4 rot4;\nattribute float instanceID;\nuniform float fakeinstanceID;\nuniform float capres;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float lennum;\nuniform float radnum;\nvarying lowp float scaleVary;\nuniform float NORMTYPE;\nvoid main ()\n{\n  lowp float ll_1;\n  lowp vec4 rr_2;\n  lowp float l_3;\n  vec4 p_4;\n  vec4 tmpvar_5;\n  tmpvar_5.w = 1.0;\n  tmpvar_5.xy = position.xy;\n  tmpvar_5.z = (instanceID + fakeinstanceID);\n  p_4.zw = tmpvar_5.zw;\n  p_4.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_4.y = (p_4.y * 0.5);\n  };\n  if ((tmpvar_5.z < cumcount3)) {\n    ribs = R_ribs;\n  } else {\n    ribs = 77.0;\n  };\n  lowp vec3 xmnormal_6;\n  lowp vec3 surfpos_7;\n  float fac_8;\n  float lk_9;\n  float xrscalea_10;\n  float sss_11;\n  float star1_12;\n  if ((tmpvar_5.z < cumcount3)) {\n    radius = R_radius;\n    ribs = R_ribs;\n  } else {\n    radius = (max (0.2, (tmpvar_5.z - 20.0)) * fract((time * 0.25)));\n  };\n  float tmpvar_13;\n  tmpvar_13 = floor(((lennum * capres) * 0.5));\n  float tmpvar_14;\n  tmpvar_14 = (lennum - (2.0 * tmpvar_13));\n  float tmpvar_15;\n  tmpvar_15 = -(tmpvar_13);\n  float tmpvar_16;\n  tmpvar_16 = (tmpvar_15 + (p_4.x * (\n    (tmpvar_14 + tmpvar_13)\n   - tmpvar_15)));\n  float tmpvar_17;\n  tmpvar_17 = clamp ((tmpvar_16 / tmpvar_14), 0.0, 1.0);\n  lowp vec3 rad1a_18;\n  vec2 tmpvar_19;\n  tmpvar_19.x = 0.5;\n  tmpvar_19.y = (((\n    (tmpvar_17 + 0.01)\n   * numSegs) + 0.5) / numInstancesP2);\n  lowp vec4 tmpvar_20;\n  tmpvar_20.xyz = (texture2D (posNewvals, tmpvar_19) * scaleFactor).xyz;\n  tmpvar_20.w = 1.0;\n  vec2 tmpvar_21;\n  tmpvar_21.x = 0.5;\n  tmpvar_21.y = (((tmpvar_17 * numSegs) + 0.5) / numInstancesP2);\n  lowp vec4 tmpvar_22;\n  tmpvar_22 = (texture2D (posNewvals, tmpvar_21) * scaleFactor);\n  lowp vec4 tmpvar_23;\n  tmpvar_23.xyz = tmpvar_22.xyz;\n  tmpvar_23.w = 1.0;\n  lowp vec3 tmpvar_24;\n  tmpvar_24 = (tmpvar_20 - tmpvar_23).xyz;\n  lowp float tmpvar_25;\n  tmpvar_25 = sqrt(dot (tmpvar_24, tmpvar_24));\n  lowp vec3 tmpvar_26;\n  if ((tmpvar_25 == 0.0)) {\n    tmpvar_26 = vec3(0.0, 1.0, 0.0);\n  } else {\n    tmpvar_26 = (tmpvar_24 / tmpvar_25);\n  };\n  if (((tmpvar_25 == 0.0) || (NORMTYPE == 0.0))) {\n    rad1a_18 = vec3(1.0, 0.0, 0.0);\n  } else {\n    if ((NORMTYPE == 1.0)) {\n      rad1a_18 = ((tmpvar_26.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_26.zxy * vec3(1.3, 2.1, 1.0)));\n    } else {\n      if ((NORMTYPE == 2.0)) {\n        vec2 tmpvar_27;\n        tmpvar_27.x = 0.5;\n        tmpvar_27.y = (((\n          (tmpvar_17 - 0.09)\n         * numSegs) + 0.5) / numInstancesP2);\n        lowp vec3 b_28;\n        b_28 = ((texture2D (posNewvals, tmpvar_27) * scaleFactor).xyz - tmpvar_22.xyz);\n        rad1a_18 = ((tmpvar_26.yzx * b_28.zxy) - (tmpvar_26.zxy * b_28.yzx));\n      } else {\n        if ((NORMTYPE == 3.0)) {\n          vec2 tmpvar_29;\n          tmpvar_29.x = 0.5;\n          tmpvar_29.y = (((\n            (tmpvar_17 - 0.09)\n           * numSegs) + 0.5) / numInstancesP2);\n          lowp vec3 tmpvar_30;\n          lowp vec3 b_31;\n          b_31 = ((texture2D (posNewvals, tmpvar_29) * scaleFactor).xyz - tmpvar_22.xyz);\n          tmpvar_30 = ((tmpvar_26.yzx * b_31.zxy) - (tmpvar_26.zxy * b_31.yzx));\n          rad1a_18 = tmpvar_30;\n          lowp float tmpvar_32;\n          tmpvar_32 = dot (tmpvar_30, tmpvar_30);\n          if ((tmpvar_32 < 1e-6)) {\n            rad1a_18 = ((tmpvar_26.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_26.zxy * vec3(1.3, 2.1, 1.0)));\n          };\n        } else {\n          if ((NORMTYPE == 4.0)) {\n            vec2 tmpvar_33;\n            tmpvar_33.x = 0.5;\n            tmpvar_33.y = (((tmpvar_17 * numSegs) + 0.5) / numInstancesP2);\n            lowp vec4 tmpvar_34;\n            tmpvar_34 = (texture2D (posNewvals, tmpvar_33) * scaleFactor);\n            lowp vec4 tmpvar_35;\n            tmpvar_35.x = (0.013 + tmpvar_34.x);\n            tmpvar_35.y = tmpvar_34.y;\n            tmpvar_35.z = (0.017 + tmpvar_34.z);\n            tmpvar_35.w = 1.0;\n            lowp vec3 b_36;\n            b_36 = (tmpvar_35.xyz - tmpvar_22.xyz);\n            rad1a_18 = ((tmpvar_26.yzx * b_36.zxy) - (tmpvar_26.zxy * b_36.yzx));\n          } else {\n            if ((NORMTYPE == 5.0)) {\n              mat3 tmpvar_37;\n              tmpvar_37[0] = rot4[0].xyz;\n              tmpvar_37[1] = rot4[1].xyz;\n              tmpvar_37[2] = rot4[2].xyz;\n              lowp vec3 tmpvar_38;\n              tmpvar_38 = normalize((tmpvar_37 * (clearposA0 - \n                (tmpvar_23 * rot4)\n              .xyz)));\n              rad1a_18 = ((tmpvar_38.yzx * tmpvar_26.zxy) - (tmpvar_38.zxy * tmpvar_26.yzx));\n            } else {\n              if ((NORMTYPE == 6.0)) {\n                rad1a_18 = ((awayvec.yzx * tmpvar_26.zxy) - (awayvec.zxy * tmpvar_26.yzx));\n              } else {\n                rad1a_18 = vec3(0.0, 0.0, 1.0);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  float tmpvar_39;\n  tmpvar_39 = (p_4.y * nstar);\n  star1_12 = tmpvar_39;\n  sss_11 = 1.0;\n  float tmpvar_40;\n  tmpvar_40 = floor(nstar);\n  if ((tmpvar_39 > tmpvar_40)) {\n    float tmpvar_41;\n    tmpvar_41 = fract(nstar);\n    sss_11 = tmpvar_41;\n    float tmpvar_42;\n    tmpvar_42 = floor(nstar);\n    star1_12 = (tmpvar_42 + ((tmpvar_39 - tmpvar_42) / tmpvar_41));\n  };\n  float tmpvar_43;\n  tmpvar_43 = (radius * (1.0 - (\n    (1.0 - (((1.0 - \n      cos((6.28318 * star1_12))\n    ) * sss_11) * sss_11))\n   * stardepth)));\n  xrscalea_10 = tmpvar_43;\n  lk_9 = 0.0;\n  fac_8 = 1.0;\n  if (((0.0 < tmpvar_16) && (tmpvar_16 < tmpvar_14))) {\n    lk_9 = ((p_4.x * ribs) + 0.5);\n    float tmpvar_44;\n    tmpvar_44 = abs((fract(lk_9) - 0.5));\n    lk_9 = tmpvar_44;\n    float tmpvar_45;\n    tmpvar_45 = sqrt((1.0 - (\n      (ribdepth * tmpvar_44)\n     * tmpvar_44)));\n    fac_8 = tmpvar_45;\n    xrscalea_10 = (tmpvar_43 * tmpvar_45);\n  };\n  lowp vec3 tmpvar_46;\n  tmpvar_46 = normalize(rad1a_18);\n  xmnormal_6 = ((-(\n    sin((6.28318 * p_4.y))\n  ) * -(\n    normalize(((tmpvar_26.yzx * tmpvar_46.zxy) - (tmpvar_26.zxy * tmpvar_46.yzx)))\n  )) + (cos(\n    (6.28318 * p_4.y)\n  ) * tmpvar_46));\n  surfpos_7 = (tmpvar_22.xyz + (xrscalea_10 * xmnormal_6));\n  xmnormal_6 = (xmnormal_6 + (tmpvar_26 * (\n    (ribdepth * lk_9)\n   / fac_8)));\n  lowp vec3 tmpvar_47;\n  tmpvar_47 = normalize(xmnormal_6);\n  xmnormal_6 = tmpvar_47;\n  if ((tmpvar_16 > tmpvar_14)) {\n    float tmpvar_48;\n    tmpvar_48 = (((\n      (tmpvar_16 - tmpvar_14)\n     / tmpvar_13) * 3.14159) / 2.0);\n    surfpos_7 = (tmpvar_22.xyz + (xrscalea_10 * (\n      (sin(tmpvar_48) * tmpvar_26)\n     + \n      (cos(tmpvar_48) * tmpvar_47)\n    )));\n  };\n  if ((tmpvar_16 < 0.0)) {\n    float tmpvar_49;\n    tmpvar_49 = (((tmpvar_16 / tmpvar_13) * 3.14159) / 2.0);\n    surfpos_7 = (tmpvar_22.xyz + (xrscalea_10 * (\n      (sin(tmpvar_49) * tmpvar_26)\n     + \n      (cos(tmpvar_49) * tmpvar_47)\n    )));\n  };\n  xmnormal_6 = tmpvar_47;\n  lowp vec4 tmpvar_50;\n  tmpvar_50.xyz = surfpos_7;\n  tmpvar_50.w = tmpvar_23.w;\n  gl_PointSize = 1.0;\n  float tmpvar_51;\n  tmpvar_51 = (float(mod (((p_4.x * lennum) + (p_4.y * radnum)), 8.0)));\n  if ((tmpvar_51 < 1.0)) {\n    l_3 = -(surfpos_7.x);\n    rr_2.x = -0.875;\n  } else {\n    if ((tmpvar_51 < 2.0)) {\n      l_3 = tmpvar_50.x;\n      rr_2.x = -0.625;\n    } else {\n      if ((tmpvar_51 < 3.0)) {\n        l_3 = -(surfpos_7.y);\n        rr_2.x = -0.375;\n      } else {\n        if ((tmpvar_51 < 4.0)) {\n          l_3 = tmpvar_50.y;\n          rr_2.x = -0.125;\n        } else {\n          if ((tmpvar_51 < 5.0)) {\n            l_3 = -(surfpos_7.z);\n            rr_2.x = 0.125;\n          } else {\n            if ((tmpvar_51 < 6.0)) {\n              l_3 = tmpvar_50.z;\n              rr_2.x = 0.375;\n            } else {\n              if ((tmpvar_51 < 7.0)) {\n                l_3 = -1.0;\n                rr_2.x = 0.625;\n              } else {\n                l_3 = tmpvar_50.w;\n                rr_2.x = 0.875;\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  rr_2.y = 0.0;\n  ll_1 = 0.0;\n  if ((l_3 > 1.0)) {\n    ll_1 = (-(log(l_3)) / 20.0);\n  };\n  if ((l_3 < -1.0)) {\n    ll_1 = (log(-(l_3)) / 20.0);\n  };\n  if (((ll_1 < -1.0) || (ll_1 > 1.0))) {\n    rr_2.x = 999.0;\n  };\n  if ((ll_1 != ll_1)) {\n    rr_2.x = 999.0;\n  };\n  rr_2.z = ll_1;\n  rr_2.w = 1.0;\n  gl_Position = rr_2;\n  scaleVary = l_3;\n}\n\n"},"horn(\"R\").ribs(#R_ribs#).radius(#R_radius#).code(\"vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;\").code(\"#define SKELPICK\");\nmainhorn=\"R\";\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) {     float p = getPickC(i);    float xtra = 1. - abs(p-rp) / ribbonPickWidth;    rx = max(rx, xtra);  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nvarying float scaleVary;\nvoid main ()\n{\n  mediump vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.x = scaleVary;\n  tmpvar_1.y = -(scaleVary);\n  tmpvar_1.z = (scaleVary + 10000.0);\n  gl_FragColor = tmpvar_1;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform vec3 awayvec;\nuniform vec3 clearposA0;\nfloat ribs;\nfloat radius;\nuniform float time;\nuniform float nstar;\nuniform float stardepth;\nuniform float ribdepth;\nuniform float R_ribs;\nuniform float R_radius;\nuniform float cumcount3;\nuniform float scaleFactor;\nuniform mat4 rot4;\nattribute float instanceID;\nuniform float fakeinstanceID;\nuniform float capres;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float lennum;\nuniform float radnum;\nvarying lowp float scaleVary;\nuniform float NORMTYPE;\nvoid main ()\n{\n  lowp float ll_1;\n  lowp vec4 rr_2;\n  lowp float l_3;\n  vec4 p_4;\n  vec4 tmpvar_5;\n  tmpvar_5.w = 1.0;\n  tmpvar_5.xy = position.xy;\n  tmpvar_5.z = (instanceID + fakeinstanceID);\n  p_4.zw = tmpvar_5.zw;\n  p_4.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_4.y = (p_4.y * 0.5);\n  };\n  if ((tmpvar_5.z < cumcount3)) {\n    ribs = R_ribs;\n  } else {\n    ribs = 77.0;\n  };\n  lowp vec3 xmnormal_6;\n  lowp vec3 surfpos_7;\n  float fac_8;\n  float lk_9;\n  float xrscalea_10;\n  float sss_11;\n  float star1_12;\n  if ((tmpvar_5.z < cumcount3)) {\n    radius = R_radius;\n    ribs = R_ribs;\n  } else {\n    radius = (max (0.2, (tmpvar_5.z - 20.0)) * fract((time * 0.25)));\n  };\n  float tmpvar_13;\n  tmpvar_13 = floor(((lennum * capres) * 0.5));\n  float tmpvar_14;\n  tmpvar_14 = (lennum - (2.0 * tmpvar_13));\n  float tmpvar_15;\n  tmpvar_15 = -(tmpvar_13);\n  float tmpvar_16;\n  tmpvar_16 = (tmpvar_15 + (p_4.x * (\n    (tmpvar_14 + tmpvar_13)\n   - tmpvar_15)));\n  float tmpvar_17;\n  tmpvar_17 = clamp ((tmpvar_16 / tmpvar_14), 0.0, 1.0);\n  lowp vec3 rad1a_18;\n  vec2 tmpvar_19;\n  tmpvar_19.x = 0.5;\n  tmpvar_19.y = (((\n    (tmpvar_17 + 0.01)\n   * numSegs) + 0.5) / numInstancesP2);\n  lowp vec4 tmpvar_20;\n  tmpvar_20.xyz = (texture2D (posNewvals, tmpvar_19) * scaleFactor).xyz;\n  tmpvar_20.w = 1.0;\n  vec2 tmpvar_21;\n  tmpvar_21.x = 0.5;\n  tmpvar_21.y = (((tmpvar_17 * numSegs) + 0.5) / numInstancesP2);\n  lowp vec4 tmpvar_22;\n  tmpvar_22 = (texture2D (posNewvals, tmpvar_21) * scaleFactor);\n  lowp vec4 tmpvar_23;\n  tmpvar_23.xyz = tmpvar_22.xyz;\n  tmpvar_23.w = 1.0;\n  lowp vec3 tmpvar_24;\n  tmpvar_24 = (tmpvar_20 - tmpvar_23).xyz;\n  lowp float tmpvar_25;\n  tmpvar_25 = sqrt(dot (tmpvar_24, tmpvar_24));\n  lowp vec3 tmpvar_26;\n  if ((tmpvar_25 == 0.0)) {\n    tmpvar_26 = vec3(0.0, 1.0, 0.0);\n  } else {\n    tmpvar_26 = (tmpvar_24 / tmpvar_25);\n  };\n  if (((tmpvar_25 == 0.0) || (NORMTYPE == 0.0))) {\n    rad1a_18 = vec3(1.0, 0.0, 0.0);\n  } else {\n    if ((NORMTYPE == 1.0)) {\n      rad1a_18 = ((tmpvar_26.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_26.zxy * vec3(1.3, 2.1, 1.0)));\n    } else {\n      if ((NORMTYPE == 2.0)) {\n        vec2 tmpvar_27;\n        tmpvar_27.x = 0.5;\n        tmpvar_27.y = (((\n          (tmpvar_17 - 0.09)\n         * numSegs) + 0.5) / numInstancesP2);\n        lowp vec3 b_28;\n        b_28 = ((texture2D (posNewvals, tmpvar_27) * scaleFactor).xyz - tmpvar_22.xyz);\n        rad1a_18 = ((tmpvar_26.yzx * b_28.zxy) - (tmpvar_26.zxy * b_28.yzx));\n      } else {\n        if ((NORMTYPE == 3.0)) {\n          vec2 tmpvar_29;\n          tmpvar_29.x = 0.5;\n          tmpvar_29.y = (((\n            (tmpvar_17 - 0.09)\n           * numSegs) + 0.5) / numInstancesP2);\n          lowp vec3 tmpvar_30;\n          lowp vec3 b_31;\n          b_31 = ((texture2D (posNewvals, tmpvar_29) * scaleFactor).xyz - tmpvar_22.xyz);\n          tmpvar_30 = ((tmpvar_26.yzx * b_31.zxy) - (tmpvar_26.zxy * b_31.yzx));\n          rad1a_18 = tmpvar_30;\n          lowp float tmpvar_32;\n          tmpvar_32 = dot (tmpvar_30, tmpvar_30);\n          if ((tmpvar_32 < 1e-6)) {\n            rad1a_18 = ((tmpvar_26.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_26.zxy * vec3(1.3, 2.1, 1.0)));\n          };\n        } else {\n          if ((NORMTYPE == 4.0)) {\n            vec2 tmpvar_33;\n            tmpvar_33.x = 0.5;\n            tmpvar_33.y = (((tmpvar_17 * numSegs) + 0.5) / numInstancesP2);\n            lowp vec4 tmpvar_34;\n            tmpvar_34 = (texture2D (posNewvals, tmpvar_33) * scaleFactor);\n            lowp vec4 tmpvar_35;\n            tmpvar_35.x = (0.013 + tmpvar_34.x);\n            tmpvar_35.y = tmpvar_34.y;\n            tmpvar_35.z = (0.017 + tmpvar_34.z);\n            tmpvar_35.w = 1.0;\n            lowp vec3 b_36;\n            b_36 = (tmpvar_35.xyz - tmpvar_22.xyz);\n            rad1a_18 = ((tmpvar_26.yzx * b_36.zxy) - (tmpvar_26.zxy * b_36.yzx));\n          } else {\n            if ((NORMTYPE == 5.0)) {\n              mat3 tmpvar_37;\n              tmpvar_37[0] = rot4[0].xyz;\n              tmpvar_37[1] = rot4[1].xyz;\n              tmpvar_37[2] = rot4[2].xyz;\n              lowp vec3 tmpvar_38;\n              tmpvar_38 = normalize((tmpvar_37 * (clearposA0 - \n                (tmpvar_23 * rot4)\n              .xyz)));\n              rad1a_18 = ((tmpvar_38.yzx * tmpvar_26.zxy) - (tmpvar_38.zxy * tmpvar_26.yzx));\n            } else {\n              if ((NORMTYPE == 6.0)) {\n                rad1a_18 = ((awayvec.yzx * tmpvar_26.zxy) - (awayvec.zxy * tmpvar_26.yzx));\n              } else {\n                rad1a_18 = vec3(0.0, 0.0, 1.0);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  float tmpvar_39;\n  tmpvar_39 = (p_4.y * nstar);\n  star1_12 = tmpvar_39;\n  sss_11 = 1.0;\n  float tmpvar_40;\n  tmpvar_40 = floor(nstar);\n  if ((tmpvar_39 > tmpvar_40)) {\n    float tmpvar_41;\n    tmpvar_41 = fract(nstar);\n    sss_11 = tmpvar_41;\n    float tmpvar_42;\n    tmpvar_42 = floor(nstar);\n    star1_12 = (tmpvar_42 + ((tmpvar_39 - tmpvar_42) / tmpvar_41));\n  };\n  float tmpvar_43;\n  tmpvar_43 = (radius * (1.0 - (\n    (1.0 - (((1.0 - \n      cos((6.28318 * star1_12))\n    ) * sss_11) * sss_11))\n   * stardepth)));\n  xrscalea_10 = tmpvar_43;\n  lk_9 = 0.0;\n  fac_8 = 1.0;\n  if (((0.0 < tmpvar_16) && (tmpvar_16 < tmpvar_14))) {\n    lk_9 = ((p_4.x * ribs) + 0.5);\n    float tmpvar_44;\n    tmpvar_44 = abs((fract(lk_9) - 0.5));\n    lk_9 = tmpvar_44;\n    float tmpvar_45;\n    tmpvar_45 = sqrt((1.0 - (\n      (ribdepth * tmpvar_44)\n     * tmpvar_44)));\n    fac_8 = tmpvar_45;\n    xrscalea_10 = (tmpvar_43 * tmpvar_45);\n  };\n  lowp vec3 tmpvar_46;\n  tmpvar_46 = normalize(rad1a_18);\n  xmnormal_6 = ((-(\n    sin((6.28318 * p_4.y))\n  ) * -(\n    normalize(((tmpvar_26.yzx * tmpvar_46.zxy) - (tmpvar_26.zxy * tmpvar_46.yzx)))\n  )) + (cos(\n    (6.28318 * p_4.y)\n  ) * tmpvar_46));\n  surfpos_7 = (tmpvar_22.xyz + (xrscalea_10 * xmnormal_6));\n  xmnormal_6 = (xmnormal_6 + (tmpvar_26 * (\n    (ribdepth * lk_9)\n   / fac_8)));\n  lowp vec3 tmpvar_47;\n  tmpvar_47 = normalize(xmnormal_6);\n  xmnormal_6 = tmpvar_47;\n  if ((tmpvar_16 > tmpvar_14)) {\n    float tmpvar_48;\n    tmpvar_48 = (((\n      (tmpvar_16 - tmpvar_14)\n     / tmpvar_13) * 3.14159) / 2.0);\n    surfpos_7 = (tmpvar_22.xyz + (xrscalea_10 * (\n      (sin(tmpvar_48) * tmpvar_26)\n     + \n      (cos(tmpvar_48) * tmpvar_47)\n    )));\n  };\n  if ((tmpvar_16 < 0.0)) {\n    float tmpvar_49;\n    tmpvar_49 = (((tmpvar_16 / tmpvar_13) * 3.14159) / 2.0);\n    surfpos_7 = (tmpvar_22.xyz + (xrscalea_10 * (\n      (sin(tmpvar_49) * tmpvar_26)\n     + \n      (cos(tmpvar_49) * tmpvar_47)\n    )));\n  };\n  xmnormal_6 = tmpvar_47;\n  lowp vec4 tmpvar_50;\n  tmpvar_50.xyz = surfpos_7;\n  tmpvar_50.w = tmpvar_23.w;\n  gl_PointSize = 1.0;\n  float tmpvar_51;\n  tmpvar_51 = (float(mod (((p_4.x * lennum) + (p_4.y * radnum)), 8.0)));\n  if ((tmpvar_51 < 1.0)) {\n    l_3 = -(surfpos_7.x);\n    rr_2.x = -0.875;\n  } else {\n    if ((tmpvar_51 < 2.0)) {\n      l_3 = tmpvar_50.x;\n      rr_2.x = -0.625;\n    } else {\n      if ((tmpvar_51 < 3.0)) {\n        l_3 = -(surfpos_7.y);\n        rr_2.x = -0.375;\n      } else {\n        if ((tmpvar_51 < 4.0)) {\n          l_3 = tmpvar_50.y;\n          rr_2.x = -0.125;\n        } else {\n          if ((tmpvar_51 < 5.0)) {\n            l_3 = -(surfpos_7.z);\n            rr_2.x = 0.125;\n          } else {\n            if ((tmpvar_51 < 6.0)) {\n              l_3 = tmpvar_50.z;\n              rr_2.x = 0.375;\n            } else {\n              if ((tmpvar_51 < 7.0)) {\n                l_3 = -1.0;\n                rr_2.x = 0.625;\n              } else {\n                l_3 = tmpvar_50.w;\n                rr_2.x = 0.875;\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  rr_2.y = 0.0;\n  ll_1 = 0.0;\n  if ((l_3 > 1.0)) {\n    ll_1 = (-(log(l_3)) / 20.0);\n  };\n  if ((l_3 < -1.0)) {\n    ll_1 = (log(-(l_3)) / 20.0);\n  };\n  if (((ll_1 < -1.0) || (ll_1 > 1.0))) {\n    rr_2.x = 999.0;\n  };\n  if ((ll_1 != ll_1)) {\n    rr_2.x = 999.0;\n  };\n  rr_2.z = ll_1;\n  rr_2.w = 1.0;\n  gl_Position = rr_2;\n  scaleVary = l_3;\n}\n\n"}},"shadergenes":{},"matcodes":{},"makeskelbuff":{"// CSynth ribbon\n//(gn, s, min, max, delta, step, help, tag, free, useuniform)\ngene('wigmult', 500., 0, 2000, 10, 1, 'multiplier for wig radius', 'geom', 1);\ngene('colmix', 0., 0, 1, 0.1, 0.01, 'proportion of rainbow to use', 'geom', 1);\ngene('scaleFactor', 30., 1., 100., 10, 1, 'scaling factor for 3d ribbon etc', 'geom', 1);\ngene('ribbonPickWidth', 0.04, 0,1, 0.01, 0.01, 'how much of ribbon will have increased radius around selected particles', 'geom', 1 );\ngene('ribbonPickExtra', 0, 0,40, 0.1, 0.1, 'amount by which to increase ribbon diameter around selected particles', 'geom', 1 );\n\ngene('endblobs', 3., 0., 20., 1, 1, 'number of blobs at endc', 'geom', 1);\ngene('endbloblen', 0.01, 0., 0.1, 0.001, 0.0001, 'length of blobby end', 'geom', 1);\n\ngene('killradwidth', 0, 0, 10, 1, 1, 'numer of particles to kill each side of killrad points', 'geom', 1);\n\n\n//gene('numSegs', 87, 0,1023, 1,1, 'number of segments, numInstances-1', 'system', 0);\n//gene('numInstancesP2', 87, 0,1023, 1,1, 'power of 2 to hold all instances', 'system', 0);\nhorn('R').ribs(20).radius(80)\n  .code('vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;') // nb, r set below in skerad\n  .code('#define SKELPICK')\n;\nmainhorn='R';\nonframe(checkvr, 5);\nonframe(checkvr, 25);\nextradefines = `\n  uniform sampler2D t_ribboncol, t_ribbonrad;\n  #define KILLRADLEN 4\n  uniform float killrads[KILLRADLEN];\n`;\noverrides= //gl //comment serves as a tag to start a glsl section\n`\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) { \\\n    float p = getPickC(i);\\\n    float xtra = 1. - abs(p-rp) / ribbonPickWidth;\\\n    rx = max(rx, xtra);\\\n  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n`; ///gl  //comment closes the glsl section\nCSynth.startdemo();\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nvarying vec4 objpos;\nvoid main ()\n{\n  gl_FragColor = objpos;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform vec3 clearposA0;\nuniform vec3 clearposA1;\nuniform vec3 clearposB0;\nuniform vec3 clearposB1;\nfloat radius;\nuniform float time;\nuniform float R_radius;\nuniform float cumcount3;\nuniform float scaleFactor;\nuniform mat4 rot4;\nattribute float instanceID;\nuniform float fakeinstanceID;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float skelnum;\nuniform float skelends;\nuniform vec2 skelbufferRes;\nuniform sampler2D scaleDampTarget;\nuniform float shrinkfactor;\nuniform float shrinkradiusA;\nuniform float shrinkradiusB;\nvarying lowp vec4 objpos;\nuniform float NORMTYPE;\nvoid main ()\n{\n  vec4 p_1;\n  vec4 tmpvar_2;\n  tmpvar_2.w = 1.0;\n  tmpvar_2.xy = position.xy;\n  tmpvar_2.z = (instanceID + fakeinstanceID);\n  p_1.zw = tmpvar_2.zw;\n  p_1.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_1.y = (p_1.y * 0.5);\n  };\n  lowp vec4 skelpos_3;\n  lowp float xrscale_4;\n  if ((tmpvar_2.z < cumcount3)) {\n    radius = R_radius;\n  } else {\n    radius = (max (0.2, (tmpvar_2.z - 20.0)) * fract((time * 0.25)));\n  };\n  vec2 tmpvar_5;\n  tmpvar_5.x = 0.5;\n  tmpvar_5.y = (((p_1.x * numSegs) + 0.5) / numInstancesP2);\n  lowp vec4 tmpvar_6;\n  tmpvar_6.xyz = ((texture2D (posNewvals, tmpvar_5) * scaleFactor).xyz - texture2D (scaleDampTarget, vec2(0.5, 0.5)).xyz);\n  tmpvar_6.w = 1.0;\n  xrscale_4 = radius;\n  skelpos_3 = tmpvar_6;\n  lowp vec3 tmpvar_7;\n  tmpvar_7 = (tmpvar_6 * rot4).xyz;\n  if ((shrinkradiusA > 0.0)) {\n    lowp float tmpvar_8;\n    tmpvar_8 = (shrinkradiusA + radius);\n    lowp vec3 x_9;\n    x_9 = (clearposA0 - tmpvar_7);\n    lowp vec3 x_10;\n    x_10 = (clearposA1 - tmpvar_7);\n    vec3 x_11;\n    x_11 = (clearposA1 - clearposA0);\n    xrscale_4 = (radius * sqrt(clamp (\n      ((((\n        (sqrt(dot (x_9, x_9)) + sqrt(dot (x_10, x_10)))\n       - \n        sqrt(dot (x_11, x_11))\n      ) * 0.5) - tmpvar_8) / ((tmpvar_8 * shrinkfactor) - tmpvar_8))\n    , 0.0, 1.0)));\n  };\n  if ((shrinkradiusB > 0.0)) {\n    lowp float tmpvar_12;\n    tmpvar_12 = (shrinkradiusB + xrscale_4);\n    lowp vec3 x_13;\n    x_13 = (clearposB0 - tmpvar_7);\n    lowp vec3 x_14;\n    x_14 = (clearposB1 - tmpvar_7);\n    vec3 x_15;\n    x_15 = (clearposB1 - clearposB0);\n    xrscale_4 = (xrscale_4 * sqrt(clamp (\n      ((((\n        (sqrt(dot (x_13, x_13)) + sqrt(dot (x_14, x_14)))\n       - \n        sqrt(dot (x_15, x_15))\n      ) * 0.5) - tmpvar_12) / ((tmpvar_12 * shrinkfactor) - tmpvar_12))\n    , 0.0, 1.0)));\n  };\n  skelpos_3.w = xrscale_4;\n  objpos = skelpos_3;\n  gl_PointSize = 1.0;\n  vec2 tmpvar_16;\n  tmpvar_16.x = (floor((\n    ((p_1.x * skelnum) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_16.y = (tmpvar_2.z + 0.5);\n  highp vec4 tmpvar_17;\n  tmpvar_17.zw = vec2(0.0, 1.0);\n  tmpvar_17.xy = (((tmpvar_16 / skelbufferRes) * 2.0) - 1.0);\n  gl_Position = tmpvar_17;\n}\n\n"},"horn(\"R\").ribs(#R_ribs#).radius(#R_radius#).code(\"vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;\").code(\"#define SKELPICK\");\nmainhorn=\"R\";\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) {     float p = getPickC(i);    float xtra = 1. - abs(p-rp) / ribbonPickWidth;    rx = max(rx, xtra);  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nvarying vec4 objpos;\nvoid main ()\n{\n  gl_FragColor = objpos;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform vec3 clearposA0;\nuniform vec3 clearposA1;\nuniform vec3 clearposB0;\nuniform vec3 clearposB1;\nfloat radius;\nuniform float time;\nuniform float R_radius;\nuniform float cumcount3;\nuniform float scaleFactor;\nuniform mat4 rot4;\nattribute float instanceID;\nuniform float fakeinstanceID;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float skelnum;\nuniform float skelends;\nuniform vec2 skelbufferRes;\nuniform sampler2D scaleDampTarget;\nuniform float shrinkfactor;\nuniform float shrinkradiusA;\nuniform float shrinkradiusB;\nvarying lowp vec4 objpos;\nuniform float NORMTYPE;\nvoid main ()\n{\n  vec4 p_1;\n  vec4 tmpvar_2;\n  tmpvar_2.w = 1.0;\n  tmpvar_2.xy = position.xy;\n  tmpvar_2.z = (instanceID + fakeinstanceID);\n  p_1.zw = tmpvar_2.zw;\n  p_1.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_1.y = (p_1.y * 0.5);\n  };\n  lowp vec4 skelpos_3;\n  lowp float xrscale_4;\n  if ((tmpvar_2.z < cumcount3)) {\n    radius = R_radius;\n  } else {\n    radius = (max (0.2, (tmpvar_2.z - 20.0)) * fract((time * 0.25)));\n  };\n  vec2 tmpvar_5;\n  tmpvar_5.x = 0.5;\n  tmpvar_5.y = (((p_1.x * numSegs) + 0.5) / numInstancesP2);\n  lowp vec4 tmpvar_6;\n  tmpvar_6.xyz = ((texture2D (posNewvals, tmpvar_5) * scaleFactor).xyz - texture2D (scaleDampTarget, vec2(0.5, 0.5)).xyz);\n  tmpvar_6.w = 1.0;\n  xrscale_4 = radius;\n  skelpos_3 = tmpvar_6;\n  lowp vec3 tmpvar_7;\n  tmpvar_7 = (tmpvar_6 * rot4).xyz;\n  if ((shrinkradiusA > 0.0)) {\n    lowp float tmpvar_8;\n    tmpvar_8 = (shrinkradiusA + radius);\n    lowp vec3 x_9;\n    x_9 = (clearposA0 - tmpvar_7);\n    lowp vec3 x_10;\n    x_10 = (clearposA1 - tmpvar_7);\n    vec3 x_11;\n    x_11 = (clearposA1 - clearposA0);\n    xrscale_4 = (radius * sqrt(clamp (\n      ((((\n        (sqrt(dot (x_9, x_9)) + sqrt(dot (x_10, x_10)))\n       - \n        sqrt(dot (x_11, x_11))\n      ) * 0.5) - tmpvar_8) / ((tmpvar_8 * shrinkfactor) - tmpvar_8))\n    , 0.0, 1.0)));\n  };\n  if ((shrinkradiusB > 0.0)) {\n    lowp float tmpvar_12;\n    tmpvar_12 = (shrinkradiusB + xrscale_4);\n    lowp vec3 x_13;\n    x_13 = (clearposB0 - tmpvar_7);\n    lowp vec3 x_14;\n    x_14 = (clearposB1 - tmpvar_7);\n    vec3 x_15;\n    x_15 = (clearposB1 - clearposB0);\n    xrscale_4 = (xrscale_4 * sqrt(clamp (\n      ((((\n        (sqrt(dot (x_13, x_13)) + sqrt(dot (x_14, x_14)))\n       - \n        sqrt(dot (x_15, x_15))\n      ) * 0.5) - tmpvar_12) / ((tmpvar_12 * shrinkfactor) - tmpvar_12))\n    , 0.0, 1.0)));\n  };\n  skelpos_3.w = xrscale_4;\n  objpos = skelpos_3;\n  gl_PointSize = 1.0;\n  vec2 tmpvar_16;\n  tmpvar_16.x = (floor((\n    ((p_1.x * skelnum) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_16.y = (tmpvar_2.z + 0.5);\n  highp vec4 tmpvar_17;\n  tmpvar_17.zw = vec2(0.0, 1.0);\n  tmpvar_17.xy = (((tmpvar_16 / skelbufferRes) * 2.0) - 1.0);\n  gl_Position = tmpvar_17;\n}\n\n"}},"opos":{"// CSynth ribbon\n//(gn, s, min, max, delta, step, help, tag, free, useuniform)\ngene('wigmult', 500., 0, 2000, 10, 1, 'multiplier for wig radius', 'geom', 1);\ngene('colmix', 0., 0, 1, 0.1, 0.01, 'proportion of rainbow to use', 'geom', 1);\ngene('scaleFactor', 30., 1., 100., 10, 1, 'scaling factor for 3d ribbon etc', 'geom', 1);\ngene('ribbonPickWidth', 0.04, 0,1, 0.01, 0.01, 'how much of ribbon will have increased radius around selected particles', 'geom', 1 );\ngene('ribbonPickExtra', 0, 0,40, 0.1, 0.1, 'amount by which to increase ribbon diameter around selected particles', 'geom', 1 );\n\ngene('endblobs', 3., 0., 20., 1, 1, 'number of blobs at endc', 'geom', 1);\ngene('endbloblen', 0.01, 0., 0.1, 0.001, 0.0001, 'length of blobby end', 'geom', 1);\n\ngene('killradwidth', 0, 0, 10, 1, 1, 'numer of particles to kill each side of killrad points', 'geom', 1);\n\n\n//gene('numSegs', 87, 0,1023, 1,1, 'number of segments, numInstances-1', 'system', 0);\n//gene('numInstancesP2', 87, 0,1023, 1,1, 'power of 2 to hold all instances', 'system', 0);\nhorn('R').ribs(20).radius(80)\n  .code('vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;') // nb, r set below in skerad\n  .code('#define SKELPICK')\n;\nmainhorn='R';\nonframe(checkvr, 5);\nonframe(checkvr, 25);\nextradefines = `\n  uniform sampler2D t_ribboncol, t_ribbonrad;\n  #define KILLRADLEN 4\n  uniform float killrads[KILLRADLEN];\n`;\noverrides= //gl //comment serves as a tag to start a glsl section\n`\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) { \\\n    float p = getPickC(i);\\\n    float xtra = 1. - abs(p-rp) / ribbonPickWidth;\\\n    rx = max(rx, xtra);\\\n  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n`; ///gl  //comment closes the glsl section\nCSynth.startdemo();\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nvarying vec4 opos;\nvoid main ()\n{\n  vec2 tmpvar_1;\n  tmpvar_1.x = cutx;\n  tmpvar_1.y = cuty;\n  highp vec2 tmpvar_2;\n  tmpvar_2 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_1);\n  if ((((tmpvar_2.x * tmpvar_2.x) + (tmpvar_2.y * tmpvar_2.y)) > 1.0)) {\n    discard;\n  };\n  gl_FragColor.xyw = opos.xyw;\n  gl_FragColor.z = floor((opos.z + 0.1));\n  mediump float tmpvar_3;\n  if (gl_FrontFacing) {\n    tmpvar_3 = floor((opos.w + 0.5));\n  } else {\n    tmpvar_3 = 99.0;\n  };\n  gl_FragColor.w = tmpvar_3;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform sampler2D t_ribbonrad;\nuniform float killrads[4];\nuniform vec3 awayvec;\nuniform vec4 _camd;\nuniform vec3 clearposA0;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nfloat ribs;\nuniform float nstar;\nuniform float stardepth;\nuniform float ribdepth;\nuniform float R_ribs;\nuniform float R_radius;\nuniform float cumcount3;\nuniform float wigmult;\nuniform float scaleFactor;\nuniform float ribbonPickWidth;\nuniform float ribbonPickExtra;\nuniform float endblobs;\nuniform float endbloblen;\nuniform float killradwidth;\nuniform mat4 rot4;\nuniform float pointSize;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvarying vec4 opos;\nfloat xhornid;\nuniform sampler2D pickrt;\nuniform float capres;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float lennum;\nuniform float skelnum;\nuniform float skelends;\nuniform vec2 skelbufferRes;\nuniform sampler2D skelbuffer;\nuniform sampler2D scaleDampTarget;\nuniform float NORMTYPE;\nuniform float USELOGDEPTH;\nvoid main ()\n{\n  xhornid = -99.0;\n  lowp vec4 ooo_1;\n  vec4 p_2;\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xy = position.xy;\n  tmpvar_3.z = (instanceID + fakeinstanceID);\n  p_2.zw = tmpvar_3.zw;\n  p_2.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_2.y = (p_2.y * 0.5);\n  };\n  opos = p_2;\n  if ((tmpvar_3.z < cumcount3)) {\n    xhornid = 3.0;\n    ribs = R_ribs;\n  } else {\n    xhornid = -1.0;\n    ribs = 77.0;\n  };\n  lowp vec3 xmnormal_4;\n  lowp vec3 surfpos_5;\n  float fac_6;\n  float lk_7;\n  lowp float xrscalea_8;\n  float sss_9;\n  float star1_10;\n  float tmpvar_11;\n  tmpvar_11 = floor(((lennum * capres) * 0.5));\n  float tmpvar_12;\n  tmpvar_12 = (lennum - (2.0 * tmpvar_11));\n  float tmpvar_13;\n  tmpvar_13 = -(tmpvar_11);\n  float tmpvar_14;\n  tmpvar_14 = (tmpvar_13 + (p_2.x * (\n    (tmpvar_12 + tmpvar_11)\n   - tmpvar_13)));\n  float tmpvar_15;\n  tmpvar_15 = clamp ((tmpvar_14 / tmpvar_12), 0.0, 1.0);\n  lowp vec3 rad1a_16;\n  lowp vec3 skela3_17;\n  lowp vec3 step_18;\n  float tmpvar_19;\n  tmpvar_19 = floor((tmpvar_15 * skelnum));\n  float tmpvar_20;\n  tmpvar_20 = ((tmpvar_15 * skelnum) - tmpvar_19);\n  float tmpvar_21;\n  tmpvar_21 = (skelnum + (2.0 * skelends));\n  vec2 tmpvar_22;\n  tmpvar_22.x = (floor((\n    (min (tmpvar_21, (tmpvar_19 - 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_22.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_23;\n  tmpvar_23 = texture2D (skelbuffer, (tmpvar_22 / skelbufferRes));\n  vec2 tmpvar_24;\n  tmpvar_24.x = (floor((\n    (min (tmpvar_21, tmpvar_19) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_24.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_25;\n  tmpvar_25 = texture2D (skelbuffer, (tmpvar_24 / skelbufferRes));\n  vec2 tmpvar_26;\n  tmpvar_26.x = (floor((\n    (min (tmpvar_21, (tmpvar_19 + 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_26.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_27;\n  tmpvar_27 = texture2D (skelbuffer, (tmpvar_26 / skelbufferRes));\n  vec2 tmpvar_28;\n  tmpvar_28.x = (floor((\n    (min (tmpvar_21, (tmpvar_19 + 2.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_28.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_29;\n  tmpvar_29 = texture2D (skelbuffer, (tmpvar_28 / skelbufferRes));\n  lowp vec4 tmpvar_30;\n  tmpvar_30 = (((\n    (-0.5 * tmpvar_23)\n   + \n    (1.5 * tmpvar_25)\n  ) - (1.5 * tmpvar_27)) + (0.5 * tmpvar_29));\n  lowp vec4 tmpvar_31;\n  tmpvar_31 = (((tmpvar_23 - \n    (2.5 * tmpvar_25)\n  ) + (2.0 * tmpvar_27)) - (0.5 * tmpvar_29));\n  lowp vec4 tmpvar_32;\n  tmpvar_32 = ((-0.5 * tmpvar_23) + (0.5 * tmpvar_27));\n  step_18 = (((\n    (3.0 * tmpvar_30)\n   * \n    (tmpvar_20 * tmpvar_20)\n  ) + (\n    (2.0 * tmpvar_31)\n   * tmpvar_20)) + tmpvar_32).xyz;\n  skela3_17 = (((\n    ((tmpvar_30 * tmpvar_20) * (tmpvar_20 * tmpvar_20))\n   + \n    ((tmpvar_31 * tmpvar_20) * tmpvar_20)\n  ) + (tmpvar_32 * tmpvar_20)) + tmpvar_25).xyz;\n  lowp float r_33;\n  vec2 tmpvar_34;\n  tmpvar_34.y = 0.5;\n  tmpvar_34.x = tmpvar_15;\n  lowp vec4 tmpvar_35;\n  tmpvar_35 = texture2D (t_ribbonrad, tmpvar_34);\n  r_33 = (scaleFactor * (R_radius + (tmpvar_35.x * wigmult)));\n  if (((wigmult < 0.0) && (tmpvar_35.x != 0.0))) {\n    r_33 = -0.1;\n  };\n  if ((ribbonPickExtra != 0.0)) {\n    lowp float rx_36;\n    rx_36 = max (0.0, (1.0 - (\n      abs((texture2D (pickrt, vec2(0.0, 0.5)).x - tmpvar_15))\n     / ribbonPickWidth)));\n    lowp vec4 tmpvar_37;\n    tmpvar_37 = texture2D (pickrt, vec2(0.25, 0.5));\n    rx_36 = max (rx_36, (1.0 - (\n      abs((tmpvar_37.x - tmpvar_15))\n     / ribbonPickWidth)));\n    rx_36 = max (rx_36, (1.0 - (\n      abs((tmpvar_37.y - tmpvar_15))\n     / ribbonPickWidth)));\n    rx_36 = max (rx_36, (1.0 - (\n      abs((texture2D (pickrt, vec2(0.5, 0.5)).x - tmpvar_15))\n     / ribbonPickWidth)));\n    lowp vec4 tmpvar_38;\n    tmpvar_38 = texture2D (pickrt, vec2(0.75, 0.5));\n    rx_36 = max (rx_36, (1.0 - (\n      abs((tmpvar_38.x - tmpvar_15))\n     / ribbonPickWidth)));\n    lowp float tmpvar_39;\n    tmpvar_39 = max (rx_36, (1.0 - (\n      abs((tmpvar_38.y - tmpvar_15))\n     / ribbonPickWidth)));\n    rx_36 = tmpvar_39;\n    r_33 = (r_33 + (ribbonPickExtra * tmpvar_39));\n  };\n  float tmpvar_40;\n  tmpvar_40 = abs(((tmpvar_15 * \n    (numSegs + 1.0)\n  ) - killrads[0]));\n  if ((tmpvar_40 <= killradwidth)) {\n    r_33 = -0.1;\n  };\n  float tmpvar_41;\n  tmpvar_41 = abs(((tmpvar_15 * \n    (numSegs + 1.0)\n  ) - killrads[1]));\n  if ((tmpvar_41 <= killradwidth)) {\n    r_33 = -0.1;\n  };\n  float tmpvar_42;\n  tmpvar_42 = abs(((tmpvar_15 * \n    (numSegs + 1.0)\n  ) - killrads[2]));\n  if ((tmpvar_42 <= killradwidth)) {\n    r_33 = -0.1;\n  };\n  float tmpvar_43;\n  tmpvar_43 = abs(((tmpvar_15 * \n    (numSegs + 1.0)\n  ) - killrads[3]));\n  if ((tmpvar_43 <= killradwidth)) {\n    r_33 = -0.1;\n  };\n  float tmpvar_44;\n  tmpvar_44 = (max ((endbloblen - tmpvar_15), (\n    (-1.0 + endbloblen)\n   + tmpvar_15)) / endbloblen);\n  if ((tmpvar_44 > 0.0)) {\n    r_33 = (r_33 * sqrt(max (0.0, \n      (((1.0 + cos(\n        (((1.0 - tmpvar_44) * 6.28318) * endblobs)\n      )) * 0.5) * (1.0 - tmpvar_44))\n    )));\n  };\n  lowp float tmpvar_45;\n  tmpvar_45 = sqrt(dot (step_18, step_18));\n  lowp vec3 tmpvar_46;\n  if ((tmpvar_45 == 0.0)) {\n    tmpvar_46 = vec3(0.0, 1.0, 0.0);\n  } else {\n    tmpvar_46 = (step_18 / tmpvar_45);\n  };\n  lowp vec4 tmpvar_47;\n  tmpvar_47.w = 1.0;\n  tmpvar_47.xyz = skela3_17;\n  if (((tmpvar_45 == 0.0) || (NORMTYPE == 0.0))) {\n    rad1a_16 = vec3(1.0, 0.0, 0.0);\n  } else {\n    if ((NORMTYPE == 1.0)) {\n      rad1a_16 = ((tmpvar_46.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_46.zxy * vec3(1.3, 2.1, 1.0)));\n    } else {\n      if ((NORMTYPE == 2.0)) {\n        vec2 tmpvar_48;\n        tmpvar_48.x = 0.5;\n        tmpvar_48.y = (((\n          (tmpvar_15 - 0.09)\n         * numSegs) + 0.5) / numInstancesP2);\n        lowp vec4 tmpvar_49;\n        tmpvar_49.xyz = ((texture2D (posNewvals, tmpvar_48) * scaleFactor).xyz - texture2D (scaleDampTarget, vec2(0.5, 0.5)).xyz);\n        tmpvar_49.w = 1.0;\n        lowp vec3 b_50;\n        b_50 = (tmpvar_49.xyz - skela3_17);\n        rad1a_16 = ((tmpvar_46.yzx * b_50.zxy) - (tmpvar_46.zxy * b_50.yzx));\n      } else {\n        if ((NORMTYPE == 3.0)) {\n          vec2 tmpvar_51;\n          tmpvar_51.x = 0.5;\n          tmpvar_51.y = (((\n            (tmpvar_15 - 0.09)\n           * numSegs) + 0.5) / numInstancesP2);\n          lowp vec4 tmpvar_52;\n          tmpvar_52.xyz = ((texture2D (posNewvals, tmpvar_51) * scaleFactor).xyz - texture2D (scaleDampTarget, vec2(0.5, 0.5)).xyz);\n          tmpvar_52.w = 1.0;\n          lowp vec3 tmpvar_53;\n          lowp vec3 b_54;\n          b_54 = (tmpvar_52.xyz - skela3_17);\n          tmpvar_53 = ((tmpvar_46.yzx * b_54.zxy) - (tmpvar_46.zxy * b_54.yzx));\n          rad1a_16 = tmpvar_53;\n          lowp float tmpvar_55;\n          tmpvar_55 = dot (tmpvar_53, tmpvar_53);\n          if ((tmpvar_55 < 1e-6)) {\n            rad1a_16 = ((tmpvar_46.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_46.zxy * vec3(1.3, 2.1, 1.0)));\n          };\n        } else {\n          if ((NORMTYPE == 4.0)) {\n            lowp float z_56;\n            lowp float x_57;\n            vec2 tmpvar_58;\n            tmpvar_58.x = 0.5;\n            tmpvar_58.y = (((tmpvar_15 * numSegs) + 0.5) / numInstancesP2);\n            lowp vec4 tmpvar_59;\n            tmpvar_59 = (texture2D (posNewvals, tmpvar_58) * scaleFactor);\n            x_57 = (0.013 + tmpvar_59.x);\n            z_56 = (0.017 + tmpvar_59.z);\n            lowp vec4 tmpvar_60;\n            tmpvar_60 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n            x_57 = (x_57 - tmpvar_60.x);\n            z_56 = (z_56 - tmpvar_60.z);\n            lowp vec4 tmpvar_61;\n            tmpvar_61.x = x_57;\n            tmpvar_61.y = (tmpvar_59.y - tmpvar_60.y);\n            tmpvar_61.z = z_56;\n            tmpvar_61.w = 1.0;\n            lowp vec3 b_62;\n            b_62 = (tmpvar_61.xyz - skela3_17);\n            rad1a_16 = ((tmpvar_46.yzx * b_62.zxy) - (tmpvar_46.zxy * b_62.yzx));\n          } else {\n            if ((NORMTYPE == 5.0)) {\n              mat3 tmpvar_63;\n              tmpvar_63[0] = rot4[0].xyz;\n              tmpvar_63[1] = rot4[1].xyz;\n              tmpvar_63[2] = rot4[2].xyz;\n              lowp vec3 tmpvar_64;\n              tmpvar_64 = normalize((tmpvar_63 * (clearposA0 - \n                (tmpvar_47 * rot4)\n              .xyz)));\n              rad1a_16 = ((tmpvar_64.yzx * tmpvar_46.zxy) - (tmpvar_64.zxy * tmpvar_46.yzx));\n            } else {\n              if ((NORMTYPE == 6.0)) {\n                rad1a_16 = ((awayvec.yzx * tmpvar_46.zxy) - (awayvec.zxy * tmpvar_46.yzx));\n              } else {\n                rad1a_16 = vec3(0.0, 0.0, 1.0);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  float tmpvar_65;\n  tmpvar_65 = (p_2.y * nstar);\n  star1_10 = tmpvar_65;\n  sss_9 = 1.0;\n  float tmpvar_66;\n  tmpvar_66 = floor(nstar);\n  if ((tmpvar_65 > tmpvar_66)) {\n    float tmpvar_67;\n    tmpvar_67 = fract(nstar);\n    sss_9 = tmpvar_67;\n    float tmpvar_68;\n    tmpvar_68 = floor(nstar);\n    star1_10 = (tmpvar_68 + ((tmpvar_65 - tmpvar_68) / tmpvar_67));\n  };\n  lowp float tmpvar_69;\n  tmpvar_69 = (r_33 * (1.0 - (\n    (1.0 - (((1.0 - \n      cos((6.28318 * star1_10))\n    ) * sss_9) * sss_9))\n   * stardepth)));\n  xrscalea_8 = tmpvar_69;\n  lk_7 = 0.0;\n  fac_6 = 1.0;\n  if (((0.0 < tmpvar_14) && (tmpvar_14 < tmpvar_12))) {\n    lk_7 = ((p_2.x * ribs) + 0.5);\n    float tmpvar_70;\n    tmpvar_70 = abs((fract(lk_7) - 0.5));\n    lk_7 = tmpvar_70;\n    float tmpvar_71;\n    tmpvar_71 = sqrt((1.0 - (\n      (ribdepth * tmpvar_70)\n     * tmpvar_70)));\n    fac_6 = tmpvar_71;\n    xrscalea_8 = (tmpvar_69 * tmpvar_71);\n  };\n  lowp vec3 tmpvar_72;\n  tmpvar_72 = normalize(rad1a_16);\n  xmnormal_4 = ((-(\n    sin((6.28318 * p_2.y))\n  ) * -(\n    normalize(((tmpvar_46.yzx * tmpvar_72.zxy) - (tmpvar_46.zxy * tmpvar_72.yzx)))\n  )) + (cos(\n    (6.28318 * p_2.y)\n  ) * tmpvar_72));\n  surfpos_5 = (skela3_17 + (xrscalea_8 * xmnormal_4));\n  xmnormal_4 = (xmnormal_4 + (tmpvar_46 * (\n    (ribdepth * lk_7)\n   / fac_6)));\n  lowp vec3 tmpvar_73;\n  tmpvar_73 = normalize(xmnormal_4);\n  xmnormal_4 = tmpvar_73;\n  if ((tmpvar_14 > tmpvar_12)) {\n    float tmpvar_74;\n    tmpvar_74 = (((\n      (tmpvar_14 - tmpvar_12)\n     / tmpvar_11) * 3.14159) / 2.0);\n    surfpos_5 = (skela3_17 + (xrscalea_8 * (\n      (sin(tmpvar_74) * tmpvar_46)\n     + \n      (cos(tmpvar_74) * tmpvar_73)\n    )));\n  };\n  if ((tmpvar_14 < 0.0)) {\n    float tmpvar_75;\n    tmpvar_75 = (((tmpvar_14 / tmpvar_11) * 3.14159) / 2.0);\n    surfpos_5 = (skela3_17 + (xrscalea_8 * (\n      (sin(tmpvar_75) * tmpvar_46)\n     + \n      (cos(tmpvar_75) * tmpvar_73)\n    )));\n  };\n  xmnormal_4 = tmpvar_73;\n  lowp vec4 tmpvar_76;\n  tmpvar_76.xyz = surfpos_5;\n  tmpvar_76.w = 1.0;\n  gl_PointSize = pointSize;\n  lowp vec4 tmpvar_77;\n  tmpvar_77.w = 1.0;\n  tmpvar_77.xyz = (tmpvar_76 * rot4).xyz;\n  ooo_1 = (projectionMatrix * (modelViewMatrix * tmpvar_77));\n  lowp vec4 ooo_78;\n  ooo_78 = ooo_1;\n  if ((USELOGDEPTH > 0.0)) {\n    ooo_78.xy = (ooo_1.xy / ooo_1.w);\n    ooo_78.w = 1.0;\n    ooo_78.z = (((\n      (log(ooo_1.w) - _camd.z)\n     * _camd.w) * 2.0) - 1.0);\n  } else {\n    if ((USELOGDEPTH < 0.0)) {\n      ooo_78.z = (log2(max (1e-6, \n        (ooo_78.w + 1.0)\n      )) * 0.15);\n      ooo_78.z = ((ooo_78.z - 1.0) * ooo_78.w);\n    };\n  };\n  ooo_1 = ooo_78;\n  gl_Position = ooo_78;\n  opos.xyz = p_2.xyz;\n  opos.w = xhornid;\n}\n\n"},"horn(\"R\").ribs(#R_ribs#).radius(#R_radius#).code(\"vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;\").code(\"#define SKELPICK\");\nmainhorn=\"R\";\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) {     float p = getPickC(i);    float xtra = 1. - abs(p-rp) / ribbonPickWidth;    rx = max(rx, xtra);  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nvarying vec4 opos;\nvoid main ()\n{\n  vec2 tmpvar_1;\n  tmpvar_1.x = cutx;\n  tmpvar_1.y = cuty;\n  highp vec2 tmpvar_2;\n  tmpvar_2 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_1);\n  if ((((tmpvar_2.x * tmpvar_2.x) + (tmpvar_2.y * tmpvar_2.y)) > 1.0)) {\n    discard;\n  };\n  gl_FragColor.xyw = opos.xyw;\n  gl_FragColor.z = floor((opos.z + 0.1));\n  mediump float tmpvar_3;\n  if (gl_FrontFacing) {\n    tmpvar_3 = floor((opos.w + 0.5));\n  } else {\n    tmpvar_3 = 99.0;\n  };\n  gl_FragColor.w = tmpvar_3;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform sampler2D t_ribbonrad;\nuniform float killrads[4];\nuniform vec3 awayvec;\nuniform vec4 _camd;\nuniform vec3 clearposA0;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nfloat ribs;\nuniform float nstar;\nuniform float stardepth;\nuniform float ribdepth;\nuniform float R_ribs;\nuniform float R_radius;\nuniform float cumcount3;\nuniform float wigmult;\nuniform float scaleFactor;\nuniform float ribbonPickWidth;\nuniform float ribbonPickExtra;\nuniform float endblobs;\nuniform float endbloblen;\nuniform float killradwidth;\nuniform mat4 rot4;\nuniform float pointSize;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvarying vec4 opos;\nfloat xhornid;\nuniform sampler2D pickrt;\nuniform float capres;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float lennum;\nuniform float skelnum;\nuniform float skelends;\nuniform vec2 skelbufferRes;\nuniform sampler2D skelbuffer;\nuniform sampler2D scaleDampTarget;\nuniform float NORMTYPE;\nuniform float USELOGDEPTH;\nvoid main ()\n{\n  xhornid = -99.0;\n  lowp vec4 ooo_1;\n  vec4 p_2;\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xy = position.xy;\n  tmpvar_3.z = (instanceID + fakeinstanceID);\n  p_2.zw = tmpvar_3.zw;\n  p_2.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_2.y = (p_2.y * 0.5);\n  };\n  opos = p_2;\n  if ((tmpvar_3.z < cumcount3)) {\n    xhornid = 3.0;\n    ribs = R_ribs;\n  } else {\n    xhornid = -1.0;\n    ribs = 77.0;\n  };\n  lowp vec3 xmnormal_4;\n  lowp vec3 surfpos_5;\n  float fac_6;\n  float lk_7;\n  lowp float xrscalea_8;\n  float sss_9;\n  float star1_10;\n  float tmpvar_11;\n  tmpvar_11 = floor(((lennum * capres) * 0.5));\n  float tmpvar_12;\n  tmpvar_12 = (lennum - (2.0 * tmpvar_11));\n  float tmpvar_13;\n  tmpvar_13 = -(tmpvar_11);\n  float tmpvar_14;\n  tmpvar_14 = (tmpvar_13 + (p_2.x * (\n    (tmpvar_12 + tmpvar_11)\n   - tmpvar_13)));\n  float tmpvar_15;\n  tmpvar_15 = clamp ((tmpvar_14 / tmpvar_12), 0.0, 1.0);\n  lowp vec3 rad1a_16;\n  lowp vec3 skela3_17;\n  lowp vec3 step_18;\n  float tmpvar_19;\n  tmpvar_19 = floor((tmpvar_15 * skelnum));\n  float tmpvar_20;\n  tmpvar_20 = ((tmpvar_15 * skelnum) - tmpvar_19);\n  float tmpvar_21;\n  tmpvar_21 = (skelnum + (2.0 * skelends));\n  vec2 tmpvar_22;\n  tmpvar_22.x = (floor((\n    (min (tmpvar_21, (tmpvar_19 - 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_22.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_23;\n  tmpvar_23 = texture2D (skelbuffer, (tmpvar_22 / skelbufferRes));\n  vec2 tmpvar_24;\n  tmpvar_24.x = (floor((\n    (min (tmpvar_21, tmpvar_19) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_24.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_25;\n  tmpvar_25 = texture2D (skelbuffer, (tmpvar_24 / skelbufferRes));\n  vec2 tmpvar_26;\n  tmpvar_26.x = (floor((\n    (min (tmpvar_21, (tmpvar_19 + 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_26.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_27;\n  tmpvar_27 = texture2D (skelbuffer, (tmpvar_26 / skelbufferRes));\n  vec2 tmpvar_28;\n  tmpvar_28.x = (floor((\n    (min (tmpvar_21, (tmpvar_19 + 2.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_28.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_29;\n  tmpvar_29 = texture2D (skelbuffer, (tmpvar_28 / skelbufferRes));\n  lowp vec4 tmpvar_30;\n  tmpvar_30 = (((\n    (-0.5 * tmpvar_23)\n   + \n    (1.5 * tmpvar_25)\n  ) - (1.5 * tmpvar_27)) + (0.5 * tmpvar_29));\n  lowp vec4 tmpvar_31;\n  tmpvar_31 = (((tmpvar_23 - \n    (2.5 * tmpvar_25)\n  ) + (2.0 * tmpvar_27)) - (0.5 * tmpvar_29));\n  lowp vec4 tmpvar_32;\n  tmpvar_32 = ((-0.5 * tmpvar_23) + (0.5 * tmpvar_27));\n  step_18 = (((\n    (3.0 * tmpvar_30)\n   * \n    (tmpvar_20 * tmpvar_20)\n  ) + (\n    (2.0 * tmpvar_31)\n   * tmpvar_20)) + tmpvar_32).xyz;\n  skela3_17 = (((\n    ((tmpvar_30 * tmpvar_20) * (tmpvar_20 * tmpvar_20))\n   + \n    ((tmpvar_31 * tmpvar_20) * tmpvar_20)\n  ) + (tmpvar_32 * tmpvar_20)) + tmpvar_25).xyz;\n  lowp float r_33;\n  vec2 tmpvar_34;\n  tmpvar_34.y = 0.5;\n  tmpvar_34.x = tmpvar_15;\n  lowp vec4 tmpvar_35;\n  tmpvar_35 = texture2D (t_ribbonrad, tmpvar_34);\n  r_33 = (scaleFactor * (R_radius + (tmpvar_35.x * wigmult)));\n  if (((wigmult < 0.0) && (tmpvar_35.x != 0.0))) {\n    r_33 = -0.1;\n  };\n  if ((ribbonPickExtra != 0.0)) {\n    lowp float rx_36;\n    rx_36 = max (0.0, (1.0 - (\n      abs((texture2D (pickrt, vec2(0.0, 0.5)).x - tmpvar_15))\n     / ribbonPickWidth)));\n    lowp vec4 tmpvar_37;\n    tmpvar_37 = texture2D (pickrt, vec2(0.25, 0.5));\n    rx_36 = max (rx_36, (1.0 - (\n      abs((tmpvar_37.x - tmpvar_15))\n     / ribbonPickWidth)));\n    rx_36 = max (rx_36, (1.0 - (\n      abs((tmpvar_37.y - tmpvar_15))\n     / ribbonPickWidth)));\n    rx_36 = max (rx_36, (1.0 - (\n      abs((texture2D (pickrt, vec2(0.5, 0.5)).x - tmpvar_15))\n     / ribbonPickWidth)));\n    lowp vec4 tmpvar_38;\n    tmpvar_38 = texture2D (pickrt, vec2(0.75, 0.5));\n    rx_36 = max (rx_36, (1.0 - (\n      abs((tmpvar_38.x - tmpvar_15))\n     / ribbonPickWidth)));\n    lowp float tmpvar_39;\n    tmpvar_39 = max (rx_36, (1.0 - (\n      abs((tmpvar_38.y - tmpvar_15))\n     / ribbonPickWidth)));\n    rx_36 = tmpvar_39;\n    r_33 = (r_33 + (ribbonPickExtra * tmpvar_39));\n  };\n  float tmpvar_40;\n  tmpvar_40 = abs(((tmpvar_15 * \n    (numSegs + 1.0)\n  ) - killrads[0]));\n  if ((tmpvar_40 <= killradwidth)) {\n    r_33 = -0.1;\n  };\n  float tmpvar_41;\n  tmpvar_41 = abs(((tmpvar_15 * \n    (numSegs + 1.0)\n  ) - killrads[1]));\n  if ((tmpvar_41 <= killradwidth)) {\n    r_33 = -0.1;\n  };\n  float tmpvar_42;\n  tmpvar_42 = abs(((tmpvar_15 * \n    (numSegs + 1.0)\n  ) - killrads[2]));\n  if ((tmpvar_42 <= killradwidth)) {\n    r_33 = -0.1;\n  };\n  float tmpvar_43;\n  tmpvar_43 = abs(((tmpvar_15 * \n    (numSegs + 1.0)\n  ) - killrads[3]));\n  if ((tmpvar_43 <= killradwidth)) {\n    r_33 = -0.1;\n  };\n  float tmpvar_44;\n  tmpvar_44 = (max ((endbloblen - tmpvar_15), (\n    (-1.0 + endbloblen)\n   + tmpvar_15)) / endbloblen);\n  if ((tmpvar_44 > 0.0)) {\n    r_33 = (r_33 * sqrt(max (0.0, \n      (((1.0 + cos(\n        (((1.0 - tmpvar_44) * 6.28318) * endblobs)\n      )) * 0.5) * (1.0 - tmpvar_44))\n    )));\n  };\n  lowp float tmpvar_45;\n  tmpvar_45 = sqrt(dot (step_18, step_18));\n  lowp vec3 tmpvar_46;\n  if ((tmpvar_45 == 0.0)) {\n    tmpvar_46 = vec3(0.0, 1.0, 0.0);\n  } else {\n    tmpvar_46 = (step_18 / tmpvar_45);\n  };\n  lowp vec4 tmpvar_47;\n  tmpvar_47.w = 1.0;\n  tmpvar_47.xyz = skela3_17;\n  if (((tmpvar_45 == 0.0) || (NORMTYPE == 0.0))) {\n    rad1a_16 = vec3(1.0, 0.0, 0.0);\n  } else {\n    if ((NORMTYPE == 1.0)) {\n      rad1a_16 = ((tmpvar_46.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_46.zxy * vec3(1.3, 2.1, 1.0)));\n    } else {\n      if ((NORMTYPE == 2.0)) {\n        vec2 tmpvar_48;\n        tmpvar_48.x = 0.5;\n        tmpvar_48.y = (((\n          (tmpvar_15 - 0.09)\n         * numSegs) + 0.5) / numInstancesP2);\n        lowp vec4 tmpvar_49;\n        tmpvar_49.xyz = ((texture2D (posNewvals, tmpvar_48) * scaleFactor).xyz - texture2D (scaleDampTarget, vec2(0.5, 0.5)).xyz);\n        tmpvar_49.w = 1.0;\n        lowp vec3 b_50;\n        b_50 = (tmpvar_49.xyz - skela3_17);\n        rad1a_16 = ((tmpvar_46.yzx * b_50.zxy) - (tmpvar_46.zxy * b_50.yzx));\n      } else {\n        if ((NORMTYPE == 3.0)) {\n          vec2 tmpvar_51;\n          tmpvar_51.x = 0.5;\n          tmpvar_51.y = (((\n            (tmpvar_15 - 0.09)\n           * numSegs) + 0.5) / numInstancesP2);\n          lowp vec4 tmpvar_52;\n          tmpvar_52.xyz = ((texture2D (posNewvals, tmpvar_51) * scaleFactor).xyz - texture2D (scaleDampTarget, vec2(0.5, 0.5)).xyz);\n          tmpvar_52.w = 1.0;\n          lowp vec3 tmpvar_53;\n          lowp vec3 b_54;\n          b_54 = (tmpvar_52.xyz - skela3_17);\n          tmpvar_53 = ((tmpvar_46.yzx * b_54.zxy) - (tmpvar_46.zxy * b_54.yzx));\n          rad1a_16 = tmpvar_53;\n          lowp float tmpvar_55;\n          tmpvar_55 = dot (tmpvar_53, tmpvar_53);\n          if ((tmpvar_55 < 1e-6)) {\n            rad1a_16 = ((tmpvar_46.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_46.zxy * vec3(1.3, 2.1, 1.0)));\n          };\n        } else {\n          if ((NORMTYPE == 4.0)) {\n            lowp float z_56;\n            lowp float x_57;\n            vec2 tmpvar_58;\n            tmpvar_58.x = 0.5;\n            tmpvar_58.y = (((tmpvar_15 * numSegs) + 0.5) / numInstancesP2);\n            lowp vec4 tmpvar_59;\n            tmpvar_59 = (texture2D (posNewvals, tmpvar_58) * scaleFactor);\n            x_57 = (0.013 + tmpvar_59.x);\n            z_56 = (0.017 + tmpvar_59.z);\n            lowp vec4 tmpvar_60;\n            tmpvar_60 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n            x_57 = (x_57 - tmpvar_60.x);\n            z_56 = (z_56 - tmpvar_60.z);\n            lowp vec4 tmpvar_61;\n            tmpvar_61.x = x_57;\n            tmpvar_61.y = (tmpvar_59.y - tmpvar_60.y);\n            tmpvar_61.z = z_56;\n            tmpvar_61.w = 1.0;\n            lowp vec3 b_62;\n            b_62 = (tmpvar_61.xyz - skela3_17);\n            rad1a_16 = ((tmpvar_46.yzx * b_62.zxy) - (tmpvar_46.zxy * b_62.yzx));\n          } else {\n            if ((NORMTYPE == 5.0)) {\n              mat3 tmpvar_63;\n              tmpvar_63[0] = rot4[0].xyz;\n              tmpvar_63[1] = rot4[1].xyz;\n              tmpvar_63[2] = rot4[2].xyz;\n              lowp vec3 tmpvar_64;\n              tmpvar_64 = normalize((tmpvar_63 * (clearposA0 - \n                (tmpvar_47 * rot4)\n              .xyz)));\n              rad1a_16 = ((tmpvar_64.yzx * tmpvar_46.zxy) - (tmpvar_64.zxy * tmpvar_46.yzx));\n            } else {\n              if ((NORMTYPE == 6.0)) {\n                rad1a_16 = ((awayvec.yzx * tmpvar_46.zxy) - (awayvec.zxy * tmpvar_46.yzx));\n              } else {\n                rad1a_16 = vec3(0.0, 0.0, 1.0);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  float tmpvar_65;\n  tmpvar_65 = (p_2.y * nstar);\n  star1_10 = tmpvar_65;\n  sss_9 = 1.0;\n  float tmpvar_66;\n  tmpvar_66 = floor(nstar);\n  if ((tmpvar_65 > tmpvar_66)) {\n    float tmpvar_67;\n    tmpvar_67 = fract(nstar);\n    sss_9 = tmpvar_67;\n    float tmpvar_68;\n    tmpvar_68 = floor(nstar);\n    star1_10 = (tmpvar_68 + ((tmpvar_65 - tmpvar_68) / tmpvar_67));\n  };\n  lowp float tmpvar_69;\n  tmpvar_69 = (r_33 * (1.0 - (\n    (1.0 - (((1.0 - \n      cos((6.28318 * star1_10))\n    ) * sss_9) * sss_9))\n   * stardepth)));\n  xrscalea_8 = tmpvar_69;\n  lk_7 = 0.0;\n  fac_6 = 1.0;\n  if (((0.0 < tmpvar_14) && (tmpvar_14 < tmpvar_12))) {\n    lk_7 = ((p_2.x * ribs) + 0.5);\n    float tmpvar_70;\n    tmpvar_70 = abs((fract(lk_7) - 0.5));\n    lk_7 = tmpvar_70;\n    float tmpvar_71;\n    tmpvar_71 = sqrt((1.0 - (\n      (ribdepth * tmpvar_70)\n     * tmpvar_70)));\n    fac_6 = tmpvar_71;\n    xrscalea_8 = (tmpvar_69 * tmpvar_71);\n  };\n  lowp vec3 tmpvar_72;\n  tmpvar_72 = normalize(rad1a_16);\n  xmnormal_4 = ((-(\n    sin((6.28318 * p_2.y))\n  ) * -(\n    normalize(((tmpvar_46.yzx * tmpvar_72.zxy) - (tmpvar_46.zxy * tmpvar_72.yzx)))\n  )) + (cos(\n    (6.28318 * p_2.y)\n  ) * tmpvar_72));\n  surfpos_5 = (skela3_17 + (xrscalea_8 * xmnormal_4));\n  xmnormal_4 = (xmnormal_4 + (tmpvar_46 * (\n    (ribdepth * lk_7)\n   / fac_6)));\n  lowp vec3 tmpvar_73;\n  tmpvar_73 = normalize(xmnormal_4);\n  xmnormal_4 = tmpvar_73;\n  if ((tmpvar_14 > tmpvar_12)) {\n    float tmpvar_74;\n    tmpvar_74 = (((\n      (tmpvar_14 - tmpvar_12)\n     / tmpvar_11) * 3.14159) / 2.0);\n    surfpos_5 = (skela3_17 + (xrscalea_8 * (\n      (sin(tmpvar_74) * tmpvar_46)\n     + \n      (cos(tmpvar_74) * tmpvar_73)\n    )));\n  };\n  if ((tmpvar_14 < 0.0)) {\n    float tmpvar_75;\n    tmpvar_75 = (((tmpvar_14 / tmpvar_11) * 3.14159) / 2.0);\n    surfpos_5 = (skela3_17 + (xrscalea_8 * (\n      (sin(tmpvar_75) * tmpvar_46)\n     + \n      (cos(tmpvar_75) * tmpvar_73)\n    )));\n  };\n  xmnormal_4 = tmpvar_73;\n  lowp vec4 tmpvar_76;\n  tmpvar_76.xyz = surfpos_5;\n  tmpvar_76.w = 1.0;\n  gl_PointSize = pointSize;\n  lowp vec4 tmpvar_77;\n  tmpvar_77.w = 1.0;\n  tmpvar_77.xyz = (tmpvar_76 * rot4).xyz;\n  ooo_1 = (projectionMatrix * (modelViewMatrix * tmpvar_77));\n  lowp vec4 ooo_78;\n  ooo_78 = ooo_1;\n  if ((USELOGDEPTH > 0.0)) {\n    ooo_78.xy = (ooo_1.xy / ooo_1.w);\n    ooo_78.w = 1.0;\n    ooo_78.z = (((\n      (log(ooo_1.w) - _camd.z)\n     * _camd.w) * 2.0) - 1.0);\n  } else {\n    if ((USELOGDEPTH < 0.0)) {\n      ooo_78.z = (log2(max (1e-6, \n        (ooo_78.w + 1.0)\n      )) * 0.15);\n      ooo_78.z = ((ooo_78.z - 1.0) * ooo_78.w);\n    };\n  };\n  ooo_1 = ooo_78;\n  gl_Position = ooo_78;\n  opos.xyz = p_2.xyz;\n  opos.w = xhornid;\n}\n\n"},"matrix":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nvarying vec4 opos;\nvoid main ()\n{\n  vec2 tmpvar_1;\n  tmpvar_1.x = cutx;\n  tmpvar_1.y = cuty;\n  highp vec2 tmpvar_2;\n  tmpvar_2 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_1);\n  if ((((tmpvar_2.x * tmpvar_2.x) + (tmpvar_2.y * tmpvar_2.y)) > 1.0)) {\n    discard;\n  };\n  gl_FragColor.xyw = opos.xyw;\n  gl_FragColor.z = floor((opos.z + 0.1));\n  mediump float tmpvar_3;\n  if (gl_FrontFacing) {\n    tmpvar_3 = floor((opos.w + 0.5));\n  } else {\n    tmpvar_3 = 99.0;\n  };\n  gl_FragColor.w = tmpvar_3;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform float matskipdiag;\nuniform float matX;\nuniform float matY;\nuniform float matZ;\nuniform float matMinD;\nuniform float matMaxD;\nuniform float minActive;\nuniform float maxActive;\nuniform vec4 _camd;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 rot4;\nuniform float pointSize;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvarying vec4 opos;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float NORMTYPE;\nuniform float USELOGDEPTH;\nvoid main ()\n{\n  lowp vec4 ooo_1;\n  vec4 p_2;\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xy = position.xy;\n  tmpvar_3.z = (instanceID + fakeinstanceID);\n  p_2.zw = tmpvar_3.zw;\n  p_2.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_2.y = (p_2.y * 0.5);\n  };\n  opos = p_2;\n  lowp float id_4;\n  lowp vec4 p_5;\n  p_5 = p_2;\n  float tmpvar_6;\n  tmpvar_6 = (numSegs + 1.0);\n  lowp vec2 tmpvar_7;\n  tmpvar_7.x = 0.0;\n  tmpvar_7.y = (((p_2.x * tmpvar_6) + 0.5) / numInstancesP2);\n  lowp vec2 tmpvar_8;\n  tmpvar_8.x = 0.0;\n  tmpvar_8.y = (((p_2.y * tmpvar_6) + 0.5) / numInstancesP2);\n  lowp vec3 x_9;\n  x_9 = (texture2D (posNewvals, tmpvar_8).xyz - texture2D (posNewvals, tmpvar_7).xyz);\n  id_4 = (1.0/(clamp ((10.0 + \n    (((sqrt(\n      dot (x_9, x_9)\n    ) - matMinD) * 290.0) / (matMaxD - matMinD))\n  ), 10.0, 300.0)));\n  if (((p_2.x - p_2.y) > ((\n    -(matskipdiag)\n   - 2.0) / numSegs))) {\n    id_4 = 0.0;\n  };\n  if (!(((\n    (minActive <= p_2.x)\n   && \n    (p_2.x <= maxActive)\n  ) && (\n    (minActive <= p_2.y)\n   && \n    (p_2.y <= maxActive)\n  )))) {\n    id_4 = 0.0;\n  };\n  lowp float tmpvar_10;\n  if ((matMaxD == 0.0)) {\n    tmpvar_10 = 0.0;\n  } else {\n    tmpvar_10 = id_4;\n  };\n  p_5.x = (p_2.x + matX);\n  p_5.y = (p_2.y + matY);\n  p_5.z = (tmpvar_10 + matZ);\n  gl_PointSize = pointSize;\n  lowp vec4 tmpvar_11;\n  tmpvar_11.w = 1.0;\n  tmpvar_11.xyz = (p_5 * rot4).xyz;\n  ooo_1 = (projectionMatrix * (modelViewMatrix * tmpvar_11));\n  lowp vec4 ooo_12;\n  ooo_12 = ooo_1;\n  if ((USELOGDEPTH > 0.0)) {\n    ooo_12.xy = (ooo_1.xy / ooo_1.w);\n    ooo_12.w = 1.0;\n    ooo_12.z = (((\n      (log(ooo_1.w) - _camd.z)\n     * _camd.w) * 2.0) - 1.0);\n  } else {\n    if ((USELOGDEPTH < 0.0)) {\n      ooo_12.z = (log2(max (1e-6, \n        (ooo_12.w + 1.0)\n      )) * 0.15);\n      ooo_12.z = ((ooo_12.z - 1.0) * ooo_12.w);\n    };\n  };\n  ooo_1 = ooo_12;\n  gl_Position = ooo_12;\n  opos.xyz = p_2.xyz;\n  opos.w = -99.0;\n}\n\n"},"matrix\n    override vec4 tr(const vec4 lopos, out vec3 xmnormal, out vec3 texpos, out float ribnum){\n        pickopos(lopos);\n        vec4 p = lopos;\n        float numInstances = numSegs + 1.;\n        vec3 p1 = histpos((p.x * numInstances + 0.5)/numInstancesP2).xyz;\n        vec3 p2 = histpos((p.y * numInstances + 0.5)/numInstancesP2).xyz;\n        float dist = length(p2 - p1);\n        float d10300 = clamp(map(dist, matMinD, matMaxD, 10., 300.), 10., 300.);// + 0.5;\n        //float id = 1./max(d, 10.);\n        float id = 1./d10300;\n        if (p.x - p.y > (-matskipdiag - 2.)/numSegs) id = 0.;\n\n        #define in(x,l,h) (l <= x && x <= h)\n        if (!(in(p.x, minActive, maxActive) && in(p.y, minActive, maxActive)))\n            id = 0.;\n\n\n        float hd = id; //heightFactor * tanh(id * heightFactor2) / tanh(heightFactor2);\n        p.z = matMaxD == 0. ? 0. : hd;\n        p.x += matX;\n        p.y += matY;\n        p.z += matZ;\n        //p.z = min(0.1, 1./d);\n        //p.xyz *= 8000.;\n        return p;\n    }\n\n    override Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n// #define bimix(a00, a01, a10, a11, x,y) mix( mix(a00,a01, x), mix(a10, a11, x), y)\n        if (texpos.x - texpos.y > -matskipdiag / numSegs) discard;\n        Colsurf c = colsurfd();\n        // float a = clamp(texpos.z/heightFactor, 0., 1.);\n        // a = 0.5 + atan(((2.*a)-1.)*matColCurve) / (2.*atan(matColCurve));\n\n        // recompute distance, info passed in texpos.z not reliable\n        // we should only need to do this where dist is actually used.\n        float numInstances = numSegs + 1.;\n        vec3 pp = round(texpos * numSegs);  // we force lookup of precise position even if posVewVals is using LinearFilter\n        vec3 p1 = histpos((pp.x + 0.5)/numInstancesP2).xyz;\n        vec3 p2 = histpos((pp.y + 0.5)/numInstancesP2).xyz;\n        float dist = length(p2 - p1);\n\n        //''if (texpos.x - texpos.y > (-matskipdiag - 2.)/numSegs) distForCol = 0.;\n\n        //TODO: more structured colour genes\n        //##vec3 col1 = vec3(matcoldr, matcoldg, matcoldb);\n        //##vec3 col2 = vec3(mathotr, mathotg, mathotb);\n        vec3 col1 = vec3(matC00r, matC00g, matC00b);\n        vec3 col2 = vec3(matC11r, matC11g, matC11b);\n    //''c.col.rgb = mix(col1, col2, distForCol);\n        //''c.fluoresc.rgb = rgb2hsv(c.col.rgb);\n\n\n        vec2 tp = (texpos.xy * numSegs + 0.5) / numInstances;\n        float v1 = clamp( nval(matintypeA, matrix2dtexA, tp, dist, matDistNear, matDistFar), 0., 1.);\n        if (matintypeA + matintypeB == 0.) {    // old code\n        } else if (matcoltypeA == matcoltypeB) {\n             c.col.rgb = mix(col1, col2, v1);\n        } else {\n            float v2 = clamp(nval(matintypeB, matrix2dtexB, tp, dist, matDistNear, matDistFar), 0., 1.);\n            /**\n            c.col.rgb = bimix(\n                vec3(matC00r, matC00g, matC00b),\n                vec3(matC01r, matC01g, matC01b),\n                vec3(matC10r, matC10g, matC10b),\n                vec3(matC11r, matC11g, matC11b),\n                clamp(v1, 0., 1.), clamp(v2, 0., 1.));\n            **/\n           // cent is the color down the diagonal\n           // tint is the colour at the off-diagonal corner\n           // overall colour uses amount off-diagonal\n            vec3 cent = mix(vec3(matC00r, matC00g, matC00b), vec3(matC11r, matC11g, matC11b), max(v1, v2));\n\n            vec3 tint = v1 > v2 ? vec3(matC10r, matC10g, matC10b) : vec3(matC01r, matC01g, matC01b);\n            c.col.rgb = mix(cent, tint, clamp(matrixTintStrength*abs(v1-v2), 0.,1.));\n        }\n        c.col.rgb = pow(c.col.rgb, vec3(matgamma));  // better perceptual range\n        c.fluoresc.rgb = rgb2hsv(c.col.rgb);\n\n\n        //TODO uniforms for gridline presentation parameters.\n        //Also need to do something about aliasing. Could consider non-binary logic here.\n        if (matrixgridres != 0.) {\n            float dx = abs(fract(texpos.x*numInstances/matrixgridres));\n            float dy = abs(fract(texpos.y*numInstances/matrixgridres));\n            //dx=dy=1.;  // remove comment to remove the grid bands\n\n            float solidW = matrixgridwidth;\n            float softW = matrixgridsoftw;\n            float softR = 1./softW;\n            float fx = 1. - (clamp(dx - solidW, 0., softW) * softR);\n            float fy = 1. - (clamp(dy - solidW, 0., softW) * softR);\n            float f = min(fx+fy, 1.);\n            c.col.rgb += vec3(0,0.7,0.7) * f;\n            //TODO: think better about how to combine with existing hsv...\n            if (f > 0.) {\n                c.fluoresc.rgb = vec3(0.5, 1., 0.1 * f);\n            }\n        }\n\n        vec2 mtp = texpos.xy;  // texture position for looking up bed.  ? texpos ?\n        if (matrixbedtint != 0.) {\n            vec4 bed = texture2D(matrixbed, vec2(mtp.x, 0.5));\n            float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n            float ti = t * 255. - 0.0;\n            // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n            // but close enough for now (famous last words), closer with test against green as well\n            vec3 bedrgb = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n            c.col.rgb += bedrgb * matrixbedtint;\n\n            // TODO factor bed colour option and use for x and y (and ribbon)\n            vec4 bedy = texture2D(matrixbed, vec2(mtp.y, 0.5));\n            float ty = bedy.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n            float tiy = ty * 255. - 0.0;\n            vec3 bedrgby = bedy.r != ty || bedy.g != ty ? bedy.rgb : stdcol(floor(tiy == 0. ? 0. : (mod(tiy, 6.) + 1.)));\n            c.col.rgb += bedrgby * matrixbedtint;\n        }\n\n\n        // darker for region outside active particles/springs\n#define in(x,l,h) (l <= x && x <= h)\n        if (!(in(texpos.x, minActive, maxActive) && in(texpos.y, minActive, maxActive)\n            && (texpos.y - texpos.x < maxBackboneDist))) {\n            c.col.rgb *= 0.5;\n            c.fluoresc.b *= 0.5;\n        }\n\n//;#if OPMODE != OPPICK  // minor optimization\n        // get Pick for all elements of interest.\n        for (int i=0; i<32; i++) {\n            //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n            if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 || i >= 16 ) ) continue;\n            float p = getPickC(i);\n            if (abs(opos.x-p) < 0.001 || abs(opos.y-p) < 0.001) {\n                vec3 pcol = getPickColor(i);\n                c.col.rgb += pcol;\n                vec3 pcolHSV = rgb2hsv(pcol);\n                c.fluoresc.rgb = pcolHSV.rgb;\n            }\n        }\n//;#endif\n        c.surftype.y = 0.;  // prevent default gloss causing confusion. shininess1gloss1subband1plastic1\n        return c;\n    }\n    ":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nvarying vec4 opos;\nvoid main ()\n{\n  vec2 tmpvar_1;\n  tmpvar_1.x = cutx;\n  tmpvar_1.y = cuty;\n  highp vec2 tmpvar_2;\n  tmpvar_2 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_1);\n  if ((((tmpvar_2.x * tmpvar_2.x) + (tmpvar_2.y * tmpvar_2.y)) > 1.0)) {\n    discard;\n  };\n  gl_FragColor.xyw = opos.xyw;\n  gl_FragColor.z = floor((opos.z + 0.1));\n  mediump float tmpvar_3;\n  if (gl_FrontFacing) {\n    tmpvar_3 = floor((opos.w + 0.5));\n  } else {\n    tmpvar_3 = 99.0;\n  };\n  gl_FragColor.w = tmpvar_3;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform float matskipdiag;\nuniform float matX;\nuniform float matY;\nuniform float matZ;\nuniform float matMinD;\nuniform float matMaxD;\nuniform float minActive;\nuniform float maxActive;\nuniform vec4 _camd;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 rot4;\nuniform float pointSize;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvarying vec4 opos;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float NORMTYPE;\nuniform float USELOGDEPTH;\nvoid main ()\n{\n  lowp vec4 ooo_1;\n  vec4 p_2;\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xy = position.xy;\n  tmpvar_3.z = (instanceID + fakeinstanceID);\n  p_2.zw = tmpvar_3.zw;\n  p_2.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_2.y = (p_2.y * 0.5);\n  };\n  opos = p_2;\n  lowp float id_4;\n  lowp vec4 p_5;\n  p_5 = p_2;\n  float tmpvar_6;\n  tmpvar_6 = (numSegs + 1.0);\n  lowp vec2 tmpvar_7;\n  tmpvar_7.x = 0.0;\n  tmpvar_7.y = (((p_2.x * tmpvar_6) + 0.5) / numInstancesP2);\n  lowp vec2 tmpvar_8;\n  tmpvar_8.x = 0.0;\n  tmpvar_8.y = (((p_2.y * tmpvar_6) + 0.5) / numInstancesP2);\n  lowp vec3 x_9;\n  x_9 = (texture2D (posNewvals, tmpvar_8).xyz - texture2D (posNewvals, tmpvar_7).xyz);\n  id_4 = (1.0/(clamp ((10.0 + \n    (((sqrt(\n      dot (x_9, x_9)\n    ) - matMinD) * 290.0) / (matMaxD - matMinD))\n  ), 10.0, 300.0)));\n  if (((p_2.x - p_2.y) > ((\n    -(matskipdiag)\n   - 2.0) / numSegs))) {\n    id_4 = 0.0;\n  };\n  if (!(((\n    (minActive <= p_2.x)\n   && \n    (p_2.x <= maxActive)\n  ) && (\n    (minActive <= p_2.y)\n   && \n    (p_2.y <= maxActive)\n  )))) {\n    id_4 = 0.0;\n  };\n  lowp float tmpvar_10;\n  if ((matMaxD == 0.0)) {\n    tmpvar_10 = 0.0;\n  } else {\n    tmpvar_10 = id_4;\n  };\n  p_5.x = (p_2.x + matX);\n  p_5.y = (p_2.y + matY);\n  p_5.z = (tmpvar_10 + matZ);\n  gl_PointSize = pointSize;\n  lowp vec4 tmpvar_11;\n  tmpvar_11.w = 1.0;\n  tmpvar_11.xyz = (p_5 * rot4).xyz;\n  ooo_1 = (projectionMatrix * (modelViewMatrix * tmpvar_11));\n  lowp vec4 ooo_12;\n  ooo_12 = ooo_1;\n  if ((USELOGDEPTH > 0.0)) {\n    ooo_12.xy = (ooo_1.xy / ooo_1.w);\n    ooo_12.w = 1.0;\n    ooo_12.z = (((\n      (log(ooo_1.w) - _camd.z)\n     * _camd.w) * 2.0) - 1.0);\n  } else {\n    if ((USELOGDEPTH < 0.0)) {\n      ooo_12.z = (log2(max (1e-6, \n        (ooo_12.w + 1.0)\n      )) * 0.15);\n      ooo_12.z = ((ooo_12.z - 1.0) * ooo_12.w);\n    };\n  };\n  ooo_1 = ooo_12;\n  gl_Position = ooo_12;\n  opos.xyz = p_2.xyz;\n  opos.w = -99.0;\n}\n\n"}},"shapepos":{"// CSynth ribbon\n//(gn, s, min, max, delta, step, help, tag, free, useuniform)\ngene('wigmult', 500., 0, 2000, 10, 1, 'multiplier for wig radius', 'geom', 1);\ngene('colmix', 0., 0, 1, 0.1, 0.01, 'proportion of rainbow to use', 'geom', 1);\ngene('scaleFactor', 30., 1., 100., 10, 1, 'scaling factor for 3d ribbon etc', 'geom', 1);\ngene('ribbonPickWidth', 0.04, 0,1, 0.01, 0.01, 'how much of ribbon will have increased radius around selected particles', 'geom', 1 );\ngene('ribbonPickExtra', 0, 0,40, 0.1, 0.1, 'amount by which to increase ribbon diameter around selected particles', 'geom', 1 );\n\ngene('endblobs', 3., 0., 20., 1, 1, 'number of blobs at endc', 'geom', 1);\ngene('endbloblen', 0.01, 0., 0.1, 0.001, 0.0001, 'length of blobby end', 'geom', 1);\n\ngene('killradwidth', 0, 0, 10, 1, 1, 'numer of particles to kill each side of killrad points', 'geom', 1);\n\n\n//gene('numSegs', 87, 0,1023, 1,1, 'number of segments, numInstances-1', 'system', 0);\n//gene('numInstancesP2', 87, 0,1023, 1,1, 'power of 2 to hold all instances', 'system', 0);\nhorn('R').ribs(20).radius(80)\n  .code('vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;') // nb, r set below in skerad\n  .code('#define SKELPICK')\n;\nmainhorn='R';\nonframe(checkvr, 5);\nonframe(checkvr, 25);\nextradefines = `\n  uniform sampler2D t_ribboncol, t_ribbonrad;\n  #define KILLRADLEN 4\n  uniform float killrads[KILLRADLEN];\n`;\noverrides= //gl //comment serves as a tag to start a glsl section\n`\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) { \\\n    float p = getPickC(i);\\\n    float xtra = 1. - abs(p-rp) / ribbonPickWidth;\\\n    rx = max(rx, xtra);\\\n  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n`; ///gl  //comment closes the glsl section\nCSynth.startdemo();\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform sampler2D t_ribbonrad;\nuniform float killrads[4];\nuniform vec3 awayvec;\nuniform vec3 clearposA0;\nfloat ribs;\nuniform float nstar;\nuniform float stardepth;\nuniform float ribdepth;\nuniform float R_ribs;\nuniform float R_radius;\nuniform float cumcount3;\nuniform float wigmult;\nuniform float scaleFactor;\nuniform float ribbonPickWidth;\nuniform float ribbonPickExtra;\nuniform float endblobs;\nuniform float endbloblen;\nuniform float killradwidth;\nuniform sampler2D rtopos;\nuniform sampler2D pickrt;\nuniform float multifact;\nuniform float multiquatfact;\nuniform float latenormals;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nuniform mat4 rot4;\nuniform float capres;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nfloat xhornid;\nuniform float hornid;\nuniform float lennum;\nuniform float skelnum;\nuniform float skelends;\nuniform vec2 skelbufferRes;\nuniform sampler2D skelbuffer;\nuniform sampler2D scaleDampTarget;\nuniform float NORMTYPE;\nvoid main ()\n{\n  lowp vec4 multi_1;\n  xhornid = hornid;\n  vec2 tmpvar_2;\n  tmpvar_2.x = cutx;\n  tmpvar_2.y = cuty;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_2);\n  if ((((tmpvar_3.x * tmpvar_3.x) + (tmpvar_3.y * tmpvar_3.y)) > 1.0)) {\n    discard;\n  };\n  lowp vec4 tmpvar_4;\n  highp vec2 P_5;\n  P_5 = (gl_FragCoord.xy * screen);\n  tmpvar_4 = texture2D (rtopos, P_5);\n  if ((tmpvar_4.w == 0.0)) {\n    discard;\n  };\n  if ((tmpvar_4.w == 2.0)) {\n    discard;\n  };\n  lowp float tmpvar_6;\n  tmpvar_6 = (tmpvar_4.z + 0.5);\n  if ((tmpvar_6 < cumcount3)) {\n    xhornid = 3.0;\n    ribs = R_ribs;\n  } else {\n    xhornid = -1.0;\n    ribs = 77.0;\n  };\n  lowp float tmpvar_7;\n  if ((tmpvar_4.w == 99.0)) {\n    tmpvar_7 = 1.0;\n  } else {\n    tmpvar_7 = xhornid;\n  };\n  lowp vec3 xmnormal_8;\n  lowp float ribnum_9;\n  lowp vec3 surfpos_10;\n  lowp float fac_11;\n  lowp float lk_12;\n  lowp float xrscalea_13;\n  float sss_14;\n  lowp float star1_15;\n  lowp vec3 xmu_16;\n  float tmpvar_17;\n  tmpvar_17 = floor(((lennum * capres) * 0.5));\n  float tmpvar_18;\n  tmpvar_18 = (lennum - (2.0 * tmpvar_17));\n  float tmpvar_19;\n  tmpvar_19 = -(tmpvar_17);\n  lowp float tmpvar_20;\n  tmpvar_20 = (tmpvar_19 + (tmpvar_4.x * (\n    (tmpvar_18 + tmpvar_17)\n   - tmpvar_19)));\n  lowp float tmpvar_21;\n  tmpvar_21 = clamp ((tmpvar_20 / tmpvar_18), 0.0, 1.0);\n  lowp vec3 rad1a_22;\n  lowp vec3 skela3_23;\n  lowp vec3 step_24;\n  lowp float tmpvar_25;\n  tmpvar_25 = floor((tmpvar_21 * skelnum));\n  lowp float tmpvar_26;\n  tmpvar_26 = ((tmpvar_21 * skelnum) - tmpvar_25);\n  float tmpvar_27;\n  tmpvar_27 = (skelnum + (2.0 * skelends));\n  lowp vec2 tmpvar_28;\n  tmpvar_28.x = (floor((\n    (min (tmpvar_27, (tmpvar_25 - 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_28.y = (tmpvar_4.z + 0.5);\n  lowp vec4 tmpvar_29;\n  tmpvar_29 = texture2D (skelbuffer, (tmpvar_28 / skelbufferRes));\n  lowp vec2 tmpvar_30;\n  tmpvar_30.x = (floor((\n    (min (tmpvar_27, tmpvar_25) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_30.y = (tmpvar_4.z + 0.5);\n  lowp vec4 tmpvar_31;\n  tmpvar_31 = texture2D (skelbuffer, (tmpvar_30 / skelbufferRes));\n  lowp vec2 tmpvar_32;\n  tmpvar_32.x = (floor((\n    (min (tmpvar_27, (tmpvar_25 + 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_32.y = (tmpvar_4.z + 0.5);\n  lowp vec4 tmpvar_33;\n  tmpvar_33 = texture2D (skelbuffer, (tmpvar_32 / skelbufferRes));\n  lowp vec2 tmpvar_34;\n  tmpvar_34.x = (floor((\n    (min (tmpvar_27, (tmpvar_25 + 2.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_34.y = (tmpvar_4.z + 0.5);\n  lowp vec4 tmpvar_35;\n  tmpvar_35 = texture2D (skelbuffer, (tmpvar_34 / skelbufferRes));\n  lowp vec4 tmpvar_36;\n  tmpvar_36 = (((\n    (-0.5 * tmpvar_29)\n   + \n    (1.5 * tmpvar_31)\n  ) - (1.5 * tmpvar_33)) + (0.5 * tmpvar_35));\n  lowp vec4 tmpvar_37;\n  tmpvar_37 = (((tmpvar_29 - \n    (2.5 * tmpvar_31)\n  ) + (2.0 * tmpvar_33)) - (0.5 * tmpvar_35));\n  lowp vec4 tmpvar_38;\n  tmpvar_38 = ((-0.5 * tmpvar_29) + (0.5 * tmpvar_33));\n  step_24 = (((\n    (3.0 * tmpvar_36)\n   * \n    (tmpvar_26 * tmpvar_26)\n  ) + (\n    (2.0 * tmpvar_37)\n   * tmpvar_26)) + tmpvar_38).xyz;\n  skela3_23 = (((\n    ((tmpvar_36 * tmpvar_26) * (tmpvar_26 * tmpvar_26))\n   + \n    ((tmpvar_37 * tmpvar_26) * tmpvar_26)\n  ) + (tmpvar_38 * tmpvar_26)) + tmpvar_31).xyz;\n  lowp float r_39;\n  lowp vec2 tmpvar_40;\n  tmpvar_40.y = 0.5;\n  tmpvar_40.x = tmpvar_21;\n  lowp vec4 tmpvar_41;\n  tmpvar_41 = texture2D (t_ribbonrad, tmpvar_40);\n  r_39 = (scaleFactor * (R_radius + (tmpvar_41.x * wigmult)));\n  if (((wigmult < 0.0) && (tmpvar_41.x != 0.0))) {\n    r_39 = -0.1;\n  };\n  if ((ribbonPickExtra != 0.0)) {\n    lowp float rx_42;\n    rx_42 = max (0.0, (1.0 - (\n      abs((texture2D (pickrt, vec2(0.0, 0.5)).x - tmpvar_21))\n     / ribbonPickWidth)));\n    lowp vec4 tmpvar_43;\n    tmpvar_43 = texture2D (pickrt, vec2(0.25, 0.5));\n    rx_42 = max (rx_42, (1.0 - (\n      abs((tmpvar_43.x - tmpvar_21))\n     / ribbonPickWidth)));\n    rx_42 = max (rx_42, (1.0 - (\n      abs((tmpvar_43.y - tmpvar_21))\n     / ribbonPickWidth)));\n    rx_42 = max (rx_42, (1.0 - (\n      abs((texture2D (pickrt, vec2(0.5, 0.5)).x - tmpvar_21))\n     / ribbonPickWidth)));\n    lowp vec4 tmpvar_44;\n    tmpvar_44 = texture2D (pickrt, vec2(0.75, 0.5));\n    rx_42 = max (rx_42, (1.0 - (\n      abs((tmpvar_44.x - tmpvar_21))\n     / ribbonPickWidth)));\n    lowp float tmpvar_45;\n    tmpvar_45 = max (rx_42, (1.0 - (\n      abs((tmpvar_44.y - tmpvar_21))\n     / ribbonPickWidth)));\n    rx_42 = tmpvar_45;\n    r_39 = (r_39 + (ribbonPickExtra * tmpvar_45));\n  };\n  lowp float tmpvar_46;\n  tmpvar_46 = abs(((tmpvar_21 * \n    (numSegs + 1.0)\n  ) - killrads[0]));\n  if ((tmpvar_46 <= killradwidth)) {\n    r_39 = -0.1;\n  };\n  lowp float tmpvar_47;\n  tmpvar_47 = abs(((tmpvar_21 * \n    (numSegs + 1.0)\n  ) - killrads[1]));\n  if ((tmpvar_47 <= killradwidth)) {\n    r_39 = -0.1;\n  };\n  lowp float tmpvar_48;\n  tmpvar_48 = abs(((tmpvar_21 * \n    (numSegs + 1.0)\n  ) - killrads[2]));\n  if ((tmpvar_48 <= killradwidth)) {\n    r_39 = -0.1;\n  };\n  lowp float tmpvar_49;\n  tmpvar_49 = abs(((tmpvar_21 * \n    (numSegs + 1.0)\n  ) - killrads[3]));\n  if ((tmpvar_49 <= killradwidth)) {\n    r_39 = -0.1;\n  };\n  lowp float tmpvar_50;\n  tmpvar_50 = (max ((endbloblen - tmpvar_21), (\n    (-1.0 + endbloblen)\n   + tmpvar_21)) / endbloblen);\n  if ((tmpvar_50 > 0.0)) {\n    r_39 = (r_39 * sqrt(max (0.0, \n      (((1.0 + cos(\n        (((1.0 - tmpvar_50) * 6.28318) * endblobs)\n      )) * 0.5) * (1.0 - tmpvar_50))\n    )));\n  };\n  lowp float tmpvar_51;\n  tmpvar_51 = sqrt(dot (step_24, step_24));\n  lowp vec3 tmpvar_52;\n  if ((tmpvar_51 == 0.0)) {\n    tmpvar_52 = vec3(0.0, 1.0, 0.0);\n  } else {\n    tmpvar_52 = (step_24 / tmpvar_51);\n  };\n  lowp vec4 tmpvar_53;\n  tmpvar_53.w = 1.0;\n  tmpvar_53.xyz = skela3_23;\n  if (((tmpvar_51 == 0.0) || (NORMTYPE == 0.0))) {\n    rad1a_22 = vec3(1.0, 0.0, 0.0);\n  } else {\n    if ((NORMTYPE == 1.0)) {\n      rad1a_22 = ((tmpvar_52.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_52.zxy * vec3(1.3, 2.1, 1.0)));\n    } else {\n      if ((NORMTYPE == 2.0)) {\n        lowp vec2 tmpvar_54;\n        tmpvar_54.x = 0.5;\n        tmpvar_54.y = (((\n          (tmpvar_21 - 0.09)\n         * numSegs) + 0.5) / numInstancesP2);\n        lowp vec4 tmpvar_55;\n        tmpvar_55 = (texture2D (posNewvals, tmpvar_54) * scaleFactor);\n        lowp vec4 tmpvar_56;\n        tmpvar_56 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n        lowp vec4 tmpvar_57;\n        tmpvar_57.xy = (tmpvar_55.xy - tmpvar_56.xy);\n        tmpvar_57.z = (tmpvar_55.z - tmpvar_56.z);\n        tmpvar_57.w = 1.0;\n        lowp vec3 b_58;\n        b_58 = (tmpvar_57.xyz - skela3_23);\n        rad1a_22 = ((tmpvar_52.yzx * b_58.zxy) - (tmpvar_52.zxy * b_58.yzx));\n      } else {\n        if ((NORMTYPE == 3.0)) {\n          lowp vec2 tmpvar_59;\n          tmpvar_59.x = 0.5;\n          tmpvar_59.y = (((\n            (tmpvar_21 - 0.09)\n           * numSegs) + 0.5) / numInstancesP2);\n          lowp vec4 tmpvar_60;\n          tmpvar_60 = (texture2D (posNewvals, tmpvar_59) * scaleFactor);\n          lowp vec4 tmpvar_61;\n          tmpvar_61 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n          lowp vec4 tmpvar_62;\n          tmpvar_62.xy = (tmpvar_60.xy - tmpvar_61.xy);\n          tmpvar_62.z = (tmpvar_60.z - tmpvar_61.z);\n          tmpvar_62.w = 1.0;\n          lowp vec3 tmpvar_63;\n          lowp vec3 b_64;\n          b_64 = (tmpvar_62.xyz - skela3_23);\n          tmpvar_63 = ((tmpvar_52.yzx * b_64.zxy) - (tmpvar_52.zxy * b_64.yzx));\n          rad1a_22 = tmpvar_63;\n          lowp float tmpvar_65;\n          tmpvar_65 = dot (tmpvar_63, tmpvar_63);\n          if ((tmpvar_65 < 1e-6)) {\n            rad1a_22 = ((tmpvar_52.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_52.zxy * vec3(1.3, 2.1, 1.0)));\n          };\n        } else {\n          if ((NORMTYPE == 4.0)) {\n            lowp float z_66;\n            lowp float x_67;\n            lowp vec2 tmpvar_68;\n            tmpvar_68.x = 0.5;\n            tmpvar_68.y = (((tmpvar_21 * numSegs) + 0.5) / numInstancesP2);\n            lowp vec4 tmpvar_69;\n            tmpvar_69 = (texture2D (posNewvals, tmpvar_68) * scaleFactor);\n            x_67 = (0.013 + tmpvar_69.x);\n            z_66 = (0.017 + tmpvar_69.z);\n            lowp vec4 tmpvar_70;\n            tmpvar_70 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n            x_67 = (x_67 - tmpvar_70.x);\n            z_66 = (z_66 - tmpvar_70.z);\n            lowp vec4 tmpvar_71;\n            tmpvar_71.x = x_67;\n            tmpvar_71.y = (tmpvar_69.y - tmpvar_70.y);\n            tmpvar_71.z = z_66;\n            tmpvar_71.w = 1.0;\n            lowp vec3 b_72;\n            b_72 = (tmpvar_71.xyz - skela3_23);\n            rad1a_22 = ((tmpvar_52.yzx * b_72.zxy) - (tmpvar_52.zxy * b_72.yzx));\n          } else {\n            if ((NORMTYPE == 5.0)) {\n              mat3 tmpvar_73;\n              tmpvar_73[0] = rot4[0].xyz;\n              tmpvar_73[1] = rot4[1].xyz;\n              tmpvar_73[2] = rot4[2].xyz;\n              lowp vec3 tmpvar_74;\n              tmpvar_74 = normalize((tmpvar_73 * (clearposA0 - \n                (tmpvar_53 * rot4)\n              .xyz)));\n              rad1a_22 = ((tmpvar_74.yzx * tmpvar_52.zxy) - (tmpvar_74.zxy * tmpvar_52.yzx));\n            } else {\n              if ((NORMTYPE == 6.0)) {\n                rad1a_22 = ((awayvec.yzx * tmpvar_52.zxy) - (awayvec.zxy * tmpvar_52.yzx));\n              } else {\n                rad1a_22 = vec3(0.0, 0.0, 1.0);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  xmu_16 = tmpvar_52;\n  lowp float tmpvar_75;\n  tmpvar_75 = (tmpvar_4.y * nstar);\n  star1_15 = tmpvar_75;\n  sss_14 = 1.0;\n  float tmpvar_76;\n  tmpvar_76 = floor(nstar);\n  if ((tmpvar_75 > tmpvar_76)) {\n    float tmpvar_77;\n    tmpvar_77 = fract(nstar);\n    sss_14 = tmpvar_77;\n    float tmpvar_78;\n    tmpvar_78 = floor(nstar);\n    star1_15 = (tmpvar_78 + ((tmpvar_75 - tmpvar_78) / tmpvar_77));\n  };\n  lowp float tmpvar_79;\n  tmpvar_79 = (r_39 * (1.0 - (\n    (1.0 - (((1.0 - \n      cos((6.28318 * star1_15))\n    ) * sss_14) * sss_14))\n   * stardepth)));\n  xrscalea_13 = tmpvar_79;\n  lk_12 = 0.0;\n  fac_11 = 1.0;\n  ribnum_9 = 0.0;\n  if (((0.0 < tmpvar_20) && (tmpvar_20 < tmpvar_18))) {\n    lk_12 = ((tmpvar_4.x * ribs) + 0.5);\n    ribnum_9 = floor(lk_12);\n    lowp float tmpvar_80;\n    tmpvar_80 = abs((fract(lk_12) - 0.5));\n    lk_12 = tmpvar_80;\n    lowp float tmpvar_81;\n    tmpvar_81 = sqrt((1.0 - (\n      (ribdepth * tmpvar_80)\n     * tmpvar_80)));\n    fac_11 = tmpvar_81;\n    xrscalea_13 = (tmpvar_79 * tmpvar_81);\n  };\n  lowp vec3 tmpvar_82;\n  tmpvar_82 = normalize(rad1a_22);\n  xmnormal_8 = ((-(\n    sin((6.28318 * tmpvar_4.y))\n  ) * -(\n    normalize(((tmpvar_52.yzx * tmpvar_82.zxy) - (tmpvar_52.zxy * tmpvar_82.yzx)))\n  )) + (cos(\n    (6.28318 * tmpvar_4.y)\n  ) * tmpvar_82));\n  surfpos_10 = (skela3_23 + (xrscalea_13 * xmnormal_8));\n  xmnormal_8 = (xmnormal_8 + (tmpvar_52 * (\n    (ribdepth * lk_12)\n   / fac_11)));\n  lowp vec3 tmpvar_83;\n  tmpvar_83 = normalize(xmnormal_8);\n  xmnormal_8 = tmpvar_83;\n  if ((tmpvar_20 > tmpvar_18)) {\n    lowp float tmpvar_84;\n    tmpvar_84 = (((\n      (tmpvar_20 - tmpvar_18)\n     / tmpvar_17) * 3.14159) / 2.0);\n    lowp vec3 tmpvar_85;\n    tmpvar_85 = ((sin(tmpvar_84) * tmpvar_52) + (cos(tmpvar_84) * tmpvar_83));\n    surfpos_10 = (skela3_23 + (xrscalea_13 * tmpvar_85));\n    xmu_16 = ((cos(tmpvar_84) * tmpvar_52) - (sin(tmpvar_84) * tmpvar_83));\n    xmnormal_8 = tmpvar_85;\n  };\n  if ((tmpvar_20 < 0.0)) {\n    lowp float tmpvar_86;\n    tmpvar_86 = (((tmpvar_20 / tmpvar_17) * 3.14159) / 2.0);\n    lowp vec3 tmpvar_87;\n    tmpvar_87 = ((sin(tmpvar_86) * xmu_16) + (cos(tmpvar_86) * xmnormal_8));\n    surfpos_10 = (skela3_23 + (xrscalea_13 * tmpvar_87));\n    xmu_16 = ((cos(tmpvar_86) * xmu_16) - (sin(tmpvar_86) * xmnormal_8));\n    xmnormal_8 = tmpvar_87;\n  };\n  lowp vec4 tmpvar_88;\n  tmpvar_88.xyz = surfpos_10;\n  tmpvar_88.w = 1.0;\n  multi_1.xyz = (floor((surfpos_10 * multifact)) + ((xmnormal_8 + 1.0) * multiquatfact));\n  if ((latenormals != 0.0)) {\n    multi_1 = tmpvar_88;\n  };\n  multi_1.w = (((4096.0 * tmpvar_7) + tmpvar_4.z) + ((float(mod (ribnum_9, 2.0))) * 0.5));\n  if ((tmpvar_7 == 2.0)) {\n    multi_1.w = ((4096.0 * tmpvar_7) + ribnum_9);\n  };\n  gl_FragColor = multi_1;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"},"horn(\"R\").ribs(#R_ribs#).radius(#R_radius#).code(\"vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;\").code(\"#define SKELPICK\");\nmainhorn=\"R\";\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) {     float p = getPickC(i);    float xtra = 1. - abs(p-rp) / ribbonPickWidth;    rx = max(rx, xtra);  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform sampler2D t_ribbonrad;\nuniform float killrads[4];\nuniform vec3 awayvec;\nuniform vec3 clearposA0;\nfloat ribs;\nuniform float nstar;\nuniform float stardepth;\nuniform float ribdepth;\nuniform float R_ribs;\nuniform float R_radius;\nuniform float cumcount3;\nuniform float wigmult;\nuniform float scaleFactor;\nuniform float ribbonPickWidth;\nuniform float ribbonPickExtra;\nuniform float endblobs;\nuniform float endbloblen;\nuniform float killradwidth;\nuniform sampler2D rtopos;\nuniform sampler2D pickrt;\nuniform float multifact;\nuniform float multiquatfact;\nuniform float latenormals;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nuniform mat4 rot4;\nuniform float capres;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nfloat xhornid;\nuniform float hornid;\nuniform float lennum;\nuniform float skelnum;\nuniform float skelends;\nuniform vec2 skelbufferRes;\nuniform sampler2D skelbuffer;\nuniform sampler2D scaleDampTarget;\nuniform float NORMTYPE;\nvoid main ()\n{\n  lowp vec4 multi_1;\n  xhornid = hornid;\n  vec2 tmpvar_2;\n  tmpvar_2.x = cutx;\n  tmpvar_2.y = cuty;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_2);\n  if ((((tmpvar_3.x * tmpvar_3.x) + (tmpvar_3.y * tmpvar_3.y)) > 1.0)) {\n    discard;\n  };\n  lowp vec4 tmpvar_4;\n  highp vec2 P_5;\n  P_5 = (gl_FragCoord.xy * screen);\n  tmpvar_4 = texture2D (rtopos, P_5);\n  if ((tmpvar_4.w == 0.0)) {\n    discard;\n  };\n  if ((tmpvar_4.w == 2.0)) {\n    discard;\n  };\n  lowp float tmpvar_6;\n  tmpvar_6 = (tmpvar_4.z + 0.5);\n  if ((tmpvar_6 < cumcount3)) {\n    xhornid = 3.0;\n    ribs = R_ribs;\n  } else {\n    xhornid = -1.0;\n    ribs = 77.0;\n  };\n  lowp float tmpvar_7;\n  if ((tmpvar_4.w == 99.0)) {\n    tmpvar_7 = 1.0;\n  } else {\n    tmpvar_7 = xhornid;\n  };\n  lowp vec3 xmnormal_8;\n  lowp float ribnum_9;\n  lowp vec3 surfpos_10;\n  lowp float fac_11;\n  lowp float lk_12;\n  lowp float xrscalea_13;\n  float sss_14;\n  lowp float star1_15;\n  lowp vec3 xmu_16;\n  float tmpvar_17;\n  tmpvar_17 = floor(((lennum * capres) * 0.5));\n  float tmpvar_18;\n  tmpvar_18 = (lennum - (2.0 * tmpvar_17));\n  float tmpvar_19;\n  tmpvar_19 = -(tmpvar_17);\n  lowp float tmpvar_20;\n  tmpvar_20 = (tmpvar_19 + (tmpvar_4.x * (\n    (tmpvar_18 + tmpvar_17)\n   - tmpvar_19)));\n  lowp float tmpvar_21;\n  tmpvar_21 = clamp ((tmpvar_20 / tmpvar_18), 0.0, 1.0);\n  lowp vec3 rad1a_22;\n  lowp vec3 skela3_23;\n  lowp vec3 step_24;\n  lowp float tmpvar_25;\n  tmpvar_25 = floor((tmpvar_21 * skelnum));\n  lowp float tmpvar_26;\n  tmpvar_26 = ((tmpvar_21 * skelnum) - tmpvar_25);\n  float tmpvar_27;\n  tmpvar_27 = (skelnum + (2.0 * skelends));\n  lowp vec2 tmpvar_28;\n  tmpvar_28.x = (floor((\n    (min (tmpvar_27, (tmpvar_25 - 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_28.y = (tmpvar_4.z + 0.5);\n  lowp vec4 tmpvar_29;\n  tmpvar_29 = texture2D (skelbuffer, (tmpvar_28 / skelbufferRes));\n  lowp vec2 tmpvar_30;\n  tmpvar_30.x = (floor((\n    (min (tmpvar_27, tmpvar_25) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_30.y = (tmpvar_4.z + 0.5);\n  lowp vec4 tmpvar_31;\n  tmpvar_31 = texture2D (skelbuffer, (tmpvar_30 / skelbufferRes));\n  lowp vec2 tmpvar_32;\n  tmpvar_32.x = (floor((\n    (min (tmpvar_27, (tmpvar_25 + 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_32.y = (tmpvar_4.z + 0.5);\n  lowp vec4 tmpvar_33;\n  tmpvar_33 = texture2D (skelbuffer, (tmpvar_32 / skelbufferRes));\n  lowp vec2 tmpvar_34;\n  tmpvar_34.x = (floor((\n    (min (tmpvar_27, (tmpvar_25 + 2.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_34.y = (tmpvar_4.z + 0.5);\n  lowp vec4 tmpvar_35;\n  tmpvar_35 = texture2D (skelbuffer, (tmpvar_34 / skelbufferRes));\n  lowp vec4 tmpvar_36;\n  tmpvar_36 = (((\n    (-0.5 * tmpvar_29)\n   + \n    (1.5 * tmpvar_31)\n  ) - (1.5 * tmpvar_33)) + (0.5 * tmpvar_35));\n  lowp vec4 tmpvar_37;\n  tmpvar_37 = (((tmpvar_29 - \n    (2.5 * tmpvar_31)\n  ) + (2.0 * tmpvar_33)) - (0.5 * tmpvar_35));\n  lowp vec4 tmpvar_38;\n  tmpvar_38 = ((-0.5 * tmpvar_29) + (0.5 * tmpvar_33));\n  step_24 = (((\n    (3.0 * tmpvar_36)\n   * \n    (tmpvar_26 * tmpvar_26)\n  ) + (\n    (2.0 * tmpvar_37)\n   * tmpvar_26)) + tmpvar_38).xyz;\n  skela3_23 = (((\n    ((tmpvar_36 * tmpvar_26) * (tmpvar_26 * tmpvar_26))\n   + \n    ((tmpvar_37 * tmpvar_26) * tmpvar_26)\n  ) + (tmpvar_38 * tmpvar_26)) + tmpvar_31).xyz;\n  lowp float r_39;\n  lowp vec2 tmpvar_40;\n  tmpvar_40.y = 0.5;\n  tmpvar_40.x = tmpvar_21;\n  lowp vec4 tmpvar_41;\n  tmpvar_41 = texture2D (t_ribbonrad, tmpvar_40);\n  r_39 = (scaleFactor * (R_radius + (tmpvar_41.x * wigmult)));\n  if (((wigmult < 0.0) && (tmpvar_41.x != 0.0))) {\n    r_39 = -0.1;\n  };\n  if ((ribbonPickExtra != 0.0)) {\n    lowp float rx_42;\n    rx_42 = max (0.0, (1.0 - (\n      abs((texture2D (pickrt, vec2(0.0, 0.5)).x - tmpvar_21))\n     / ribbonPickWidth)));\n    lowp vec4 tmpvar_43;\n    tmpvar_43 = texture2D (pickrt, vec2(0.25, 0.5));\n    rx_42 = max (rx_42, (1.0 - (\n      abs((tmpvar_43.x - tmpvar_21))\n     / ribbonPickWidth)));\n    rx_42 = max (rx_42, (1.0 - (\n      abs((tmpvar_43.y - tmpvar_21))\n     / ribbonPickWidth)));\n    rx_42 = max (rx_42, (1.0 - (\n      abs((texture2D (pickrt, vec2(0.5, 0.5)).x - tmpvar_21))\n     / ribbonPickWidth)));\n    lowp vec4 tmpvar_44;\n    tmpvar_44 = texture2D (pickrt, vec2(0.75, 0.5));\n    rx_42 = max (rx_42, (1.0 - (\n      abs((tmpvar_44.x - tmpvar_21))\n     / ribbonPickWidth)));\n    lowp float tmpvar_45;\n    tmpvar_45 = max (rx_42, (1.0 - (\n      abs((tmpvar_44.y - tmpvar_21))\n     / ribbonPickWidth)));\n    rx_42 = tmpvar_45;\n    r_39 = (r_39 + (ribbonPickExtra * tmpvar_45));\n  };\n  lowp float tmpvar_46;\n  tmpvar_46 = abs(((tmpvar_21 * \n    (numSegs + 1.0)\n  ) - killrads[0]));\n  if ((tmpvar_46 <= killradwidth)) {\n    r_39 = -0.1;\n  };\n  lowp float tmpvar_47;\n  tmpvar_47 = abs(((tmpvar_21 * \n    (numSegs + 1.0)\n  ) - killrads[1]));\n  if ((tmpvar_47 <= killradwidth)) {\n    r_39 = -0.1;\n  };\n  lowp float tmpvar_48;\n  tmpvar_48 = abs(((tmpvar_21 * \n    (numSegs + 1.0)\n  ) - killrads[2]));\n  if ((tmpvar_48 <= killradwidth)) {\n    r_39 = -0.1;\n  };\n  lowp float tmpvar_49;\n  tmpvar_49 = abs(((tmpvar_21 * \n    (numSegs + 1.0)\n  ) - killrads[3]));\n  if ((tmpvar_49 <= killradwidth)) {\n    r_39 = -0.1;\n  };\n  lowp float tmpvar_50;\n  tmpvar_50 = (max ((endbloblen - tmpvar_21), (\n    (-1.0 + endbloblen)\n   + tmpvar_21)) / endbloblen);\n  if ((tmpvar_50 > 0.0)) {\n    r_39 = (r_39 * sqrt(max (0.0, \n      (((1.0 + cos(\n        (((1.0 - tmpvar_50) * 6.28318) * endblobs)\n      )) * 0.5) * (1.0 - tmpvar_50))\n    )));\n  };\n  lowp float tmpvar_51;\n  tmpvar_51 = sqrt(dot (step_24, step_24));\n  lowp vec3 tmpvar_52;\n  if ((tmpvar_51 == 0.0)) {\n    tmpvar_52 = vec3(0.0, 1.0, 0.0);\n  } else {\n    tmpvar_52 = (step_24 / tmpvar_51);\n  };\n  lowp vec4 tmpvar_53;\n  tmpvar_53.w = 1.0;\n  tmpvar_53.xyz = skela3_23;\n  if (((tmpvar_51 == 0.0) || (NORMTYPE == 0.0))) {\n    rad1a_22 = vec3(1.0, 0.0, 0.0);\n  } else {\n    if ((NORMTYPE == 1.0)) {\n      rad1a_22 = ((tmpvar_52.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_52.zxy * vec3(1.3, 2.1, 1.0)));\n    } else {\n      if ((NORMTYPE == 2.0)) {\n        lowp vec2 tmpvar_54;\n        tmpvar_54.x = 0.5;\n        tmpvar_54.y = (((\n          (tmpvar_21 - 0.09)\n         * numSegs) + 0.5) / numInstancesP2);\n        lowp vec4 tmpvar_55;\n        tmpvar_55 = (texture2D (posNewvals, tmpvar_54) * scaleFactor);\n        lowp vec4 tmpvar_56;\n        tmpvar_56 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n        lowp vec4 tmpvar_57;\n        tmpvar_57.xy = (tmpvar_55.xy - tmpvar_56.xy);\n        tmpvar_57.z = (tmpvar_55.z - tmpvar_56.z);\n        tmpvar_57.w = 1.0;\n        lowp vec3 b_58;\n        b_58 = (tmpvar_57.xyz - skela3_23);\n        rad1a_22 = ((tmpvar_52.yzx * b_58.zxy) - (tmpvar_52.zxy * b_58.yzx));\n      } else {\n        if ((NORMTYPE == 3.0)) {\n          lowp vec2 tmpvar_59;\n          tmpvar_59.x = 0.5;\n          tmpvar_59.y = (((\n            (tmpvar_21 - 0.09)\n           * numSegs) + 0.5) / numInstancesP2);\n          lowp vec4 tmpvar_60;\n          tmpvar_60 = (texture2D (posNewvals, tmpvar_59) * scaleFactor);\n          lowp vec4 tmpvar_61;\n          tmpvar_61 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n          lowp vec4 tmpvar_62;\n          tmpvar_62.xy = (tmpvar_60.xy - tmpvar_61.xy);\n          tmpvar_62.z = (tmpvar_60.z - tmpvar_61.z);\n          tmpvar_62.w = 1.0;\n          lowp vec3 tmpvar_63;\n          lowp vec3 b_64;\n          b_64 = (tmpvar_62.xyz - skela3_23);\n          tmpvar_63 = ((tmpvar_52.yzx * b_64.zxy) - (tmpvar_52.zxy * b_64.yzx));\n          rad1a_22 = tmpvar_63;\n          lowp float tmpvar_65;\n          tmpvar_65 = dot (tmpvar_63, tmpvar_63);\n          if ((tmpvar_65 < 1e-6)) {\n            rad1a_22 = ((tmpvar_52.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_52.zxy * vec3(1.3, 2.1, 1.0)));\n          };\n        } else {\n          if ((NORMTYPE == 4.0)) {\n            lowp float z_66;\n            lowp float x_67;\n            lowp vec2 tmpvar_68;\n            tmpvar_68.x = 0.5;\n            tmpvar_68.y = (((tmpvar_21 * numSegs) + 0.5) / numInstancesP2);\n            lowp vec4 tmpvar_69;\n            tmpvar_69 = (texture2D (posNewvals, tmpvar_68) * scaleFactor);\n            x_67 = (0.013 + tmpvar_69.x);\n            z_66 = (0.017 + tmpvar_69.z);\n            lowp vec4 tmpvar_70;\n            tmpvar_70 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n            x_67 = (x_67 - tmpvar_70.x);\n            z_66 = (z_66 - tmpvar_70.z);\n            lowp vec4 tmpvar_71;\n            tmpvar_71.x = x_67;\n            tmpvar_71.y = (tmpvar_69.y - tmpvar_70.y);\n            tmpvar_71.z = z_66;\n            tmpvar_71.w = 1.0;\n            lowp vec3 b_72;\n            b_72 = (tmpvar_71.xyz - skela3_23);\n            rad1a_22 = ((tmpvar_52.yzx * b_72.zxy) - (tmpvar_52.zxy * b_72.yzx));\n          } else {\n            if ((NORMTYPE == 5.0)) {\n              mat3 tmpvar_73;\n              tmpvar_73[0] = rot4[0].xyz;\n              tmpvar_73[1] = rot4[1].xyz;\n              tmpvar_73[2] = rot4[2].xyz;\n              lowp vec3 tmpvar_74;\n              tmpvar_74 = normalize((tmpvar_73 * (clearposA0 - \n                (tmpvar_53 * rot4)\n              .xyz)));\n              rad1a_22 = ((tmpvar_74.yzx * tmpvar_52.zxy) - (tmpvar_74.zxy * tmpvar_52.yzx));\n            } else {\n              if ((NORMTYPE == 6.0)) {\n                rad1a_22 = ((awayvec.yzx * tmpvar_52.zxy) - (awayvec.zxy * tmpvar_52.yzx));\n              } else {\n                rad1a_22 = vec3(0.0, 0.0, 1.0);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  xmu_16 = tmpvar_52;\n  lowp float tmpvar_75;\n  tmpvar_75 = (tmpvar_4.y * nstar);\n  star1_15 = tmpvar_75;\n  sss_14 = 1.0;\n  float tmpvar_76;\n  tmpvar_76 = floor(nstar);\n  if ((tmpvar_75 > tmpvar_76)) {\n    float tmpvar_77;\n    tmpvar_77 = fract(nstar);\n    sss_14 = tmpvar_77;\n    float tmpvar_78;\n    tmpvar_78 = floor(nstar);\n    star1_15 = (tmpvar_78 + ((tmpvar_75 - tmpvar_78) / tmpvar_77));\n  };\n  lowp float tmpvar_79;\n  tmpvar_79 = (r_39 * (1.0 - (\n    (1.0 - (((1.0 - \n      cos((6.28318 * star1_15))\n    ) * sss_14) * sss_14))\n   * stardepth)));\n  xrscalea_13 = tmpvar_79;\n  lk_12 = 0.0;\n  fac_11 = 1.0;\n  ribnum_9 = 0.0;\n  if (((0.0 < tmpvar_20) && (tmpvar_20 < tmpvar_18))) {\n    lk_12 = ((tmpvar_4.x * ribs) + 0.5);\n    ribnum_9 = floor(lk_12);\n    lowp float tmpvar_80;\n    tmpvar_80 = abs((fract(lk_12) - 0.5));\n    lk_12 = tmpvar_80;\n    lowp float tmpvar_81;\n    tmpvar_81 = sqrt((1.0 - (\n      (ribdepth * tmpvar_80)\n     * tmpvar_80)));\n    fac_11 = tmpvar_81;\n    xrscalea_13 = (tmpvar_79 * tmpvar_81);\n  };\n  lowp vec3 tmpvar_82;\n  tmpvar_82 = normalize(rad1a_22);\n  xmnormal_8 = ((-(\n    sin((6.28318 * tmpvar_4.y))\n  ) * -(\n    normalize(((tmpvar_52.yzx * tmpvar_82.zxy) - (tmpvar_52.zxy * tmpvar_82.yzx)))\n  )) + (cos(\n    (6.28318 * tmpvar_4.y)\n  ) * tmpvar_82));\n  surfpos_10 = (skela3_23 + (xrscalea_13 * xmnormal_8));\n  xmnormal_8 = (xmnormal_8 + (tmpvar_52 * (\n    (ribdepth * lk_12)\n   / fac_11)));\n  lowp vec3 tmpvar_83;\n  tmpvar_83 = normalize(xmnormal_8);\n  xmnormal_8 = tmpvar_83;\n  if ((tmpvar_20 > tmpvar_18)) {\n    lowp float tmpvar_84;\n    tmpvar_84 = (((\n      (tmpvar_20 - tmpvar_18)\n     / tmpvar_17) * 3.14159) / 2.0);\n    lowp vec3 tmpvar_85;\n    tmpvar_85 = ((sin(tmpvar_84) * tmpvar_52) + (cos(tmpvar_84) * tmpvar_83));\n    surfpos_10 = (skela3_23 + (xrscalea_13 * tmpvar_85));\n    xmu_16 = ((cos(tmpvar_84) * tmpvar_52) - (sin(tmpvar_84) * tmpvar_83));\n    xmnormal_8 = tmpvar_85;\n  };\n  if ((tmpvar_20 < 0.0)) {\n    lowp float tmpvar_86;\n    tmpvar_86 = (((tmpvar_20 / tmpvar_17) * 3.14159) / 2.0);\n    lowp vec3 tmpvar_87;\n    tmpvar_87 = ((sin(tmpvar_86) * xmu_16) + (cos(tmpvar_86) * xmnormal_8));\n    surfpos_10 = (skela3_23 + (xrscalea_13 * tmpvar_87));\n    xmu_16 = ((cos(tmpvar_86) * xmu_16) - (sin(tmpvar_86) * xmnormal_8));\n    xmnormal_8 = tmpvar_87;\n  };\n  lowp vec4 tmpvar_88;\n  tmpvar_88.xyz = surfpos_10;\n  tmpvar_88.w = 1.0;\n  multi_1.xyz = (floor((surfpos_10 * multifact)) + ((xmnormal_8 + 1.0) * multiquatfact));\n  if ((latenormals != 0.0)) {\n    multi_1 = tmpvar_88;\n  };\n  multi_1.w = (((4096.0 * tmpvar_7) + tmpvar_4.z) + ((float(mod (ribnum_9, 2.0))) * 0.5));\n  if ((tmpvar_7 == 2.0)) {\n    multi_1.w = ((4096.0 * tmpvar_7) + ribnum_9);\n  };\n  gl_FragColor = multi_1;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"},"matrix":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform float matskipdiag;\nuniform float matX;\nuniform float matY;\nuniform float matZ;\nuniform float matMinD;\nuniform float matMaxD;\nuniform float minActive;\nuniform float maxActive;\nuniform sampler2D rtopos;\nuniform float multifact;\nuniform float multiquatfact;\nuniform float latenormals;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float hornid;\nvoid main ()\n{\n  lowp vec4 multi_1;\n  vec2 tmpvar_2;\n  tmpvar_2.x = cutx;\n  tmpvar_2.y = cuty;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_2);\n  if ((((tmpvar_3.x * tmpvar_3.x) + (tmpvar_3.y * tmpvar_3.y)) > 1.0)) {\n    discard;\n  };\n  lowp vec4 tmpvar_4;\n  highp vec2 P_5;\n  P_5 = (gl_FragCoord.xy * screen);\n  tmpvar_4 = texture2D (rtopos, P_5);\n  if ((tmpvar_4.w == 0.0)) {\n    discard;\n  };\n  if ((tmpvar_4.w == 2.0)) {\n    discard;\n  };\n  lowp float tmpvar_6;\n  if ((tmpvar_4.w == 99.0)) {\n    tmpvar_6 = 1.0;\n  } else {\n    tmpvar_6 = hornid;\n  };\n  vec3 xmnormal_7;\n  float ribnum_8;\n  lowp float id_9;\n  lowp vec4 p_10;\n  p_10 = tmpvar_4;\n  float tmpvar_11;\n  tmpvar_11 = (numSegs + 1.0);\n  lowp vec2 tmpvar_12;\n  tmpvar_12.x = 0.0;\n  tmpvar_12.y = (((tmpvar_4.x * tmpvar_11) + 0.5) / numInstancesP2);\n  lowp vec2 tmpvar_13;\n  tmpvar_13.x = 0.0;\n  tmpvar_13.y = (((tmpvar_4.y * tmpvar_11) + 0.5) / numInstancesP2);\n  lowp vec3 x_14;\n  x_14 = (texture2D (posNewvals, tmpvar_13).xyz - texture2D (posNewvals, tmpvar_12).xyz);\n  id_9 = (1.0/(clamp ((10.0 + \n    (((sqrt(\n      dot (x_14, x_14)\n    ) - matMinD) * 290.0) / (matMaxD - matMinD))\n  ), 10.0, 300.0)));\n  if (((tmpvar_4.x - tmpvar_4.y) > ((\n    -(matskipdiag)\n   - 2.0) / numSegs))) {\n    id_9 = 0.0;\n  };\n  if (!(((\n    (minActive <= tmpvar_4.x)\n   && \n    (tmpvar_4.x <= maxActive)\n  ) && (\n    (minActive <= tmpvar_4.y)\n   && \n    (tmpvar_4.y <= maxActive)\n  )))) {\n    id_9 = 0.0;\n  };\n  lowp float tmpvar_15;\n  if ((matMaxD == 0.0)) {\n    tmpvar_15 = 0.0;\n  } else {\n    tmpvar_15 = id_9;\n  };\n  p_10.x = (tmpvar_4.x + matX);\n  p_10.y = (tmpvar_4.y + matY);\n  p_10.z = (tmpvar_15 + matZ);\n  multi_1.xyz = (floor((p_10.xyz * multifact)) + ((xmnormal_7 + 1.0) * multiquatfact));\n  if ((latenormals != 0.0)) {\n    multi_1 = p_10;\n  };\n  multi_1.w = (((4096.0 * tmpvar_6) + tmpvar_4.z) + ((float(mod (ribnum_8, 2.0))) * 0.5));\n  if ((tmpvar_6 == 2.0)) {\n    multi_1.w = ((4096.0 * tmpvar_6) + ribnum_8);\n  };\n  gl_FragColor = multi_1;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"},"matrix\n    override vec4 tr(const vec4 lopos, out vec3 xmnormal, out vec3 texpos, out float ribnum){\n        pickopos(lopos);\n        vec4 p = lopos;\n        float numInstances = numSegs + 1.;\n        vec3 p1 = histpos((p.x * numInstances + 0.5)/numInstancesP2).xyz;\n        vec3 p2 = histpos((p.y * numInstances + 0.5)/numInstancesP2).xyz;\n        float dist = length(p2 - p1);\n        float d10300 = clamp(map(dist, matMinD, matMaxD, 10., 300.), 10., 300.);// + 0.5;\n        //float id = 1./max(d, 10.);\n        float id = 1./d10300;\n        if (p.x - p.y > (-matskipdiag - 2.)/numSegs) id = 0.;\n\n        #define in(x,l,h) (l <= x && x <= h)\n        if (!(in(p.x, minActive, maxActive) && in(p.y, minActive, maxActive)))\n            id = 0.;\n\n\n        float hd = id; //heightFactor * tanh(id * heightFactor2) / tanh(heightFactor2);\n        p.z = matMaxD == 0. ? 0. : hd;\n        p.x += matX;\n        p.y += matY;\n        p.z += matZ;\n        //p.z = min(0.1, 1./d);\n        //p.xyz *= 8000.;\n        return p;\n    }\n\n    override Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n// #define bimix(a00, a01, a10, a11, x,y) mix( mix(a00,a01, x), mix(a10, a11, x), y)\n        if (texpos.x - texpos.y > -matskipdiag / numSegs) discard;\n        Colsurf c = colsurfd();\n        // float a = clamp(texpos.z/heightFactor, 0., 1.);\n        // a = 0.5 + atan(((2.*a)-1.)*matColCurve) / (2.*atan(matColCurve));\n\n        // recompute distance, info passed in texpos.z not reliable\n        // we should only need to do this where dist is actually used.\n        float numInstances = numSegs + 1.;\n        vec3 pp = round(texpos * numSegs);  // we force lookup of precise position even if posVewVals is using LinearFilter\n        vec3 p1 = histpos((pp.x + 0.5)/numInstancesP2).xyz;\n        vec3 p2 = histpos((pp.y + 0.5)/numInstancesP2).xyz;\n        float dist = length(p2 - p1);\n\n        //''if (texpos.x - texpos.y > (-matskipdiag - 2.)/numSegs) distForCol = 0.;\n\n        //TODO: more structured colour genes\n        //##vec3 col1 = vec3(matcoldr, matcoldg, matcoldb);\n        //##vec3 col2 = vec3(mathotr, mathotg, mathotb);\n        vec3 col1 = vec3(matC00r, matC00g, matC00b);\n        vec3 col2 = vec3(matC11r, matC11g, matC11b);\n    //''c.col.rgb = mix(col1, col2, distForCol);\n        //''c.fluoresc.rgb = rgb2hsv(c.col.rgb);\n\n\n        vec2 tp = (texpos.xy * numSegs + 0.5) / numInstances;\n        float v1 = clamp( nval(matintypeA, matrix2dtexA, tp, dist, matDistNear, matDistFar), 0., 1.);\n        if (matintypeA + matintypeB == 0.) {    // old code\n        } else if (matcoltypeA == matcoltypeB) {\n             c.col.rgb = mix(col1, col2, v1);\n        } else {\n            float v2 = clamp(nval(matintypeB, matrix2dtexB, tp, dist, matDistNear, matDistFar), 0., 1.);\n            /**\n            c.col.rgb = bimix(\n                vec3(matC00r, matC00g, matC00b),\n                vec3(matC01r, matC01g, matC01b),\n                vec3(matC10r, matC10g, matC10b),\n                vec3(matC11r, matC11g, matC11b),\n                clamp(v1, 0., 1.), clamp(v2, 0., 1.));\n            **/\n           // cent is the color down the diagonal\n           // tint is the colour at the off-diagonal corner\n           // overall colour uses amount off-diagonal\n            vec3 cent = mix(vec3(matC00r, matC00g, matC00b), vec3(matC11r, matC11g, matC11b), max(v1, v2));\n\n            vec3 tint = v1 > v2 ? vec3(matC10r, matC10g, matC10b) : vec3(matC01r, matC01g, matC01b);\n            c.col.rgb = mix(cent, tint, clamp(matrixTintStrength*abs(v1-v2), 0.,1.));\n        }\n        c.col.rgb = pow(c.col.rgb, vec3(matgamma));  // better perceptual range\n        c.fluoresc.rgb = rgb2hsv(c.col.rgb);\n\n\n        //TODO uniforms for gridline presentation parameters.\n        //Also need to do something about aliasing. Could consider non-binary logic here.\n        if (matrixgridres != 0.) {\n            float dx = abs(fract(texpos.x*numInstances/matrixgridres));\n            float dy = abs(fract(texpos.y*numInstances/matrixgridres));\n            //dx=dy=1.;  // remove comment to remove the grid bands\n\n            float solidW = matrixgridwidth;\n            float softW = matrixgridsoftw;\n            float softR = 1./softW;\n            float fx = 1. - (clamp(dx - solidW, 0., softW) * softR);\n            float fy = 1. - (clamp(dy - solidW, 0., softW) * softR);\n            float f = min(fx+fy, 1.);\n            c.col.rgb += vec3(0,0.7,0.7) * f;\n            //TODO: think better about how to combine with existing hsv...\n            if (f > 0.) {\n                c.fluoresc.rgb = vec3(0.5, 1., 0.1 * f);\n            }\n        }\n\n        vec2 mtp = texpos.xy;  // texture position for looking up bed.  ? texpos ?\n        if (matrixbedtint != 0.) {\n            vec4 bed = texture2D(matrixbed, vec2(mtp.x, 0.5));\n            float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n            float ti = t * 255. - 0.0;\n            // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n            // but close enough for now (famous last words), closer with test against green as well\n            vec3 bedrgb = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n            c.col.rgb += bedrgb * matrixbedtint;\n\n            // TODO factor bed colour option and use for x and y (and ribbon)\n            vec4 bedy = texture2D(matrixbed, vec2(mtp.y, 0.5));\n            float ty = bedy.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n            float tiy = ty * 255. - 0.0;\n            vec3 bedrgby = bedy.r != ty || bedy.g != ty ? bedy.rgb : stdcol(floor(tiy == 0. ? 0. : (mod(tiy, 6.) + 1.)));\n            c.col.rgb += bedrgby * matrixbedtint;\n        }\n\n\n        // darker for region outside active particles/springs\n#define in(x,l,h) (l <= x && x <= h)\n        if (!(in(texpos.x, minActive, maxActive) && in(texpos.y, minActive, maxActive)\n            && (texpos.y - texpos.x < maxBackboneDist))) {\n            c.col.rgb *= 0.5;\n            c.fluoresc.b *= 0.5;\n        }\n\n//;#if OPMODE != OPPICK  // minor optimization\n        // get Pick for all elements of interest.\n        for (int i=0; i<32; i++) {\n            //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n            if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 || i >= 16 ) ) continue;\n            float p = getPickC(i);\n            if (abs(opos.x-p) < 0.001 || abs(opos.y-p) < 0.001) {\n                vec3 pcol = getPickColor(i);\n                c.col.rgb += pcol;\n                vec3 pcolHSV = rgb2hsv(pcol);\n                c.fluoresc.rgb = pcolHSV.rgb;\n            }\n        }\n//;#endif\n        c.surftype.y = 0.;  // prevent default gloss causing confusion. shininess1gloss1subband1plastic1\n        return c;\n    }\n    ":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform float matskipdiag;\nuniform float matX;\nuniform float matY;\nuniform float matZ;\nuniform float matMinD;\nuniform float matMaxD;\nuniform float minActive;\nuniform float maxActive;\nuniform sampler2D rtopos;\nuniform float multifact;\nuniform float multiquatfact;\nuniform float latenormals;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nuniform float hornid;\nvoid main ()\n{\n  lowp vec4 multi_1;\n  vec2 tmpvar_2;\n  tmpvar_2.x = cutx;\n  tmpvar_2.y = cuty;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_2);\n  if ((((tmpvar_3.x * tmpvar_3.x) + (tmpvar_3.y * tmpvar_3.y)) > 1.0)) {\n    discard;\n  };\n  lowp vec4 tmpvar_4;\n  highp vec2 P_5;\n  P_5 = (gl_FragCoord.xy * screen);\n  tmpvar_4 = texture2D (rtopos, P_5);\n  if ((tmpvar_4.w == 0.0)) {\n    discard;\n  };\n  if ((tmpvar_4.w == 2.0)) {\n    discard;\n  };\n  lowp float tmpvar_6;\n  if ((tmpvar_4.w == 99.0)) {\n    tmpvar_6 = 1.0;\n  } else {\n    tmpvar_6 = hornid;\n  };\n  vec3 xmnormal_7;\n  float ribnum_8;\n  lowp float id_9;\n  lowp vec4 p_10;\n  p_10 = tmpvar_4;\n  float tmpvar_11;\n  tmpvar_11 = (numSegs + 1.0);\n  lowp vec2 tmpvar_12;\n  tmpvar_12.x = 0.0;\n  tmpvar_12.y = (((tmpvar_4.x * tmpvar_11) + 0.5) / numInstancesP2);\n  lowp vec2 tmpvar_13;\n  tmpvar_13.x = 0.0;\n  tmpvar_13.y = (((tmpvar_4.y * tmpvar_11) + 0.5) / numInstancesP2);\n  lowp vec3 x_14;\n  x_14 = (texture2D (posNewvals, tmpvar_13).xyz - texture2D (posNewvals, tmpvar_12).xyz);\n  id_9 = (1.0/(clamp ((10.0 + \n    (((sqrt(\n      dot (x_14, x_14)\n    ) - matMinD) * 290.0) / (matMaxD - matMinD))\n  ), 10.0, 300.0)));\n  if (((tmpvar_4.x - tmpvar_4.y) > ((\n    -(matskipdiag)\n   - 2.0) / numSegs))) {\n    id_9 = 0.0;\n  };\n  if (!(((\n    (minActive <= tmpvar_4.x)\n   && \n    (tmpvar_4.x <= maxActive)\n  ) && (\n    (minActive <= tmpvar_4.y)\n   && \n    (tmpvar_4.y <= maxActive)\n  )))) {\n    id_9 = 0.0;\n  };\n  lowp float tmpvar_15;\n  if ((matMaxD == 0.0)) {\n    tmpvar_15 = 0.0;\n  } else {\n    tmpvar_15 = id_9;\n  };\n  p_10.x = (tmpvar_4.x + matX);\n  p_10.y = (tmpvar_4.y + matY);\n  p_10.z = (tmpvar_15 + matZ);\n  multi_1.xyz = (floor((p_10.xyz * multifact)) + ((xmnormal_7 + 1.0) * multiquatfact));\n  if ((latenormals != 0.0)) {\n    multi_1 = p_10;\n  };\n  multi_1.w = (((4096.0 * tmpvar_6) + tmpvar_4.z) + ((float(mod (ribnum_8, 2.0))) * 0.5));\n  if ((tmpvar_6 == 2.0)) {\n    multi_1.w = ((4096.0 * tmpvar_6) + ribnum_8);\n  };\n  gl_FragColor = multi_1;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"}},"texture":{"// CSynth ribbon\n//(gn, s, min, max, delta, step, help, tag, free, useuniform)\ngene('wigmult', 500., 0, 2000, 10, 1, 'multiplier for wig radius', 'geom', 1);\ngene('colmix', 0., 0, 1, 0.1, 0.01, 'proportion of rainbow to use', 'geom', 1);\ngene('scaleFactor', 30., 1., 100., 10, 1, 'scaling factor for 3d ribbon etc', 'geom', 1);\ngene('ribbonPickWidth', 0.04, 0,1, 0.01, 0.01, 'how much of ribbon will have increased radius around selected particles', 'geom', 1 );\ngene('ribbonPickExtra', 0, 0,40, 0.1, 0.1, 'amount by which to increase ribbon diameter around selected particles', 'geom', 1 );\n\ngene('endblobs', 3., 0., 20., 1, 1, 'number of blobs at endc', 'geom', 1);\ngene('endbloblen', 0.01, 0., 0.1, 0.001, 0.0001, 'length of blobby end', 'geom', 1);\n\ngene('killradwidth', 0, 0, 10, 1, 1, 'numer of particles to kill each side of killrad points', 'geom', 1);\n\n\n//gene('numSegs', 87, 0,1023, 1,1, 'number of segments, numInstances-1', 'system', 0);\n//gene('numInstancesP2', 87, 0,1023, 1,1, 'power of 2 to hold all instances', 'system', 0);\nhorn('R').ribs(20).radius(80)\n  .code('vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;') // nb, r set below in skerad\n  .code('#define SKELPICK')\n;\nmainhorn='R';\nonframe(checkvr, 5);\nonframe(checkvr, 25);\nextradefines = `\n  uniform sampler2D t_ribboncol, t_ribbonrad;\n  #define KILLRADLEN 4\n  uniform float killrads[KILLRADLEN];\n`;\noverrides= //gl //comment serves as a tag to start a glsl section\n`\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) { \\\n    float p = getPickC(i);\\\n    float xtra = 1. - abs(p-rp) / ribbonPickWidth;\\\n    rx = max(rx, xtra);\\\n  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n`; ///gl  //comment closes the glsl section\nCSynth.startdemo();\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform sampler2D rtopos;\nuniform sampler2D rtshapepos;\nuniform sampler2D colbuff;\nuniform float multifact;\nuniform float latenormals;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nvoid main ()\n{\n  lowp vec3 texpos_1;\n  vec2 tmpvar_2;\n  tmpvar_2.x = cutx;\n  tmpvar_2.y = cuty;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_2);\n  if ((((tmpvar_3.x * tmpvar_3.x) + (tmpvar_3.y * tmpvar_3.y)) > 1.0)) {\n    discard;\n  };\n  lowp vec4 tmpvar_4;\n  highp vec2 tmpvar_5;\n  tmpvar_5 = (gl_FragCoord.xy * screen);\n  tmpvar_4 = texture2D (rtopos, tmpvar_5);\n  lowp vec4 shapepos_6;\n  lowp vec4 tmpvar_7;\n  tmpvar_7 = texture2D (rtshapepos, tmpvar_5);\n  if ((tmpvar_7.w == 0.0)) {\n    discard;\n  };\n  lowp float tmpvar_8;\n  tmpvar_8 = floor((tmpvar_7.w / 4096.0));\n  if ((latenormals != 0.0)) {\n    shapepos_6 = tmpvar_7;\n  } else {\n    shapepos_6 = (floor(tmpvar_7) / multifact);\n  };\n  shapepos_6.w = 1.0;\n  lowp vec2 tmpvar_9;\n  tmpvar_9.x = 0.21875;\n  tmpvar_9.y = ((tmpvar_8 + 0.5) / 32.0);\n  texpos_1 = (shapepos_6.xyz / max (texture2D (colbuff, tmpvar_9).w, 0.0001));\n  gl_FragColor.w = (4096.0 * tmpvar_8);\n  lowp vec3 lopos_10;\n  lopos_10.x = tmpvar_4.x;\n  lopos_10.z = sin((6.28318 * tmpvar_4.y));\n  lopos_10.y = cos((6.28318 * tmpvar_4.y));\n  lowp vec2 tmpvar_11;\n  tmpvar_11.x = 0.34375;\n  tmpvar_11.y = ((tmpvar_8 + 0.5) / 32.0);\n  lowp vec4 tmpvar_12;\n  tmpvar_12 = texture2D (colbuff, tmpvar_11);\n  lowp vec3 tmpvar_13;\n  if ((tmpvar_12.z == 0.0)) {\n    lowp vec2 tmpvar_14;\n    tmpvar_14.x = 0.96875;\n    tmpvar_14.y = ((tmpvar_8 + 0.5) / 32.0);\n    lowp vec2 tmpvar_15;\n    tmpvar_15.x = 0.96875;\n    tmpvar_15.y = ((tmpvar_8 + 0.5) / 32.0);\n    lowp vec2 tmpvar_16;\n    tmpvar_16.x = 0.96875;\n    tmpvar_16.y = ((tmpvar_8 + 0.5) / 32.0);\n    lowp vec3 tmpvar_17;\n    tmpvar_17.x = texture2D (colbuff, tmpvar_14).x;\n    tmpvar_17.y = texture2D (colbuff, tmpvar_15).y;\n    tmpvar_17.z = texture2D (colbuff, tmpvar_16).y;\n    tmpvar_13 = (lopos_10 * tmpvar_17);\n  } else {\n    lowp vec2 tmpvar_18;\n    tmpvar_18.x = 0.34375;\n    tmpvar_18.y = ((tmpvar_8 + 0.5) / 32.0);\n    lowp vec4 tmpvar_19;\n    tmpvar_19 = texture2D (colbuff, tmpvar_18);\n    lowp vec3 tmpvar_20;\n    if ((tmpvar_19.z == 1.0)) {\n      tmpvar_20 = texpos_1;\n    } else {\n      lowp vec2 tmpvar_21;\n      tmpvar_21.x = 0.96875;\n      tmpvar_21.y = ((tmpvar_8 + 0.5) / 32.0);\n      lowp vec2 tmpvar_22;\n      tmpvar_22.x = 0.96875;\n      tmpvar_22.y = ((tmpvar_8 + 0.5) / 32.0);\n      lowp vec2 tmpvar_23;\n      tmpvar_23.x = 0.96875;\n      tmpvar_23.y = ((tmpvar_8 + 0.5) / 32.0);\n      lowp vec3 tmpvar_24;\n      tmpvar_24.x = texture2D (colbuff, tmpvar_21).x;\n      tmpvar_24.y = texture2D (colbuff, tmpvar_22).y;\n      tmpvar_24.z = texture2D (colbuff, tmpvar_23).y;\n      lowp vec2 tmpvar_25;\n      tmpvar_25.x = 0.34375;\n      tmpvar_25.y = ((tmpvar_8 + 0.5) / 32.0);\n      tmpvar_20 = mix ((lopos_10 * tmpvar_24), texpos_1, texture2D (colbuff, tmpvar_25).z);\n    };\n    tmpvar_13 = tmpvar_20;\n  };\n  lowp float tmpvar_26;\n  lowp float tmpvar_27;\n  tmpvar_27 = (tmpvar_13.z * 0.01);\n  tmpvar_26 = (((tmpvar_27 - \n    floor(tmpvar_27)\n  ) * 0.5) + 0.5);\n  gl_FragColor.z = tmpvar_26;\n  gl_FragColor.y = tmpvar_26;\n  gl_FragColor.x = tmpvar_26;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"},"horn(\"R\").ribs(#R_ribs#).radius(#R_radius#).code(\"vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;\").code(\"#define SKELPICK\");\nmainhorn=\"R\";\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) {     float p = getPickC(i);    float xtra = 1. - abs(p-rp) / ribbonPickWidth;    rx = max(rx, xtra);  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform sampler2D rtopos;\nuniform sampler2D rtshapepos;\nuniform sampler2D colbuff;\nuniform float multifact;\nuniform float latenormals;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nvoid main ()\n{\n  lowp vec3 texpos_1;\n  vec2 tmpvar_2;\n  tmpvar_2.x = cutx;\n  tmpvar_2.y = cuty;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_2);\n  if ((((tmpvar_3.x * tmpvar_3.x) + (tmpvar_3.y * tmpvar_3.y)) > 1.0)) {\n    discard;\n  };\n  lowp vec4 tmpvar_4;\n  highp vec2 tmpvar_5;\n  tmpvar_5 = (gl_FragCoord.xy * screen);\n  tmpvar_4 = texture2D (rtopos, tmpvar_5);\n  lowp vec4 shapepos_6;\n  lowp vec4 tmpvar_7;\n  tmpvar_7 = texture2D (rtshapepos, tmpvar_5);\n  if ((tmpvar_7.w == 0.0)) {\n    discard;\n  };\n  lowp float tmpvar_8;\n  tmpvar_8 = floor((tmpvar_7.w / 4096.0));\n  if ((latenormals != 0.0)) {\n    shapepos_6 = tmpvar_7;\n  } else {\n    shapepos_6 = (floor(tmpvar_7) / multifact);\n  };\n  shapepos_6.w = 1.0;\n  lowp vec2 tmpvar_9;\n  tmpvar_9.x = 0.21875;\n  tmpvar_9.y = ((tmpvar_8 + 0.5) / 32.0);\n  texpos_1 = (shapepos_6.xyz / max (texture2D (colbuff, tmpvar_9).w, 0.0001));\n  gl_FragColor.w = (4096.0 * tmpvar_8);\n  lowp vec3 lopos_10;\n  lopos_10.x = tmpvar_4.x;\n  lopos_10.z = sin((6.28318 * tmpvar_4.y));\n  lopos_10.y = cos((6.28318 * tmpvar_4.y));\n  lowp vec2 tmpvar_11;\n  tmpvar_11.x = 0.34375;\n  tmpvar_11.y = ((tmpvar_8 + 0.5) / 32.0);\n  lowp vec4 tmpvar_12;\n  tmpvar_12 = texture2D (colbuff, tmpvar_11);\n  lowp vec3 tmpvar_13;\n  if ((tmpvar_12.z == 0.0)) {\n    lowp vec2 tmpvar_14;\n    tmpvar_14.x = 0.96875;\n    tmpvar_14.y = ((tmpvar_8 + 0.5) / 32.0);\n    lowp vec2 tmpvar_15;\n    tmpvar_15.x = 0.96875;\n    tmpvar_15.y = ((tmpvar_8 + 0.5) / 32.0);\n    lowp vec2 tmpvar_16;\n    tmpvar_16.x = 0.96875;\n    tmpvar_16.y = ((tmpvar_8 + 0.5) / 32.0);\n    lowp vec3 tmpvar_17;\n    tmpvar_17.x = texture2D (colbuff, tmpvar_14).x;\n    tmpvar_17.y = texture2D (colbuff, tmpvar_15).y;\n    tmpvar_17.z = texture2D (colbuff, tmpvar_16).y;\n    tmpvar_13 = (lopos_10 * tmpvar_17);\n  } else {\n    lowp vec2 tmpvar_18;\n    tmpvar_18.x = 0.34375;\n    tmpvar_18.y = ((tmpvar_8 + 0.5) / 32.0);\n    lowp vec4 tmpvar_19;\n    tmpvar_19 = texture2D (colbuff, tmpvar_18);\n    lowp vec3 tmpvar_20;\n    if ((tmpvar_19.z == 1.0)) {\n      tmpvar_20 = texpos_1;\n    } else {\n      lowp vec2 tmpvar_21;\n      tmpvar_21.x = 0.96875;\n      tmpvar_21.y = ((tmpvar_8 + 0.5) / 32.0);\n      lowp vec2 tmpvar_22;\n      tmpvar_22.x = 0.96875;\n      tmpvar_22.y = ((tmpvar_8 + 0.5) / 32.0);\n      lowp vec2 tmpvar_23;\n      tmpvar_23.x = 0.96875;\n      tmpvar_23.y = ((tmpvar_8 + 0.5) / 32.0);\n      lowp vec3 tmpvar_24;\n      tmpvar_24.x = texture2D (colbuff, tmpvar_21).x;\n      tmpvar_24.y = texture2D (colbuff, tmpvar_22).y;\n      tmpvar_24.z = texture2D (colbuff, tmpvar_23).y;\n      lowp vec2 tmpvar_25;\n      tmpvar_25.x = 0.34375;\n      tmpvar_25.y = ((tmpvar_8 + 0.5) / 32.0);\n      tmpvar_20 = mix ((lopos_10 * tmpvar_24), texpos_1, texture2D (colbuff, tmpvar_25).z);\n    };\n    tmpvar_13 = tmpvar_20;\n  };\n  lowp float tmpvar_26;\n  lowp float tmpvar_27;\n  tmpvar_27 = (tmpvar_13.z * 0.01);\n  tmpvar_26 = (((tmpvar_27 - \n    floor(tmpvar_27)\n  ) * 0.5) + 0.5);\n  gl_FragColor.z = tmpvar_26;\n  gl_FragColor.y = tmpvar_26;\n  gl_FragColor.x = tmpvar_26;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"}},"tshapepos2col":{"// CSynth ribbon\n//(gn, s, min, max, delta, step, help, tag, free, useuniform)\ngene('wigmult', 500., 0, 2000, 10, 1, 'multiplier for wig radius', 'geom', 1);\ngene('colmix', 0., 0, 1, 0.1, 0.01, 'proportion of rainbow to use', 'geom', 1);\ngene('scaleFactor', 30., 1., 100., 10, 1, 'scaling factor for 3d ribbon etc', 'geom', 1);\ngene('ribbonPickWidth', 0.04, 0,1, 0.01, 0.01, 'how much of ribbon will have increased radius around selected particles', 'geom', 1 );\ngene('ribbonPickExtra', 0, 0,40, 0.1, 0.1, 'amount by which to increase ribbon diameter around selected particles', 'geom', 1 );\n\ngene('endblobs', 3., 0., 20., 1, 1, 'number of blobs at endc', 'geom', 1);\ngene('endbloblen', 0.01, 0., 0.1, 0.001, 0.0001, 'length of blobby end', 'geom', 1);\n\ngene('killradwidth', 0, 0, 10, 1, 1, 'numer of particles to kill each side of killrad points', 'geom', 1);\n\n\n//gene('numSegs', 87, 0,1023, 1,1, 'number of segments, numInstances-1', 'system', 0);\n//gene('numInstancesP2', 87, 0,1023, 1,1, 'power of 2 to hold all instances', 'system', 0);\nhorn('R').ribs(20).radius(80)\n  .code('vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;') // nb, r set below in skerad\n  .code('#define SKELPICK')\n;\nmainhorn='R';\nonframe(checkvr, 5);\nonframe(checkvr, 25);\nextradefines = `\n  uniform sampler2D t_ribboncol, t_ribbonrad;\n  #define KILLRADLEN 4\n  uniform float killrads[KILLRADLEN];\n`;\noverrides= //gl //comment serves as a tag to start a glsl section\n`\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) { \\\n    float p = getPickC(i);\\\n    float xtra = 1. - abs(p-rp) / ribbonPickWidth;\\\n    rx = max(rx, xtra);\\\n  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n`; ///gl  //comment closes the glsl section\nCSynth.startdemo();\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform sampler2D t_ribboncol;\nuniform float colmix;\nuniform sampler2D rtopos;\nuniform sampler2D rtshapepos;\nuniform sampler2D colbuff;\nuniform sampler2D pickrt;\nuniform float multifact;\nuniform float multiquatfact;\nuniform float latenormals;\nuniform float latenormalsred;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nuniform mat4 rot4;\nlowp float colourid;\nuniform float userPicks[16];\nuniform float capres;\nlowp float xhornid;\nuniform sampler2D rttexture;\nuniform vec3 cameraPositionModel;\nuniform float ymin;\nuniform float ymax;\nvec4 postxcol;\nuniform float flulow;\nuniform float opacity;\nuniform float badnormals;\nuniform float colribs;\nuniform float fogr;\nuniform float fogg;\nuniform float fogb;\nuniform float fogstartdist;\nuniform float foghalfdepth;\nuniform float xxposprop;\nuniform float xxnormprop;\nuniform float ambient;\nuniform float light0s;\nuniform float light1s;\nuniform float light2s;\nuniform float light0r;\nuniform float light0g;\nuniform float light0b;\nuniform float light1r;\nuniform float light1g;\nuniform float light1b;\nuniform float light2r;\nuniform float light2g;\nuniform float light2b;\nuniform float light0x;\nuniform float light0y;\nuniform float light0z;\nuniform float light1x;\nuniform float light1y;\nuniform float light1z;\nuniform float light2x;\nuniform float light2y;\nuniform float light2z;\nuniform float light0dirx;\nuniform float light0diry;\nuniform float light0dirz;\nuniform float light1dirx;\nuniform float light1diry;\nuniform float light1dirz;\nuniform float light2dirx;\nuniform float light2diry;\nuniform float light2dirz;\nuniform float light0Spread;\nuniform float light1Spread;\nuniform float light2Spread;\nuniform float light0HalfDist;\nuniform float light1HalfDist;\nuniform float light2HalfDist;\nuniform float fresnel0;\nvoid main ()\n{\n  postxcol = vec4(0.0, 0.0, 0.0, 0.0);\n  vec2 tmpvar_1;\n  tmpvar_1.x = cutx;\n  tmpvar_1.y = cuty;\n  highp vec2 tmpvar_2;\n  tmpvar_2 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_1);\n  if ((((tmpvar_2.x * tmpvar_2.x) + (tmpvar_2.y * tmpvar_2.y)) > 1.0)) {\n    discard;\n  };\n  colourid = xhornid;\n  lowp vec3 xmnormal_3;\n  lowp vec4 shapepos_4;\n  lowp vec4 tmpvar_5;\n  highp vec2 P_6;\n  P_6 = (gl_FragCoord.xy * screen);\n  tmpvar_5 = texture2D (rtshapepos, P_6);\n  if ((tmpvar_5.w == 0.0)) {\n    discard;\n  };\n  lowp float tmpvar_7;\n  tmpvar_7 = floor((tmpvar_5.w / 4096.0));\n  if ((latenormals != 0.0)) {\n    lowp vec3 uBb_8;\n    lowp vec3 uBa_9;\n    lowp vec3 uAb_10;\n    lowp vec3 uAa_11;\n    shapepos_4 = tmpvar_5;\n    vec2 tmpvar_12;\n    tmpvar_12.y = 0.0;\n    tmpvar_12.x = latenormals;\n    lowp vec4 tmpvar_13;\n    highp vec2 P_14;\n    P_14 = ((gl_FragCoord.xy + tmpvar_12) * screen);\n    tmpvar_13 = texture2D (rtshapepos, P_14);\n    vec2 tmpvar_15;\n    tmpvar_15.y = 0.0;\n    float tmpvar_16;\n    tmpvar_16 = -(latenormals);\n    tmpvar_15.x = tmpvar_16;\n    lowp vec4 tmpvar_17;\n    highp vec2 P_18;\n    P_18 = ((gl_FragCoord.xy + tmpvar_15) * screen);\n    tmpvar_17 = texture2D (rtshapepos, P_18);\n    vec2 tmpvar_19;\n    tmpvar_19.x = 0.0;\n    tmpvar_19.y = tmpvar_16;\n    lowp vec4 tmpvar_20;\n    highp vec2 P_21;\n    P_21 = ((gl_FragCoord.xy + tmpvar_19) * screen);\n    tmpvar_20 = texture2D (rtshapepos, P_21);\n    vec2 tmpvar_22;\n    tmpvar_22.x = 0.0;\n    tmpvar_22.y = latenormals;\n    lowp vec4 tmpvar_23;\n    highp vec2 P_24;\n    P_24 = ((gl_FragCoord.xy + tmpvar_22) * screen);\n    tmpvar_23 = texture2D (rtshapepos, P_24);\n    if ((tmpvar_13.w == tmpvar_5.w)) {\n      uAa_11 = tmpvar_13.xyz;\n      uAb_10 = tmpvar_5.xyz;\n    } else {\n      if ((tmpvar_17.w == tmpvar_5.w)) {\n        uAa_11 = tmpvar_5.xyz;\n        uAb_10 = tmpvar_17.xyz;\n      } else {\n        lowp vec3 tmpvar_25;\n        if ((floor((tmpvar_5.w / 4096.0)) == floor((tmpvar_13.w / 4096.0)))) {\n          tmpvar_25 = tmpvar_13.xyz;\n        } else {\n          tmpvar_25 = tmpvar_5.xyz;\n        };\n        uAa_11 = tmpvar_25;\n        lowp vec3 tmpvar_26;\n        if ((floor((tmpvar_5.w / 4096.0)) == floor((tmpvar_17.w / 4096.0)))) {\n          tmpvar_26 = tmpvar_17.xyz;\n        } else {\n          tmpvar_26 = tmpvar_5.xyz;\n        };\n        uAb_10 = tmpvar_26;\n      };\n    };\n    if ((tmpvar_20.w == tmpvar_5.w)) {\n      uBa_9 = tmpvar_20.xyz;\n      uBb_8 = tmpvar_5.xyz;\n    } else {\n      if ((tmpvar_17.w == tmpvar_5.w)) {\n        uBa_9 = tmpvar_5.xyz;\n        uBb_8 = tmpvar_23.xyz;\n      } else {\n        lowp vec3 tmpvar_27;\n        if ((floor((tmpvar_5.w / 4096.0)) == floor((tmpvar_20.w / 4096.0)))) {\n          tmpvar_27 = tmpvar_20.xyz;\n        } else {\n          tmpvar_27 = tmpvar_5.xyz;\n        };\n        uBa_9 = tmpvar_27;\n        lowp vec3 tmpvar_28;\n        if ((floor((tmpvar_5.w / 4096.0)) == floor((tmpvar_23.w / 4096.0)))) {\n          tmpvar_28 = tmpvar_23.xyz;\n        } else {\n          tmpvar_28 = tmpvar_5.xyz;\n        };\n        uBb_8 = tmpvar_28;\n      };\n    };\n    lowp vec3 tmpvar_29;\n    lowp vec3 a_30;\n    a_30 = (uBa_9 - uBb_8);\n    lowp vec3 b_31;\n    b_31 = (uAa_11 - uAb_10);\n    tmpvar_29 = ((a_30.yzx * b_31.zxy) - (a_30.zxy * b_31.yzx));\n    lowp float tmpvar_32;\n    tmpvar_32 = sqrt(dot (tmpvar_29, tmpvar_29));\n    if ((tmpvar_32 < 1e-9)) {\n      vec4 tmpvar_33;\n      tmpvar_33.yzw = vec3(0.0, 0.0, 0.0);\n      tmpvar_33.x = latenormalsred;\n      postxcol = tmpvar_33;\n      xmnormal_3 = vec3(0.0, 0.0, 1.09);\n    } else {\n      lowp vec3 tmpvar_34;\n      tmpvar_34 = normalize(tmpvar_29);\n      xmnormal_3.xz = tmpvar_34.xz;\n      xmnormal_3.y = (tmpvar_34.y + 1e-15);\n    };\n  } else {\n    shapepos_4 = (floor(tmpvar_5) / multifact);\n    xmnormal_3 = ((fract(tmpvar_5) / multiquatfact) - 1.0).xyz;\n  };\n  shapepos_4.w = 1.0;\n  colourid = tmpvar_7;\n  xhornid = tmpvar_7;\n  mat4 tmpvar_35;\n  if ((tmpvar_7 == 2.0)) {\n    tmpvar_35 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  } else {\n    tmpvar_35 = rot4;\n  };\n  lowp vec4 tmpvar_36;\n  tmpvar_36 = (shapepos_4 * tmpvar_35);\n  mediump vec4 tmpvar_37;\n  colourid = tmpvar_7;\n  lowp vec2 tmpvar_38;\n  tmpvar_38.x = 0.34375;\n  tmpvar_38.y = ((tmpvar_7 + 0.5) / 32.0);\n  lowp vec4 tmpvar_39;\n  tmpvar_39 = texture2D (colbuff, tmpvar_38);\n  bool tmpvar_40;\n  if ((tmpvar_39.w != 0.0)) {\n    tmpvar_40 = bool(1);\n  } else {\n    lowp vec2 tmpvar_41;\n    tmpvar_41.x = 0.40625;\n    tmpvar_41.y = ((tmpvar_7 + 0.5) / 32.0);\n    tmpvar_40 = (texture2D (colbuff, tmpvar_41).x != 0.0);\n  };\n  bool tmpvar_42;\n  if (tmpvar_40) {\n    tmpvar_42 = bool(1);\n  } else {\n    lowp vec2 tmpvar_43;\n    tmpvar_43.x = 0.40625;\n    tmpvar_43.y = ((tmpvar_7 + 0.5) / 32.0);\n    tmpvar_42 = (texture2D (colbuff, tmpvar_43).y != 0.0);\n  };\n  if ((tmpvar_42 || (colribs != 0.0))) {\n    highp vec2 P_44;\n    P_44 = (gl_FragCoord.xy * screen);\n    colourid = (tmpvar_7 + (colribs * texture2D (rtopos, P_44).z));\n    colourid = (float(mod (colourid, 32.0)));\n  };\n  lowp vec4 res_45;\n  lowp vec4 col_46;\n  lowp vec3 mmnormal_47;\n  lowp vec3 tmpvar_48;\n  tmpvar_48 = normalize(xmnormal_3);\n  if (!(((ymin <= tmpvar_36.y) && (tmpvar_36.y <= ymax)))) {\n    discard;\n  };\n  mat4 tmpvar_49;\n  if ((colourid == 2.0)) {\n    tmpvar_49 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  } else {\n    tmpvar_49 = rot4;\n  };\n  mat3 tmpvar_50;\n  tmpvar_50[0] = tmpvar_49[0].xyz;\n  tmpvar_50[1] = tmpvar_49[1].xyz;\n  tmpvar_50[2] = tmpvar_49[2].xyz;\n  lowp vec3 tmpvar_51;\n  tmpvar_51 = (-(tmpvar_48) * tmpvar_50);\n  lowp float tmpvar_52;\n  lowp vec3 x_53;\n  x_53 = (cameraPositionModel - tmpvar_36.xyz);\n  tmpvar_52 = sqrt(dot (x_53, x_53));\n  lowp vec3 tmpvar_54;\n  tmpvar_54 = normalize((cameraPositionModel - tmpvar_36.xyz));\n  mmnormal_47 = -(tmpvar_51);\n  if ((xmnormal_3.z == 1.09)) {\n    mmnormal_47 = -(tmpvar_54);\n  } else {\n    lowp float tmpvar_55;\n    tmpvar_55 = dot (tmpvar_54, mmnormal_47);\n    if ((tmpvar_55 < 0.0)) {\n      if ((badnormals == 0.0)) {\n        postxcol = vec4(1.0, 1.0, 0.0, 1.0);\n      } else {\n        if ((badnormals != 1.0)) {\n          if ((badnormals == 2.0)) {\n            mmnormal_47 = (mmnormal_47 - (tmpvar_55 * tmpvar_54));\n          } else {\n            if ((badnormals < 0.0)) {\n              mmnormal_47 = (mmnormal_47 - ((\n                -(badnormals)\n               * tmpvar_55) * tmpvar_54));\n            } else {\n              if ((badnormals == 3.0)) {\n                mmnormal_47 = tmpvar_51;\n              } else {\n                if ((badnormals == 4.0)) {\n                  if ((tmpvar_55 < -0.2)) {\n                    mmnormal_47 = tmpvar_51;\n                  } else {\n                    mmnormal_47 = (mmnormal_47 - (tmpvar_55 * tmpvar_54));\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  highp int i_56;\n  lowp float op_57;\n  lowp vec3 col_58;\n  highp vec2 P_59;\n  P_59 = (gl_FragCoord.xy * screen);\n  lowp float tmpvar_60;\n  tmpvar_60 = texture2D (rtopos, P_59).x;\n  lowp vec3 tmpvar_61;\n  tmpvar_61 = clamp (clamp ((\n    abs(((fract(\n      (vec3(tmpvar_60) + vec3(1.0, 0.6666667, 0.3333333))\n    ) * 6.0) - vec3(3.0, 3.0, 3.0)))\n   - vec3(1.0, 1.0, 1.0)), 0.0, 1.0), 0.0, 1.0);\n  lowp vec2 tmpvar_62;\n  tmpvar_62.y = 0.5;\n  tmpvar_62.x = tmpvar_60;\n  lowp vec4 tmpvar_63;\n  tmpvar_63 = texture2D (t_ribboncol, tmpvar_62);\n  lowp float tmpvar_64;\n  tmpvar_64 = (tmpvar_63.w * 255.0);\n  lowp vec3 tmpvar_65;\n  if (((tmpvar_63.x != tmpvar_63.w) || (tmpvar_63.y != tmpvar_63.w))) {\n    tmpvar_65 = tmpvar_63.xyz;\n  } else {\n    lowp float tmpvar_66;\n    if ((tmpvar_64 == 0.0)) {\n      tmpvar_66 = 0.0;\n    } else {\n      tmpvar_66 = ((float(mod (tmpvar_64, 6.0))) + 1.0);\n    };\n    vec3 col_67;\n    lowp float tmpvar_68;\n    tmpvar_68 = floor((floor(tmpvar_66) + 0.5));\n    if ((tmpvar_68 < 0.0)) {\n      col_67 = vec3(9.5, 0.5, 0.5);\n    } else {\n      if ((tmpvar_68 == 0.0)) {\n        col_67 = vec3(0.5, 0.5, 0.5);\n      } else {\n        if ((tmpvar_68 == 1.0)) {\n          col_67 = vec3(1.0, 0.0, 0.0);\n        } else {\n          if ((tmpvar_68 == 2.0)) {\n            col_67 = vec3(0.0, 1.0, 0.0);\n          } else {\n            if ((tmpvar_68 == 3.0)) {\n              col_67 = vec3(0.0, 0.0, 1.0);\n            } else {\n              if ((tmpvar_68 == 4.0)) {\n                col_67 = vec3(0.0, 1.0, 1.0);\n              } else {\n                if ((tmpvar_68 == 5.0)) {\n                  col_67 = vec3(0.0, 1.0, 0.0);\n                } else {\n                  if ((tmpvar_68 == 6.0)) {\n                    col_67 = vec3(1.0, 1.0, 0.0);\n                  } else {\n                    col_67 = vec3(1.0, 1.0, 1.0);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n    tmpvar_65 = col_67;\n  };\n  col_58 = mix (tmpvar_65, tmpvar_61, colmix);\n  highp vec2 P_69;\n  P_69 = (gl_FragCoord.xy * screen);\n  op_57 = ((texture2D (rtopos, P_69).x - (capres * 0.5)) / (1.0 - capres));\n//  i_56 = 0;\n//  while (true) {\n//    if ((i_56 >= 16)) {\n//      break;\n//    };\nfor (int i_56 = 0; i_56 < 16; i_56++) {\n    if (!(((\n      ((((i_56 == 0) || (i_56 == 4)) || (i_56 == 5)) || (i_56 == 8))\n     || \n      (i_56 == 12)\n    ) || (i_56 == 13)))) {\n//      i_56++;\n      continue;\n    };\n    lowp float tmpvar_70;\n    if ((i_56 == 16)) {\n      tmpvar_70 = userPicks[0];\n    } else {\n      if ((i_56 == 17)) {\n        tmpvar_70 = userPicks[1];\n      } else {\n        if ((i_56 == 18)) {\n          tmpvar_70 = userPicks[2];\n        } else {\n          if ((i_56 == 19)) {\n            tmpvar_70 = userPicks[3];\n          } else {\n            if ((i_56 == 20)) {\n              tmpvar_70 = userPicks[4];\n            } else {\n              if ((i_56 == 21)) {\n                tmpvar_70 = userPicks[5];\n              } else {\n                if ((i_56 == 22)) {\n                  tmpvar_70 = userPicks[6];\n                } else {\n                  if ((i_56 == 23)) {\n                    tmpvar_70 = userPicks[7];\n                  } else {\n                    if ((i_56 == 24)) {\n                      tmpvar_70 = userPicks[8];\n                    } else {\n                      if ((i_56 == 25)) {\n                        tmpvar_70 = userPicks[9];\n                      } else {\n                        if ((i_56 == 26)) {\n                          tmpvar_70 = userPicks[10];\n                        } else {\n                          if ((i_56 == 27)) {\n                            tmpvar_70 = userPicks[11];\n                          } else {\n                            if ((i_56 == 28)) {\n                              tmpvar_70 = userPicks[12];\n                            } else {\n                              if ((i_56 == 29)) {\n                                tmpvar_70 = userPicks[13];\n                              } else {\n                                if ((i_56 == 30)) {\n                                  tmpvar_70 = userPicks[14];\n                                } else {\n                                  if ((i_56 == 31)) {\n                                    tmpvar_70 = userPicks[15];\n                                  } else {\n                                    float tmpvar_71;\n                                    tmpvar_71 = (float(i_56) / 4.0);\n                                    float tmpvar_72;\n                                    tmpvar_72 = floor(tmpvar_71);\n                                    vec2 tmpvar_73;\n                                    tmpvar_73.y = 0.5;\n                                    tmpvar_73.x = (tmpvar_72 / 4.0);\n                                    lowp vec4 tmpvar_74;\n                                    tmpvar_74 = texture2D (pickrt, tmpvar_73);\n                                    highp int tmpvar_75;\n                                    tmpvar_75 = int(floor((\n                                      (tmpvar_71 - tmpvar_72)\n                                     * 4.0)));\n                                    lowp float tmpvar_76;\n                                    if ((tmpvar_75 == 0)) {\n                                      tmpvar_76 = tmpvar_74.x;\n                                    } else {\n                                      lowp float tmpvar_77;\n                                      if ((tmpvar_75 == 1)) {\n                                        tmpvar_77 = tmpvar_74.y;\n                                      } else {\n                                        lowp float tmpvar_78;\n                                        if ((tmpvar_75 == 2)) {\n                                          tmpvar_78 = tmpvar_74.z;\n                                        } else {\n                                          lowp float tmpvar_79;\n                                          if ((tmpvar_75 == 3)) {\n                                            tmpvar_79 = tmpvar_74.w;\n                                          } else {\n                                            tmpvar_79 = 999.0;\n                                          };\n                                          tmpvar_78 = tmpvar_79;\n                                        };\n                                        tmpvar_77 = tmpvar_78;\n                                      };\n                                      tmpvar_76 = tmpvar_77;\n                                    };\n                                    tmpvar_70 = tmpvar_76;\n                                  };\n                                };\n                              };\n                            };\n                          };\n                        };\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n    lowp float tmpvar_80;\n    tmpvar_80 = (10.0 * (1.0 - clamp (\n      (abs((op_57 - tmpvar_70)) * 400.0)\n    , 0.0, 1.0)));\n    lowp float tmpvar_81;\n    tmpvar_81 = abs((op_57 - tmpvar_70));\n    lowp float tmpvar_82;\n    if (((tmpvar_81 * 14000.0) < 1.0)) {\n      tmpvar_82 = 0.0;\n    } else {\n      tmpvar_82 = tmpvar_80;\n    };\n    lowp vec3 tmpvar_83;\n    tmpvar_83.x = tmpvar_80;\n    tmpvar_83.y = tmpvar_82;\n    tmpvar_83.z = tmpvar_82;\n    vec3 tmpvar_84;\n    if ((i_56 < 8)) {\n      tmpvar_84 = vec3(1.0, 0.0, 0.0);\n    } else {\n      if ((i_56 < 16)) {\n        tmpvar_84 = vec3(0.0, 1.0, 0.0);\n      } else {\n        if ((i_56 == 16)) {\n          tmpvar_84 = vec3(0.0, 1.0, 1.0);\n        } else {\n          if ((i_56 == 17)) {\n            tmpvar_84 = vec3(1.0, 0.0, 1.0);\n          } else {\n            if ((i_56 == 18)) {\n              tmpvar_84 = vec3(1.0, 1.0, 0.0);\n            } else {\n              if ((i_56 == 19)) {\n                tmpvar_84 = vec3(1.0, 1.0, 1.0);\n              } else {\n                if ((i_56 == 20)) {\n                  tmpvar_84 = vec3(0.5, 1.0, 1.0);\n                } else {\n                  if ((i_56 == 21)) {\n                    tmpvar_84 = vec3(1.0, 0.5, 1.0);\n                  } else {\n                    if ((i_56 == 22)) {\n                      tmpvar_84 = vec3(1.0, 1.0, 0.5);\n                    } else {\n                      if ((i_56 == 23)) {\n                        tmpvar_84 = vec3(1.0, 1.0, 1.0);\n                      } else {\n                        tmpvar_84 = vec3(1.0, 1.0, 1.0);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n    col_58 = (col_58 + ((tmpvar_83 * tmpvar_84) * 0.1));\n//    i_56++;\n  };\n  vec3 tmpvar_85;\n  bool tmpvar_86;\n  lowp vec3 tmpvar_87;\n  tmpvar_87 = normalize(tmpvar_54);\n  lowp vec3 tmpvar_88;\n  tmpvar_88 = normalize(mmnormal_47);\n  tmpvar_86 = (light0dirx >= 490.0);\n  vec3 tmpvar_89;\n  tmpvar_89.x = light0dirx;\n  tmpvar_89.y = light0diry;\n  tmpvar_89.z = light0dirz;\n  vec3 tmpvar_90;\n  tmpvar_90 = normalize(tmpvar_89);\n  vec3 tmpvar_91;\n  tmpvar_91.x = light0x;\n  tmpvar_91.y = light0y;\n  tmpvar_91.z = light0z;\n  vec3 tmpvar_92;\n  tmpvar_92.x = light0r;\n  tmpvar_92.y = light0g;\n  tmpvar_92.z = light0b;\n  tmpvar_85 = (vec3(0.6, 0.6, 0.6) * tmpvar_92);\n  lowp vec3 tmpvar_93;\n  vec3 tmpvar_94;\n  tmpvar_94 = tmpvar_85;\n  lowp float normdotlight_95;\n  lowp float lightfall_96;\n  lowp vec3 point2light_97;\n  if (tmpvar_86) {\n    point2light_97 = normalize(tmpvar_91);\n    lightfall_96 = 1.0;\n  } else {\n    lowp float dist_98;\n    lowp vec3 tmpvar_99;\n    tmpvar_99 = normalize((tmpvar_91 - tmpvar_36.xyz));\n    point2light_97 = tmpvar_99;\n    lowp vec3 x_100;\n    x_100 = (tmpvar_36.xyz - tmpvar_91);\n    dist_98 = (sqrt(dot (x_100, x_100)) / light0HalfDist);\n    lightfall_96 = (max (0.0, (\n      ((-(dot (tmpvar_99, tmpvar_90)) + light0Spread) - 1.0)\n     / light0Spread)) * (1.0/((1.0 + \n      (dist_98 * dist_98)\n    ))));\n  };\n  lowp float tmpvar_101;\n  tmpvar_101 = dot (point2light_97, tmpvar_88);\n  normdotlight_95 = tmpvar_101;\n  if ((tmpvar_101 < 0.0)) {\n    normdotlight_95 = -(tmpvar_101);\n    point2light_97 = -(point2light_97);\n    tmpvar_94 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_102;\n  lowp float fresnel_103;\n  lowp vec3 V_104;\n  V_104.xy = tmpvar_87.xy;\n  V_104.z = (tmpvar_87.z + 0.0001);\n  lowp vec3 tmpvar_105;\n  tmpvar_105 = normalize((point2light_97 + V_104));\n  lowp float tmpvar_106;\n  tmpvar_106 = dot (tmpvar_88, tmpvar_105);\n  lowp float tmpvar_107;\n  tmpvar_107 = dot (V_104, tmpvar_105);\n  lowp float tmpvar_108;\n  tmpvar_108 = dot (tmpvar_88, V_104);\n  lowp float tmpvar_109;\n  tmpvar_109 = (tmpvar_106 * tmpvar_106);\n  float tmpvar_110;\n  tmpvar_110 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_111;\n  tmpvar_111 = (tmpvar_110 * tmpvar_110);\n  fresnel_103 = (pow (max (0.0, \n    (1.0 - tmpvar_107)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_103 = (fresnel_103 + fresnel0);\n  specular_102 = (((fresnel_103 * \n    ((1.0/(((4.0 * tmpvar_111) * (tmpvar_109 * tmpvar_109)))) * exp(((tmpvar_109 - 1.0) / (tmpvar_111 * tmpvar_109))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_106) * tmpvar_108) / tmpvar_107), (((2.0 * tmpvar_106) * clamp (\n      dot (tmpvar_88, point2light_97)\n    , 0.0, 1.0)) / tmpvar_107))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_108));\n  if (!(((0.0 <= specular_102) && (specular_102 <= 1e+20)))) {\n    specular_102 = 0.0;\n  };\n  tmpvar_93 = (((\n    ((((0.4 * normdotlight_95) * col_58) + ((specular_102 * 0.3461539) * (0.5 + \n      (col_58 * 0.5)\n    ))) * tmpvar_94)\n   * lightfall_96) * (1.0 - ambient)) * light0s);\n  tmpvar_86 = (light1dirx >= 490.0);\n  vec3 tmpvar_112;\n  tmpvar_112.x = light1dirx;\n  tmpvar_112.y = light1diry;\n  tmpvar_112.z = light1dirz;\n  vec3 tmpvar_113;\n  tmpvar_113 = normalize(tmpvar_112);\n  vec3 tmpvar_114;\n  tmpvar_114.x = light1x;\n  tmpvar_114.y = light1y;\n  tmpvar_114.z = light1z;\n  vec3 tmpvar_115;\n  tmpvar_115.x = light1r;\n  tmpvar_115.y = light1g;\n  tmpvar_115.z = light1b;\n  tmpvar_85 = (vec3(0.6, 0.6, 0.6) * tmpvar_115);\n  lowp vec3 tmpvar_116;\n  vec3 tmpvar_117;\n  tmpvar_117 = tmpvar_85;\n  lowp float normdotlight_118;\n  lowp float lightfall_119;\n  lowp vec3 point2light_120;\n  if (tmpvar_86) {\n    point2light_120 = normalize(tmpvar_114);\n    lightfall_119 = 1.0;\n  } else {\n    lowp float dist_121;\n    lowp vec3 tmpvar_122;\n    tmpvar_122 = normalize((tmpvar_114 - tmpvar_36.xyz));\n    point2light_120 = tmpvar_122;\n    lowp vec3 x_123;\n    x_123 = (tmpvar_36.xyz - tmpvar_114);\n    dist_121 = (sqrt(dot (x_123, x_123)) / light1HalfDist);\n    lightfall_119 = (max (0.0, (\n      ((-(dot (tmpvar_122, tmpvar_113)) + light1Spread) - 1.0)\n     / light1Spread)) * (1.0/((1.0 + \n      (dist_121 * dist_121)\n    ))));\n  };\n  lowp float tmpvar_124;\n  tmpvar_124 = dot (point2light_120, tmpvar_88);\n  normdotlight_118 = tmpvar_124;\n  if ((tmpvar_124 < 0.0)) {\n    normdotlight_118 = -(tmpvar_124);\n    point2light_120 = -(point2light_120);\n    tmpvar_117 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_125;\n  lowp float fresnel_126;\n  lowp vec3 V_127;\n  V_127.xy = tmpvar_87.xy;\n  V_127.z = (tmpvar_87.z + 0.0001);\n  lowp vec3 tmpvar_128;\n  tmpvar_128 = normalize((point2light_120 + V_127));\n  lowp float tmpvar_129;\n  tmpvar_129 = dot (tmpvar_88, tmpvar_128);\n  lowp float tmpvar_130;\n  tmpvar_130 = dot (V_127, tmpvar_128);\n  lowp float tmpvar_131;\n  tmpvar_131 = dot (tmpvar_88, V_127);\n  lowp float tmpvar_132;\n  tmpvar_132 = (tmpvar_129 * tmpvar_129);\n  float tmpvar_133;\n  tmpvar_133 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_134;\n  tmpvar_134 = (tmpvar_133 * tmpvar_133);\n  fresnel_126 = (pow (max (0.0, \n    (1.0 - tmpvar_130)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_126 = (fresnel_126 + fresnel0);\n  specular_125 = (((fresnel_126 * \n    ((1.0/(((4.0 * tmpvar_134) * (tmpvar_132 * tmpvar_132)))) * exp(((tmpvar_132 - 1.0) / (tmpvar_134 * tmpvar_132))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_129) * tmpvar_131) / tmpvar_130), (((2.0 * tmpvar_129) * clamp (\n      dot (tmpvar_88, point2light_120)\n    , 0.0, 1.0)) / tmpvar_130))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_131));\n  if (!(((0.0 <= specular_125) && (specular_125 <= 1e+20)))) {\n    specular_125 = 0.0;\n  };\n  tmpvar_116 = (((\n    ((((0.4 * normdotlight_118) * col_58) + ((specular_125 * 0.3461539) * (0.5 + \n      (col_58 * 0.5)\n    ))) * tmpvar_117)\n   * lightfall_119) * (1.0 - ambient)) * light1s);\n  tmpvar_86 = (light2dirx >= 490.0);\n  vec3 tmpvar_135;\n  tmpvar_135.x = light2dirx;\n  tmpvar_135.y = light2diry;\n  tmpvar_135.z = light2dirz;\n  vec3 tmpvar_136;\n  tmpvar_136 = normalize(tmpvar_135);\n  vec3 tmpvar_137;\n  tmpvar_137.x = light2x;\n  tmpvar_137.y = light2y;\n  tmpvar_137.z = light2z;\n  vec3 tmpvar_138;\n  tmpvar_138.x = light2r;\n  tmpvar_138.y = light2g;\n  tmpvar_138.z = light2b;\n  tmpvar_85 = (vec3(0.6, 0.6, 0.6) * tmpvar_138);\n  vec3 tmpvar_139;\n  tmpvar_139 = tmpvar_85;\n  lowp float normdotlight_140;\n  lowp float lightfall_141;\n  lowp vec3 point2light_142;\n  if (tmpvar_86) {\n    point2light_142 = normalize(tmpvar_137);\n    lightfall_141 = 1.0;\n  } else {\n    lowp float dist_143;\n    lowp vec3 tmpvar_144;\n    tmpvar_144 = normalize((tmpvar_137 - tmpvar_36.xyz));\n    point2light_142 = tmpvar_144;\n    lowp vec3 x_145;\n    x_145 = (tmpvar_36.xyz - tmpvar_137);\n    dist_143 = (sqrt(dot (x_145, x_145)) / light2HalfDist);\n    lightfall_141 = (max (0.0, (\n      ((-(dot (tmpvar_144, tmpvar_136)) + light2Spread) - 1.0)\n     / light2Spread)) * (1.0/((1.0 + \n      (dist_143 * dist_143)\n    ))));\n  };\n  lowp float tmpvar_146;\n  tmpvar_146 = dot (point2light_142, tmpvar_88);\n  normdotlight_140 = tmpvar_146;\n  if ((tmpvar_146 < 0.0)) {\n    normdotlight_140 = -(tmpvar_146);\n    point2light_142 = -(point2light_142);\n    tmpvar_139 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_147;\n  lowp float fresnel_148;\n  lowp vec3 V_149;\n  V_149.xy = tmpvar_87.xy;\n  V_149.z = (tmpvar_87.z + 0.0001);\n  lowp vec3 tmpvar_150;\n  tmpvar_150 = normalize((point2light_142 + V_149));\n  lowp float tmpvar_151;\n  tmpvar_151 = dot (tmpvar_88, tmpvar_150);\n  lowp float tmpvar_152;\n  tmpvar_152 = dot (V_149, tmpvar_150);\n  lowp float tmpvar_153;\n  tmpvar_153 = dot (tmpvar_88, V_149);\n  lowp float tmpvar_154;\n  tmpvar_154 = (tmpvar_151 * tmpvar_151);\n  float tmpvar_155;\n  tmpvar_155 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_156;\n  tmpvar_156 = (tmpvar_155 * tmpvar_155);\n  fresnel_148 = (pow (max (0.0, \n    (1.0 - tmpvar_152)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_148 = (fresnel_148 + fresnel0);\n  specular_147 = (((fresnel_148 * \n    ((1.0/(((4.0 * tmpvar_156) * (tmpvar_154 * tmpvar_154)))) * exp(((tmpvar_154 - 1.0) / (tmpvar_156 * tmpvar_154))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_151) * tmpvar_153) / tmpvar_152), (((2.0 * tmpvar_151) * clamp (\n      dot (tmpvar_88, point2light_142)\n    , 0.0, 1.0)) / tmpvar_152))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_153));\n  if (!(((0.0 <= specular_147) && (specular_147 <= 1e+20)))) {\n    specular_147 = 0.0;\n  };\n  lowp vec4 tmpvar_157;\n  tmpvar_157.w = 1.0;\n  tmpvar_157.xyz = (((tmpvar_93 + tmpvar_116) + (\n    ((((\n      ((0.4 * normdotlight_140) * col_58)\n     + \n      ((specular_147 * 0.3461539) * (0.5 + (col_58 * 0.5)))\n    ) * tmpvar_139) * lightfall_141) * (1.0 - ambient))\n   * light2s)) + (ambient * col_58));\n  col_46.xyz = tmpvar_157.xyz;\n  col_46.w = 1.0;\n  res_45 = col_46;\n  lowp vec2 tmpvar_158;\n  tmpvar_158.x = 0.96875;\n  tmpvar_158.y = ((colourid + 0.5) / 32.0);\n  lowp vec4 tmpvar_159;\n  tmpvar_159 = texture2D (colbuff, tmpvar_158);\n  if ((tmpvar_159.z != 0.0)) {\n    lowp vec2 tmpvar_160;\n    tmpvar_160.x = 0.96875;\n    tmpvar_160.y = ((colourid + 0.5) / 32.0);\n    lowp vec4 tmpvar_161;\n    tmpvar_161 = texture2D (colbuff, tmpvar_160);\n    if ((tmpvar_161.z < 0.0)) {\n      res_45.xyz = (tmpvar_157.xyz + clamp (vec3(0.0, 0.0, 0.0), 0.0, 1.0));\n    } else {\n      lowp vec2 tmpvar_162;\n      tmpvar_162.x = 0.96875;\n      tmpvar_162.y = ((colourid + 0.5) / 32.0);\n      lowp vec2 tmpvar_163;\n      tmpvar_163.x = 0.21875;\n      tmpvar_163.y = ((colourid + 0.5) / 32.0);\n      lowp float tmpvar_164;\n      tmpvar_164 = (texture2D (colbuff, tmpvar_162).z / texture2D (colbuff, tmpvar_163).w);\n      lowp float tmpvar_165;\n      tmpvar_165 = (flulow + tmpvar_164);\n      lowp vec4 tmpvar_166;\n      highp vec2 P_167;\n      P_167 = (gl_FragCoord.xy * screen);\n      tmpvar_166 = texture2D (rttexture, P_167);\n      lowp vec4 tmpvar_168;\n      highp vec2 P_169;\n      P_169 = ((gl_FragCoord.xy + vec2(0.0, 1.0)) * screen);\n      tmpvar_168 = texture2D (rttexture, P_169);\n      lowp vec4 tmpvar_170;\n      highp vec2 P_171;\n      P_171 = ((gl_FragCoord.xy + vec2(1.0, 0.0)) * screen);\n      tmpvar_170 = texture2D (rttexture, P_171);\n      lowp vec4 tmpvar_172;\n      highp vec2 P_173;\n      P_173 = ((gl_FragCoord.xy + vec2(1.0, 1.0)) * screen);\n      tmpvar_172 = texture2D (rttexture, P_173);\n      if (!(((\n        (tmpvar_166.w != tmpvar_168.w)\n       || \n        (tmpvar_166.w != tmpvar_170.w)\n      ) || (tmpvar_166.w != tmpvar_172.w)))) {\n        lowp float tmpvar_174;\n        tmpvar_174 = min (min (tmpvar_166.x, tmpvar_168.x), min (tmpvar_170.x, tmpvar_172.x));\n        lowp float tmpvar_175;\n        tmpvar_175 = max (max (tmpvar_166.x, tmpvar_168.x), max (tmpvar_170.x, tmpvar_172.x));\n        if (!(((tmpvar_174 > tmpvar_165) || (tmpvar_175 < flulow)))) {\n          lowp float tmpvar_176;\n          tmpvar_176 = max (tmpvar_174, flulow);\n          lowp float tmpvar_177;\n          tmpvar_177 = min (tmpvar_175, tmpvar_165);\n          lowp float tmpvar_178;\n          if ((tmpvar_175 == tmpvar_174)) {\n            tmpvar_178 = 1.0;\n          } else {\n            tmpvar_178 = ((tmpvar_177 - tmpvar_176) / (tmpvar_175 - tmpvar_174));\n          };\n          res_45.xyz = (res_45.xyz + (clamp (vec3(0.0, 0.0, 0.0), 0.0, 1.0) * (tmpvar_178 * \n            ((((tmpvar_176 - flulow) / tmpvar_164) + ((tmpvar_177 - flulow) / tmpvar_164)) * 0.5)\n          )));\n        };\n      };\n    };\n  };\n  if ((foghalfdepth != 0.0)) {\n    vec3 tmpvar_179;\n    tmpvar_179.x = fogr;\n    tmpvar_179.y = fogg;\n    tmpvar_179.z = fogb;\n    res_45.xyz = mix (tmpvar_179, res_45.xyz, pow (0.5, (\n      max (0.0, (tmpvar_52 - fogstartdist))\n     / foghalfdepth)));\n  };\n  res_45.xyz = (res_45 + postxcol).xyz;\n  res_45.w = opacity;\n  lowp vec4 tmpvar_180;\n  tmpvar_180.w = 1.0;\n  tmpvar_180.xyz = ((xmnormal_3 + 1.0) * 0.5);\n  lowp vec4 tmpvar_181;\n  tmpvar_181.w = 1.0;\n  tmpvar_181.xyz = ((shapepos_4.xyz + 300.0) / 600.0);\n  lowp vec4 tmpvar_182;\n  tmpvar_182 = (((res_45 * \n    ((1.0 - xxposprop) - xxnormprop)\n  ) + (tmpvar_180 * xxnormprop)) + (tmpvar_181 * xxposprop));\n  tmpvar_37 = tmpvar_182;\n  gl_FragColor = tmpvar_37;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"},"horn(\"R\").ribs(#R_ribs#).radius(#R_radius#).code(\"vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;\").code(\"#define SKELPICK\");\nmainhorn=\"R\";\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) {     float p = getPickC(i);    float xtra = 1. - abs(p-rp) / ribbonPickWidth;    rx = max(rx, xtra);  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform sampler2D t_ribboncol;\nuniform float colmix;\nuniform sampler2D rtopos;\nuniform sampler2D rtshapepos;\nuniform sampler2D colbuff;\nuniform sampler2D pickrt;\nuniform float multifact;\nuniform float multiquatfact;\nuniform float latenormals;\nuniform float latenormalsred;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nuniform mat4 rot4;\nlowp float colourid;\nuniform float userPicks[16];\nuniform float capres;\nlowp float xhornid;\nuniform sampler2D rttexture;\nuniform vec3 cameraPositionModel;\nuniform float ymin;\nuniform float ymax;\nvec4 postxcol;\nuniform float flulow;\nuniform float opacity;\nuniform float badnormals;\nuniform float colribs;\nuniform float fogr;\nuniform float fogg;\nuniform float fogb;\nuniform float fogstartdist;\nuniform float foghalfdepth;\nuniform float xxposprop;\nuniform float xxnormprop;\nuniform float ambient;\nuniform float light0s;\nuniform float light1s;\nuniform float light2s;\nuniform float light0r;\nuniform float light0g;\nuniform float light0b;\nuniform float light1r;\nuniform float light1g;\nuniform float light1b;\nuniform float light2r;\nuniform float light2g;\nuniform float light2b;\nuniform float light0x;\nuniform float light0y;\nuniform float light0z;\nuniform float light1x;\nuniform float light1y;\nuniform float light1z;\nuniform float light2x;\nuniform float light2y;\nuniform float light2z;\nuniform float light0dirx;\nuniform float light0diry;\nuniform float light0dirz;\nuniform float light1dirx;\nuniform float light1diry;\nuniform float light1dirz;\nuniform float light2dirx;\nuniform float light2diry;\nuniform float light2dirz;\nuniform float light0Spread;\nuniform float light1Spread;\nuniform float light2Spread;\nuniform float light0HalfDist;\nuniform float light1HalfDist;\nuniform float light2HalfDist;\nuniform float fresnel0;\nvoid main ()\n{\n  postxcol = vec4(0.0, 0.0, 0.0, 0.0);\n  vec2 tmpvar_1;\n  tmpvar_1.x = cutx;\n  tmpvar_1.y = cuty;\n  highp vec2 tmpvar_2;\n  tmpvar_2 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_1);\n  if ((((tmpvar_2.x * tmpvar_2.x) + (tmpvar_2.y * tmpvar_2.y)) > 1.0)) {\n    discard;\n  };\n  colourid = xhornid;\n  lowp vec3 xmnormal_3;\n  lowp vec4 shapepos_4;\n  lowp vec4 tmpvar_5;\n  highp vec2 P_6;\n  P_6 = (gl_FragCoord.xy * screen);\n  tmpvar_5 = texture2D (rtshapepos, P_6);\n  if ((tmpvar_5.w == 0.0)) {\n    discard;\n  };\n  lowp float tmpvar_7;\n  tmpvar_7 = floor((tmpvar_5.w / 4096.0));\n  if ((latenormals != 0.0)) {\n    lowp vec3 uBb_8;\n    lowp vec3 uBa_9;\n    lowp vec3 uAb_10;\n    lowp vec3 uAa_11;\n    shapepos_4 = tmpvar_5;\n    vec2 tmpvar_12;\n    tmpvar_12.y = 0.0;\n    tmpvar_12.x = latenormals;\n    lowp vec4 tmpvar_13;\n    highp vec2 P_14;\n    P_14 = ((gl_FragCoord.xy + tmpvar_12) * screen);\n    tmpvar_13 = texture2D (rtshapepos, P_14);\n    vec2 tmpvar_15;\n    tmpvar_15.y = 0.0;\n    float tmpvar_16;\n    tmpvar_16 = -(latenormals);\n    tmpvar_15.x = tmpvar_16;\n    lowp vec4 tmpvar_17;\n    highp vec2 P_18;\n    P_18 = ((gl_FragCoord.xy + tmpvar_15) * screen);\n    tmpvar_17 = texture2D (rtshapepos, P_18);\n    vec2 tmpvar_19;\n    tmpvar_19.x = 0.0;\n    tmpvar_19.y = tmpvar_16;\n    lowp vec4 tmpvar_20;\n    highp vec2 P_21;\n    P_21 = ((gl_FragCoord.xy + tmpvar_19) * screen);\n    tmpvar_20 = texture2D (rtshapepos, P_21);\n    vec2 tmpvar_22;\n    tmpvar_22.x = 0.0;\n    tmpvar_22.y = latenormals;\n    lowp vec4 tmpvar_23;\n    highp vec2 P_24;\n    P_24 = ((gl_FragCoord.xy + tmpvar_22) * screen);\n    tmpvar_23 = texture2D (rtshapepos, P_24);\n    if ((tmpvar_13.w == tmpvar_5.w)) {\n      uAa_11 = tmpvar_13.xyz;\n      uAb_10 = tmpvar_5.xyz;\n    } else {\n      if ((tmpvar_17.w == tmpvar_5.w)) {\n        uAa_11 = tmpvar_5.xyz;\n        uAb_10 = tmpvar_17.xyz;\n      } else {\n        lowp vec3 tmpvar_25;\n        if ((floor((tmpvar_5.w / 4096.0)) == floor((tmpvar_13.w / 4096.0)))) {\n          tmpvar_25 = tmpvar_13.xyz;\n        } else {\n          tmpvar_25 = tmpvar_5.xyz;\n        };\n        uAa_11 = tmpvar_25;\n        lowp vec3 tmpvar_26;\n        if ((floor((tmpvar_5.w / 4096.0)) == floor((tmpvar_17.w / 4096.0)))) {\n          tmpvar_26 = tmpvar_17.xyz;\n        } else {\n          tmpvar_26 = tmpvar_5.xyz;\n        };\n        uAb_10 = tmpvar_26;\n      };\n    };\n    if ((tmpvar_20.w == tmpvar_5.w)) {\n      uBa_9 = tmpvar_20.xyz;\n      uBb_8 = tmpvar_5.xyz;\n    } else {\n      if ((tmpvar_17.w == tmpvar_5.w)) {\n        uBa_9 = tmpvar_5.xyz;\n        uBb_8 = tmpvar_23.xyz;\n      } else {\n        lowp vec3 tmpvar_27;\n        if ((floor((tmpvar_5.w / 4096.0)) == floor((tmpvar_20.w / 4096.0)))) {\n          tmpvar_27 = tmpvar_20.xyz;\n        } else {\n          tmpvar_27 = tmpvar_5.xyz;\n        };\n        uBa_9 = tmpvar_27;\n        lowp vec3 tmpvar_28;\n        if ((floor((tmpvar_5.w / 4096.0)) == floor((tmpvar_23.w / 4096.0)))) {\n          tmpvar_28 = tmpvar_23.xyz;\n        } else {\n          tmpvar_28 = tmpvar_5.xyz;\n        };\n        uBb_8 = tmpvar_28;\n      };\n    };\n    lowp vec3 tmpvar_29;\n    lowp vec3 a_30;\n    a_30 = (uBa_9 - uBb_8);\n    lowp vec3 b_31;\n    b_31 = (uAa_11 - uAb_10);\n    tmpvar_29 = ((a_30.yzx * b_31.zxy) - (a_30.zxy * b_31.yzx));\n    lowp float tmpvar_32;\n    tmpvar_32 = sqrt(dot (tmpvar_29, tmpvar_29));\n    if ((tmpvar_32 < 1e-9)) {\n      vec4 tmpvar_33;\n      tmpvar_33.yzw = vec3(0.0, 0.0, 0.0);\n      tmpvar_33.x = latenormalsred;\n      postxcol = tmpvar_33;\n      xmnormal_3 = vec3(0.0, 0.0, 1.09);\n    } else {\n      lowp vec3 tmpvar_34;\n      tmpvar_34 = normalize(tmpvar_29);\n      xmnormal_3.xz = tmpvar_34.xz;\n      xmnormal_3.y = (tmpvar_34.y + 1e-15);\n    };\n  } else {\n    shapepos_4 = (floor(tmpvar_5) / multifact);\n    xmnormal_3 = ((fract(tmpvar_5) / multiquatfact) - 1.0).xyz;\n  };\n  shapepos_4.w = 1.0;\n  colourid = tmpvar_7;\n  xhornid = tmpvar_7;\n  mat4 tmpvar_35;\n  if ((tmpvar_7 == 2.0)) {\n    tmpvar_35 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  } else {\n    tmpvar_35 = rot4;\n  };\n  lowp vec4 tmpvar_36;\n  tmpvar_36 = (shapepos_4 * tmpvar_35);\n  mediump vec4 tmpvar_37;\n  colourid = tmpvar_7;\n  lowp vec2 tmpvar_38;\n  tmpvar_38.x = 0.34375;\n  tmpvar_38.y = ((tmpvar_7 + 0.5) / 32.0);\n  lowp vec4 tmpvar_39;\n  tmpvar_39 = texture2D (colbuff, tmpvar_38);\n  bool tmpvar_40;\n  if ((tmpvar_39.w != 0.0)) {\n    tmpvar_40 = bool(1);\n  } else {\n    lowp vec2 tmpvar_41;\n    tmpvar_41.x = 0.40625;\n    tmpvar_41.y = ((tmpvar_7 + 0.5) / 32.0);\n    tmpvar_40 = (texture2D (colbuff, tmpvar_41).x != 0.0);\n  };\n  bool tmpvar_42;\n  if (tmpvar_40) {\n    tmpvar_42 = bool(1);\n  } else {\n    lowp vec2 tmpvar_43;\n    tmpvar_43.x = 0.40625;\n    tmpvar_43.y = ((tmpvar_7 + 0.5) / 32.0);\n    tmpvar_42 = (texture2D (colbuff, tmpvar_43).y != 0.0);\n  };\n  if ((tmpvar_42 || (colribs != 0.0))) {\n    highp vec2 P_44;\n    P_44 = (gl_FragCoord.xy * screen);\n    colourid = (tmpvar_7 + (colribs * texture2D (rtopos, P_44).z));\n    colourid = (float(mod (colourid, 32.0)));\n  };\n  lowp vec4 res_45;\n  lowp vec4 col_46;\n  lowp vec3 mmnormal_47;\n  lowp vec3 tmpvar_48;\n  tmpvar_48 = normalize(xmnormal_3);\n  if (!(((ymin <= tmpvar_36.y) && (tmpvar_36.y <= ymax)))) {\n    discard;\n  };\n  mat4 tmpvar_49;\n  if ((colourid == 2.0)) {\n    tmpvar_49 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  } else {\n    tmpvar_49 = rot4;\n  };\n  mat3 tmpvar_50;\n  tmpvar_50[0] = tmpvar_49[0].xyz;\n  tmpvar_50[1] = tmpvar_49[1].xyz;\n  tmpvar_50[2] = tmpvar_49[2].xyz;\n  lowp vec3 tmpvar_51;\n  tmpvar_51 = (-(tmpvar_48) * tmpvar_50);\n  lowp float tmpvar_52;\n  lowp vec3 x_53;\n  x_53 = (cameraPositionModel - tmpvar_36.xyz);\n  tmpvar_52 = sqrt(dot (x_53, x_53));\n  lowp vec3 tmpvar_54;\n  tmpvar_54 = normalize((cameraPositionModel - tmpvar_36.xyz));\n  mmnormal_47 = -(tmpvar_51);\n  if ((xmnormal_3.z == 1.09)) {\n    mmnormal_47 = -(tmpvar_54);\n  } else {\n    lowp float tmpvar_55;\n    tmpvar_55 = dot (tmpvar_54, mmnormal_47);\n    if ((tmpvar_55 < 0.0)) {\n      if ((badnormals == 0.0)) {\n        postxcol = vec4(1.0, 1.0, 0.0, 1.0);\n      } else {\n        if ((badnormals != 1.0)) {\n          if ((badnormals == 2.0)) {\n            mmnormal_47 = (mmnormal_47 - (tmpvar_55 * tmpvar_54));\n          } else {\n            if ((badnormals < 0.0)) {\n              mmnormal_47 = (mmnormal_47 - ((\n                -(badnormals)\n               * tmpvar_55) * tmpvar_54));\n            } else {\n              if ((badnormals == 3.0)) {\n                mmnormal_47 = tmpvar_51;\n              } else {\n                if ((badnormals == 4.0)) {\n                  if ((tmpvar_55 < -0.2)) {\n                    mmnormal_47 = tmpvar_51;\n                  } else {\n                    mmnormal_47 = (mmnormal_47 - (tmpvar_55 * tmpvar_54));\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  highp int i_56;\n  lowp float op_57;\n  lowp vec3 col_58;\n  highp vec2 P_59;\n  P_59 = (gl_FragCoord.xy * screen);\n  lowp float tmpvar_60;\n  tmpvar_60 = texture2D (rtopos, P_59).x;\n  lowp vec3 tmpvar_61;\n  tmpvar_61 = clamp (clamp ((\n    abs(((fract(\n      (vec3(tmpvar_60) + vec3(1.0, 0.6666667, 0.3333333))\n    ) * 6.0) - vec3(3.0, 3.0, 3.0)))\n   - vec3(1.0, 1.0, 1.0)), 0.0, 1.0), 0.0, 1.0);\n  lowp vec2 tmpvar_62;\n  tmpvar_62.y = 0.5;\n  tmpvar_62.x = tmpvar_60;\n  lowp vec4 tmpvar_63;\n  tmpvar_63 = texture2D (t_ribboncol, tmpvar_62);\n  lowp float tmpvar_64;\n  tmpvar_64 = (tmpvar_63.w * 255.0);\n  lowp vec3 tmpvar_65;\n  if (((tmpvar_63.x != tmpvar_63.w) || (tmpvar_63.y != tmpvar_63.w))) {\n    tmpvar_65 = tmpvar_63.xyz;\n  } else {\n    lowp float tmpvar_66;\n    if ((tmpvar_64 == 0.0)) {\n      tmpvar_66 = 0.0;\n    } else {\n      tmpvar_66 = ((float(mod (tmpvar_64, 6.0))) + 1.0);\n    };\n    vec3 col_67;\n    lowp float tmpvar_68;\n    tmpvar_68 = floor((floor(tmpvar_66) + 0.5));\n    if ((tmpvar_68 < 0.0)) {\n      col_67 = vec3(9.5, 0.5, 0.5);\n    } else {\n      if ((tmpvar_68 == 0.0)) {\n        col_67 = vec3(0.5, 0.5, 0.5);\n      } else {\n        if ((tmpvar_68 == 1.0)) {\n          col_67 = vec3(1.0, 0.0, 0.0);\n        } else {\n          if ((tmpvar_68 == 2.0)) {\n            col_67 = vec3(0.0, 1.0, 0.0);\n          } else {\n            if ((tmpvar_68 == 3.0)) {\n              col_67 = vec3(0.0, 0.0, 1.0);\n            } else {\n              if ((tmpvar_68 == 4.0)) {\n                col_67 = vec3(0.0, 1.0, 1.0);\n              } else {\n                if ((tmpvar_68 == 5.0)) {\n                  col_67 = vec3(0.0, 1.0, 0.0);\n                } else {\n                  if ((tmpvar_68 == 6.0)) {\n                    col_67 = vec3(1.0, 1.0, 0.0);\n                  } else {\n                    col_67 = vec3(1.0, 1.0, 1.0);\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n    tmpvar_65 = col_67;\n  };\n  col_58 = mix (tmpvar_65, tmpvar_61, colmix);\n  highp vec2 P_69;\n  P_69 = (gl_FragCoord.xy * screen);\n  op_57 = ((texture2D (rtopos, P_69).x - (capres * 0.5)) / (1.0 - capres));\n//  i_56 = 0;\n//  while (true) {\n//    if ((i_56 >= 16)) {\n//      break;\n//    };\nfor (int i_56 = 0; i_56 < 16; i_56++) {\n    if (!(((\n      ((((i_56 == 0) || (i_56 == 4)) || (i_56 == 5)) || (i_56 == 8))\n     || \n      (i_56 == 12)\n    ) || (i_56 == 13)))) {\n//      i_56++;\n      continue;\n    };\n    lowp float tmpvar_70;\n    if ((i_56 == 16)) {\n      tmpvar_70 = userPicks[0];\n    } else {\n      if ((i_56 == 17)) {\n        tmpvar_70 = userPicks[1];\n      } else {\n        if ((i_56 == 18)) {\n          tmpvar_70 = userPicks[2];\n        } else {\n          if ((i_56 == 19)) {\n            tmpvar_70 = userPicks[3];\n          } else {\n            if ((i_56 == 20)) {\n              tmpvar_70 = userPicks[4];\n            } else {\n              if ((i_56 == 21)) {\n                tmpvar_70 = userPicks[5];\n              } else {\n                if ((i_56 == 22)) {\n                  tmpvar_70 = userPicks[6];\n                } else {\n                  if ((i_56 == 23)) {\n                    tmpvar_70 = userPicks[7];\n                  } else {\n                    if ((i_56 == 24)) {\n                      tmpvar_70 = userPicks[8];\n                    } else {\n                      if ((i_56 == 25)) {\n                        tmpvar_70 = userPicks[9];\n                      } else {\n                        if ((i_56 == 26)) {\n                          tmpvar_70 = userPicks[10];\n                        } else {\n                          if ((i_56 == 27)) {\n                            tmpvar_70 = userPicks[11];\n                          } else {\n                            if ((i_56 == 28)) {\n                              tmpvar_70 = userPicks[12];\n                            } else {\n                              if ((i_56 == 29)) {\n                                tmpvar_70 = userPicks[13];\n                              } else {\n                                if ((i_56 == 30)) {\n                                  tmpvar_70 = userPicks[14];\n                                } else {\n                                  if ((i_56 == 31)) {\n                                    tmpvar_70 = userPicks[15];\n                                  } else {\n                                    float tmpvar_71;\n                                    tmpvar_71 = (float(i_56) / 4.0);\n                                    float tmpvar_72;\n                                    tmpvar_72 = floor(tmpvar_71);\n                                    vec2 tmpvar_73;\n                                    tmpvar_73.y = 0.5;\n                                    tmpvar_73.x = (tmpvar_72 / 4.0);\n                                    lowp vec4 tmpvar_74;\n                                    tmpvar_74 = texture2D (pickrt, tmpvar_73);\n                                    highp int tmpvar_75;\n                                    tmpvar_75 = int(floor((\n                                      (tmpvar_71 - tmpvar_72)\n                                     * 4.0)));\n                                    lowp float tmpvar_76;\n                                    if ((tmpvar_75 == 0)) {\n                                      tmpvar_76 = tmpvar_74.x;\n                                    } else {\n                                      lowp float tmpvar_77;\n                                      if ((tmpvar_75 == 1)) {\n                                        tmpvar_77 = tmpvar_74.y;\n                                      } else {\n                                        lowp float tmpvar_78;\n                                        if ((tmpvar_75 == 2)) {\n                                          tmpvar_78 = tmpvar_74.z;\n                                        } else {\n                                          lowp float tmpvar_79;\n                                          if ((tmpvar_75 == 3)) {\n                                            tmpvar_79 = tmpvar_74.w;\n                                          } else {\n                                            tmpvar_79 = 999.0;\n                                          };\n                                          tmpvar_78 = tmpvar_79;\n                                        };\n                                        tmpvar_77 = tmpvar_78;\n                                      };\n                                      tmpvar_76 = tmpvar_77;\n                                    };\n                                    tmpvar_70 = tmpvar_76;\n                                  };\n                                };\n                              };\n                            };\n                          };\n                        };\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n    lowp float tmpvar_80;\n    tmpvar_80 = (10.0 * (1.0 - clamp (\n      (abs((op_57 - tmpvar_70)) * 400.0)\n    , 0.0, 1.0)));\n    lowp float tmpvar_81;\n    tmpvar_81 = abs((op_57 - tmpvar_70));\n    lowp float tmpvar_82;\n    if (((tmpvar_81 * 14000.0) < 1.0)) {\n      tmpvar_82 = 0.0;\n    } else {\n      tmpvar_82 = tmpvar_80;\n    };\n    lowp vec3 tmpvar_83;\n    tmpvar_83.x = tmpvar_80;\n    tmpvar_83.y = tmpvar_82;\n    tmpvar_83.z = tmpvar_82;\n    vec3 tmpvar_84;\n    if ((i_56 < 8)) {\n      tmpvar_84 = vec3(1.0, 0.0, 0.0);\n    } else {\n      if ((i_56 < 16)) {\n        tmpvar_84 = vec3(0.0, 1.0, 0.0);\n      } else {\n        if ((i_56 == 16)) {\n          tmpvar_84 = vec3(0.0, 1.0, 1.0);\n        } else {\n          if ((i_56 == 17)) {\n            tmpvar_84 = vec3(1.0, 0.0, 1.0);\n          } else {\n            if ((i_56 == 18)) {\n              tmpvar_84 = vec3(1.0, 1.0, 0.0);\n            } else {\n              if ((i_56 == 19)) {\n                tmpvar_84 = vec3(1.0, 1.0, 1.0);\n              } else {\n                if ((i_56 == 20)) {\n                  tmpvar_84 = vec3(0.5, 1.0, 1.0);\n                } else {\n                  if ((i_56 == 21)) {\n                    tmpvar_84 = vec3(1.0, 0.5, 1.0);\n                  } else {\n                    if ((i_56 == 22)) {\n                      tmpvar_84 = vec3(1.0, 1.0, 0.5);\n                    } else {\n                      if ((i_56 == 23)) {\n                        tmpvar_84 = vec3(1.0, 1.0, 1.0);\n                      } else {\n                        tmpvar_84 = vec3(1.0, 1.0, 1.0);\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n    col_58 = (col_58 + ((tmpvar_83 * tmpvar_84) * 0.1));\n//    i_56++;\n  };\n  vec3 tmpvar_85;\n  bool tmpvar_86;\n  lowp vec3 tmpvar_87;\n  tmpvar_87 = normalize(tmpvar_54);\n  lowp vec3 tmpvar_88;\n  tmpvar_88 = normalize(mmnormal_47);\n  tmpvar_86 = (light0dirx >= 490.0);\n  vec3 tmpvar_89;\n  tmpvar_89.x = light0dirx;\n  tmpvar_89.y = light0diry;\n  tmpvar_89.z = light0dirz;\n  vec3 tmpvar_90;\n  tmpvar_90 = normalize(tmpvar_89);\n  vec3 tmpvar_91;\n  tmpvar_91.x = light0x;\n  tmpvar_91.y = light0y;\n  tmpvar_91.z = light0z;\n  vec3 tmpvar_92;\n  tmpvar_92.x = light0r;\n  tmpvar_92.y = light0g;\n  tmpvar_92.z = light0b;\n  tmpvar_85 = (vec3(0.6, 0.6, 0.6) * tmpvar_92);\n  lowp vec3 tmpvar_93;\n  vec3 tmpvar_94;\n  tmpvar_94 = tmpvar_85;\n  lowp float normdotlight_95;\n  lowp float lightfall_96;\n  lowp vec3 point2light_97;\n  if (tmpvar_86) {\n    point2light_97 = normalize(tmpvar_91);\n    lightfall_96 = 1.0;\n  } else {\n    lowp float dist_98;\n    lowp vec3 tmpvar_99;\n    tmpvar_99 = normalize((tmpvar_91 - tmpvar_36.xyz));\n    point2light_97 = tmpvar_99;\n    lowp vec3 x_100;\n    x_100 = (tmpvar_36.xyz - tmpvar_91);\n    dist_98 = (sqrt(dot (x_100, x_100)) / light0HalfDist);\n    lightfall_96 = (max (0.0, (\n      ((-(dot (tmpvar_99, tmpvar_90)) + light0Spread) - 1.0)\n     / light0Spread)) * (1.0/((1.0 + \n      (dist_98 * dist_98)\n    ))));\n  };\n  lowp float tmpvar_101;\n  tmpvar_101 = dot (point2light_97, tmpvar_88);\n  normdotlight_95 = tmpvar_101;\n  if ((tmpvar_101 < 0.0)) {\n    normdotlight_95 = -(tmpvar_101);\n    point2light_97 = -(point2light_97);\n    tmpvar_94 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_102;\n  lowp float fresnel_103;\n  lowp vec3 V_104;\n  V_104.xy = tmpvar_87.xy;\n  V_104.z = (tmpvar_87.z + 0.0001);\n  lowp vec3 tmpvar_105;\n  tmpvar_105 = normalize((point2light_97 + V_104));\n  lowp float tmpvar_106;\n  tmpvar_106 = dot (tmpvar_88, tmpvar_105);\n  lowp float tmpvar_107;\n  tmpvar_107 = dot (V_104, tmpvar_105);\n  lowp float tmpvar_108;\n  tmpvar_108 = dot (tmpvar_88, V_104);\n  lowp float tmpvar_109;\n  tmpvar_109 = (tmpvar_106 * tmpvar_106);\n  float tmpvar_110;\n  tmpvar_110 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_111;\n  tmpvar_111 = (tmpvar_110 * tmpvar_110);\n  fresnel_103 = (pow (max (0.0, \n    (1.0 - tmpvar_107)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_103 = (fresnel_103 + fresnel0);\n  specular_102 = (((fresnel_103 * \n    ((1.0/(((4.0 * tmpvar_111) * (tmpvar_109 * tmpvar_109)))) * exp(((tmpvar_109 - 1.0) / (tmpvar_111 * tmpvar_109))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_106) * tmpvar_108) / tmpvar_107), (((2.0 * tmpvar_106) * clamp (\n      dot (tmpvar_88, point2light_97)\n    , 0.0, 1.0)) / tmpvar_107))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_108));\n  if (!(((0.0 <= specular_102) && (specular_102 <= 1e+20)))) {\n    specular_102 = 0.0;\n  };\n  tmpvar_93 = (((\n    ((((0.4 * normdotlight_95) * col_58) + ((specular_102 * 0.3461539) * (0.5 + \n      (col_58 * 0.5)\n    ))) * tmpvar_94)\n   * lightfall_96) * (1.0 - ambient)) * light0s);\n  tmpvar_86 = (light1dirx >= 490.0);\n  vec3 tmpvar_112;\n  tmpvar_112.x = light1dirx;\n  tmpvar_112.y = light1diry;\n  tmpvar_112.z = light1dirz;\n  vec3 tmpvar_113;\n  tmpvar_113 = normalize(tmpvar_112);\n  vec3 tmpvar_114;\n  tmpvar_114.x = light1x;\n  tmpvar_114.y = light1y;\n  tmpvar_114.z = light1z;\n  vec3 tmpvar_115;\n  tmpvar_115.x = light1r;\n  tmpvar_115.y = light1g;\n  tmpvar_115.z = light1b;\n  tmpvar_85 = (vec3(0.6, 0.6, 0.6) * tmpvar_115);\n  lowp vec3 tmpvar_116;\n  vec3 tmpvar_117;\n  tmpvar_117 = tmpvar_85;\n  lowp float normdotlight_118;\n  lowp float lightfall_119;\n  lowp vec3 point2light_120;\n  if (tmpvar_86) {\n    point2light_120 = normalize(tmpvar_114);\n    lightfall_119 = 1.0;\n  } else {\n    lowp float dist_121;\n    lowp vec3 tmpvar_122;\n    tmpvar_122 = normalize((tmpvar_114 - tmpvar_36.xyz));\n    point2light_120 = tmpvar_122;\n    lowp vec3 x_123;\n    x_123 = (tmpvar_36.xyz - tmpvar_114);\n    dist_121 = (sqrt(dot (x_123, x_123)) / light1HalfDist);\n    lightfall_119 = (max (0.0, (\n      ((-(dot (tmpvar_122, tmpvar_113)) + light1Spread) - 1.0)\n     / light1Spread)) * (1.0/((1.0 + \n      (dist_121 * dist_121)\n    ))));\n  };\n  lowp float tmpvar_124;\n  tmpvar_124 = dot (point2light_120, tmpvar_88);\n  normdotlight_118 = tmpvar_124;\n  if ((tmpvar_124 < 0.0)) {\n    normdotlight_118 = -(tmpvar_124);\n    point2light_120 = -(point2light_120);\n    tmpvar_117 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_125;\n  lowp float fresnel_126;\n  lowp vec3 V_127;\n  V_127.xy = tmpvar_87.xy;\n  V_127.z = (tmpvar_87.z + 0.0001);\n  lowp vec3 tmpvar_128;\n  tmpvar_128 = normalize((point2light_120 + V_127));\n  lowp float tmpvar_129;\n  tmpvar_129 = dot (tmpvar_88, tmpvar_128);\n  lowp float tmpvar_130;\n  tmpvar_130 = dot (V_127, tmpvar_128);\n  lowp float tmpvar_131;\n  tmpvar_131 = dot (tmpvar_88, V_127);\n  lowp float tmpvar_132;\n  tmpvar_132 = (tmpvar_129 * tmpvar_129);\n  float tmpvar_133;\n  tmpvar_133 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_134;\n  tmpvar_134 = (tmpvar_133 * tmpvar_133);\n  fresnel_126 = (pow (max (0.0, \n    (1.0 - tmpvar_130)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_126 = (fresnel_126 + fresnel0);\n  specular_125 = (((fresnel_126 * \n    ((1.0/(((4.0 * tmpvar_134) * (tmpvar_132 * tmpvar_132)))) * exp(((tmpvar_132 - 1.0) / (tmpvar_134 * tmpvar_132))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_129) * tmpvar_131) / tmpvar_130), (((2.0 * tmpvar_129) * clamp (\n      dot (tmpvar_88, point2light_120)\n    , 0.0, 1.0)) / tmpvar_130))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_131));\n  if (!(((0.0 <= specular_125) && (specular_125 <= 1e+20)))) {\n    specular_125 = 0.0;\n  };\n  tmpvar_116 = (((\n    ((((0.4 * normdotlight_118) * col_58) + ((specular_125 * 0.3461539) * (0.5 + \n      (col_58 * 0.5)\n    ))) * tmpvar_117)\n   * lightfall_119) * (1.0 - ambient)) * light1s);\n  tmpvar_86 = (light2dirx >= 490.0);\n  vec3 tmpvar_135;\n  tmpvar_135.x = light2dirx;\n  tmpvar_135.y = light2diry;\n  tmpvar_135.z = light2dirz;\n  vec3 tmpvar_136;\n  tmpvar_136 = normalize(tmpvar_135);\n  vec3 tmpvar_137;\n  tmpvar_137.x = light2x;\n  tmpvar_137.y = light2y;\n  tmpvar_137.z = light2z;\n  vec3 tmpvar_138;\n  tmpvar_138.x = light2r;\n  tmpvar_138.y = light2g;\n  tmpvar_138.z = light2b;\n  tmpvar_85 = (vec3(0.6, 0.6, 0.6) * tmpvar_138);\n  vec3 tmpvar_139;\n  tmpvar_139 = tmpvar_85;\n  lowp float normdotlight_140;\n  lowp float lightfall_141;\n  lowp vec3 point2light_142;\n  if (tmpvar_86) {\n    point2light_142 = normalize(tmpvar_137);\n    lightfall_141 = 1.0;\n  } else {\n    lowp float dist_143;\n    lowp vec3 tmpvar_144;\n    tmpvar_144 = normalize((tmpvar_137 - tmpvar_36.xyz));\n    point2light_142 = tmpvar_144;\n    lowp vec3 x_145;\n    x_145 = (tmpvar_36.xyz - tmpvar_137);\n    dist_143 = (sqrt(dot (x_145, x_145)) / light2HalfDist);\n    lightfall_141 = (max (0.0, (\n      ((-(dot (tmpvar_144, tmpvar_136)) + light2Spread) - 1.0)\n     / light2Spread)) * (1.0/((1.0 + \n      (dist_143 * dist_143)\n    ))));\n  };\n  lowp float tmpvar_146;\n  tmpvar_146 = dot (point2light_142, tmpvar_88);\n  normdotlight_140 = tmpvar_146;\n  if ((tmpvar_146 < 0.0)) {\n    normdotlight_140 = -(tmpvar_146);\n    point2light_142 = -(point2light_142);\n    tmpvar_139 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_147;\n  lowp float fresnel_148;\n  lowp vec3 V_149;\n  V_149.xy = tmpvar_87.xy;\n  V_149.z = (tmpvar_87.z + 0.0001);\n  lowp vec3 tmpvar_150;\n  tmpvar_150 = normalize((point2light_142 + V_149));\n  lowp float tmpvar_151;\n  tmpvar_151 = dot (tmpvar_88, tmpvar_150);\n  lowp float tmpvar_152;\n  tmpvar_152 = dot (V_149, tmpvar_150);\n  lowp float tmpvar_153;\n  tmpvar_153 = dot (tmpvar_88, V_149);\n  lowp float tmpvar_154;\n  tmpvar_154 = (tmpvar_151 * tmpvar_151);\n  float tmpvar_155;\n  tmpvar_155 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_156;\n  tmpvar_156 = (tmpvar_155 * tmpvar_155);\n  fresnel_148 = (pow (max (0.0, \n    (1.0 - tmpvar_152)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_148 = (fresnel_148 + fresnel0);\n  specular_147 = (((fresnel_148 * \n    ((1.0/(((4.0 * tmpvar_156) * (tmpvar_154 * tmpvar_154)))) * exp(((tmpvar_154 - 1.0) / (tmpvar_156 * tmpvar_154))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_151) * tmpvar_153) / tmpvar_152), (((2.0 * tmpvar_151) * clamp (\n      dot (tmpvar_88, point2light_142)\n    , 0.0, 1.0)) / tmpvar_152))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_153));\n  if (!(((0.0 <= specular_147) && (specular_147 <= 1e+20)))) {\n    specular_147 = 0.0;\n  };\n  lowp vec4 tmpvar_157;\n  tmpvar_157.w = 1.0;\n  tmpvar_157.xyz = (((tmpvar_93 + tmpvar_116) + (\n    ((((\n      ((0.4 * normdotlight_140) * col_58)\n     + \n      ((specular_147 * 0.3461539) * (0.5 + (col_58 * 0.5)))\n    ) * tmpvar_139) * lightfall_141) * (1.0 - ambient))\n   * light2s)) + (ambient * col_58));\n  col_46.xyz = tmpvar_157.xyz;\n  col_46.w = 1.0;\n  res_45 = col_46;\n  lowp vec2 tmpvar_158;\n  tmpvar_158.x = 0.96875;\n  tmpvar_158.y = ((colourid + 0.5) / 32.0);\n  lowp vec4 tmpvar_159;\n  tmpvar_159 = texture2D (colbuff, tmpvar_158);\n  if ((tmpvar_159.z != 0.0)) {\n    lowp vec2 tmpvar_160;\n    tmpvar_160.x = 0.96875;\n    tmpvar_160.y = ((colourid + 0.5) / 32.0);\n    lowp vec4 tmpvar_161;\n    tmpvar_161 = texture2D (colbuff, tmpvar_160);\n    if ((tmpvar_161.z < 0.0)) {\n      res_45.xyz = (tmpvar_157.xyz + clamp (vec3(0.0, 0.0, 0.0), 0.0, 1.0));\n    } else {\n      lowp vec2 tmpvar_162;\n      tmpvar_162.x = 0.96875;\n      tmpvar_162.y = ((colourid + 0.5) / 32.0);\n      lowp vec2 tmpvar_163;\n      tmpvar_163.x = 0.21875;\n      tmpvar_163.y = ((colourid + 0.5) / 32.0);\n      lowp float tmpvar_164;\n      tmpvar_164 = (texture2D (colbuff, tmpvar_162).z / texture2D (colbuff, tmpvar_163).w);\n      lowp float tmpvar_165;\n      tmpvar_165 = (flulow + tmpvar_164);\n      lowp vec4 tmpvar_166;\n      highp vec2 P_167;\n      P_167 = (gl_FragCoord.xy * screen);\n      tmpvar_166 = texture2D (rttexture, P_167);\n      lowp vec4 tmpvar_168;\n      highp vec2 P_169;\n      P_169 = ((gl_FragCoord.xy + vec2(0.0, 1.0)) * screen);\n      tmpvar_168 = texture2D (rttexture, P_169);\n      lowp vec4 tmpvar_170;\n      highp vec2 P_171;\n      P_171 = ((gl_FragCoord.xy + vec2(1.0, 0.0)) * screen);\n      tmpvar_170 = texture2D (rttexture, P_171);\n      lowp vec4 tmpvar_172;\n      highp vec2 P_173;\n      P_173 = ((gl_FragCoord.xy + vec2(1.0, 1.0)) * screen);\n      tmpvar_172 = texture2D (rttexture, P_173);\n      if (!(((\n        (tmpvar_166.w != tmpvar_168.w)\n       || \n        (tmpvar_166.w != tmpvar_170.w)\n      ) || (tmpvar_166.w != tmpvar_172.w)))) {\n        lowp float tmpvar_174;\n        tmpvar_174 = min (min (tmpvar_166.x, tmpvar_168.x), min (tmpvar_170.x, tmpvar_172.x));\n        lowp float tmpvar_175;\n        tmpvar_175 = max (max (tmpvar_166.x, tmpvar_168.x), max (tmpvar_170.x, tmpvar_172.x));\n        if (!(((tmpvar_174 > tmpvar_165) || (tmpvar_175 < flulow)))) {\n          lowp float tmpvar_176;\n          tmpvar_176 = max (tmpvar_174, flulow);\n          lowp float tmpvar_177;\n          tmpvar_177 = min (tmpvar_175, tmpvar_165);\n          lowp float tmpvar_178;\n          if ((tmpvar_175 == tmpvar_174)) {\n            tmpvar_178 = 1.0;\n          } else {\n            tmpvar_178 = ((tmpvar_177 - tmpvar_176) / (tmpvar_175 - tmpvar_174));\n          };\n          res_45.xyz = (res_45.xyz + (clamp (vec3(0.0, 0.0, 0.0), 0.0, 1.0) * (tmpvar_178 * \n            ((((tmpvar_176 - flulow) / tmpvar_164) + ((tmpvar_177 - flulow) / tmpvar_164)) * 0.5)\n          )));\n        };\n      };\n    };\n  };\n  if ((foghalfdepth != 0.0)) {\n    vec3 tmpvar_179;\n    tmpvar_179.x = fogr;\n    tmpvar_179.y = fogg;\n    tmpvar_179.z = fogb;\n    res_45.xyz = mix (tmpvar_179, res_45.xyz, pow (0.5, (\n      max (0.0, (tmpvar_52 - fogstartdist))\n     / foghalfdepth)));\n  };\n  res_45.xyz = (res_45 + postxcol).xyz;\n  res_45.w = opacity;\n  lowp vec4 tmpvar_180;\n  tmpvar_180.w = 1.0;\n  tmpvar_180.xyz = ((xmnormal_3 + 1.0) * 0.5);\n  lowp vec4 tmpvar_181;\n  tmpvar_181.w = 1.0;\n  tmpvar_181.xyz = ((shapepos_4.xyz + 300.0) / 600.0);\n  lowp vec4 tmpvar_182;\n  tmpvar_182 = (((res_45 * \n    ((1.0 - xxposprop) - xxnormprop)\n  ) + (tmpvar_180 * xxnormprop)) + (tmpvar_181 * xxposprop));\n  tmpvar_37 = tmpvar_182;\n  gl_FragColor = tmpvar_37;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"},"matrix":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform sampler2D matrixbed;\nuniform float matskipdiag;\nuniform float matC00r;\nuniform float matC00g;\nuniform float matC00b;\nuniform float matC01r;\nuniform float matC01g;\nuniform float matC01b;\nuniform float matC10r;\nuniform float matC10g;\nuniform float matC10b;\nuniform float matC11r;\nuniform float matC11g;\nuniform float matC11b;\nuniform float matDistFar;\nuniform float matDistNear;\nuniform float matrixbedtint;\nuniform float matrixgridres;\nuniform float matrixgridwidth;\nuniform float matrixgridsoftw;\nuniform float matrixcontactmin;\nuniform float matrixcontactmult;\nuniform float matgamma;\nuniform sampler2D matrix2dtexA;\nuniform sampler2D matrix2dtexB;\nuniform float matintypeA;\nuniform float matintypeB;\nuniform float matcoltypeA;\nuniform float matcoltypeB;\nuniform float matrixTintStrength;\nuniform float minActive;\nuniform float maxActive;\nuniform float maxBackboneDist;\nuniform float nonBackboneLen;\nuniform float representativeContact;\nuniform float m_k;\nuniform float m_alpha;\nuniform float pushapartforce;\nuniform float pushapartpow;\nuniform float contactforcesc;\nuniform float powBaseDist;\nuniform sampler2D rtopos;\nuniform sampler2D rtshapepos;\nuniform sampler2D colbuff;\nuniform sampler2D pickrt;\nuniform float multifact;\nuniform float multiquatfact;\nuniform float latenormals;\nuniform float latenormalsred;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nuniform mat4 rot4;\nlowp float colourid;\nuniform float userPicks[16];\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nlowp float xhornid;\nuniform sampler2D rttexture;\nuniform vec3 cameraPositionModel;\nuniform float ymin;\nuniform float ymax;\nvec4 postxcol;\nuniform float flulow;\nuniform float opacity;\nuniform float badnormals;\nuniform float colribs;\nuniform float fogr;\nuniform float fogg;\nuniform float fogb;\nuniform float fogstartdist;\nuniform float foghalfdepth;\nuniform float xxposprop;\nuniform float xxnormprop;\nuniform float ambient;\nuniform float light0s;\nuniform float light1s;\nuniform float light2s;\nuniform float light0r;\nuniform float light0g;\nuniform float light0b;\nuniform float light1r;\nuniform float light1g;\nuniform float light1b;\nuniform float light2r;\nuniform float light2g;\nuniform float light2b;\nuniform float light0x;\nuniform float light0y;\nuniform float light0z;\nuniform float light1x;\nuniform float light1y;\nuniform float light1z;\nuniform float light2x;\nuniform float light2y;\nuniform float light2z;\nuniform float light0dirx;\nuniform float light0diry;\nuniform float light0dirz;\nuniform float light1dirx;\nuniform float light1diry;\nuniform float light1dirz;\nuniform float light2dirx;\nuniform float light2diry;\nuniform float light2dirz;\nuniform float light0Spread;\nuniform float light1Spread;\nuniform float light2Spread;\nuniform float light0HalfDist;\nuniform float light1HalfDist;\nuniform float light2HalfDist;\nuniform float fresnel0;\nvoid main ()\n{\n  postxcol = vec4(0.0, 0.0, 0.0, 0.0);\n  lowp vec3 texpos_1;\n  vec2 tmpvar_2;\n  tmpvar_2.x = cutx;\n  tmpvar_2.y = cuty;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_2);\n  if ((((tmpvar_3.x * tmpvar_3.x) + (tmpvar_3.y * tmpvar_3.y)) > 1.0)) {\n    discard;\n  };\n  colourid = xhornid;\n  lowp vec3 xmnormal_4;\n  lowp vec4 shapepos_5;\n  lowp vec4 tmpvar_6;\n  highp vec2 P_7;\n  P_7 = (gl_FragCoord.xy * screen);\n  tmpvar_6 = texture2D (rtshapepos, P_7);\n  if ((tmpvar_6.w == 0.0)) {\n    discard;\n  };\n  lowp float tmpvar_8;\n  tmpvar_8 = floor((tmpvar_6.w / 4096.0));\n  if ((latenormals != 0.0)) {\n    lowp vec3 uBb_9;\n    lowp vec3 uBa_10;\n    lowp vec3 uAb_11;\n    lowp vec3 uAa_12;\n    shapepos_5 = tmpvar_6;\n    vec2 tmpvar_13;\n    tmpvar_13.y = 0.0;\n    tmpvar_13.x = latenormals;\n    lowp vec4 tmpvar_14;\n    highp vec2 P_15;\n    P_15 = ((gl_FragCoord.xy + tmpvar_13) * screen);\n    tmpvar_14 = texture2D (rtshapepos, P_15);\n    vec2 tmpvar_16;\n    tmpvar_16.y = 0.0;\n    float tmpvar_17;\n    tmpvar_17 = -(latenormals);\n    tmpvar_16.x = tmpvar_17;\n    lowp vec4 tmpvar_18;\n    highp vec2 P_19;\n    P_19 = ((gl_FragCoord.xy + tmpvar_16) * screen);\n    tmpvar_18 = texture2D (rtshapepos, P_19);\n    vec2 tmpvar_20;\n    tmpvar_20.x = 0.0;\n    tmpvar_20.y = tmpvar_17;\n    lowp vec4 tmpvar_21;\n    highp vec2 P_22;\n    P_22 = ((gl_FragCoord.xy + tmpvar_20) * screen);\n    tmpvar_21 = texture2D (rtshapepos, P_22);\n    vec2 tmpvar_23;\n    tmpvar_23.x = 0.0;\n    tmpvar_23.y = latenormals;\n    lowp vec4 tmpvar_24;\n    highp vec2 P_25;\n    P_25 = ((gl_FragCoord.xy + tmpvar_23) * screen);\n    tmpvar_24 = texture2D (rtshapepos, P_25);\n    if ((tmpvar_14.w == tmpvar_6.w)) {\n      uAa_12 = tmpvar_14.xyz;\n      uAb_11 = tmpvar_6.xyz;\n    } else {\n      if ((tmpvar_18.w == tmpvar_6.w)) {\n        uAa_12 = tmpvar_6.xyz;\n        uAb_11 = tmpvar_18.xyz;\n      } else {\n        lowp vec3 tmpvar_26;\n        if ((floor((tmpvar_6.w / 4096.0)) == floor((tmpvar_14.w / 4096.0)))) {\n          tmpvar_26 = tmpvar_14.xyz;\n        } else {\n          tmpvar_26 = tmpvar_6.xyz;\n        };\n        uAa_12 = tmpvar_26;\n        lowp vec3 tmpvar_27;\n        if ((floor((tmpvar_6.w / 4096.0)) == floor((tmpvar_18.w / 4096.0)))) {\n          tmpvar_27 = tmpvar_18.xyz;\n        } else {\n          tmpvar_27 = tmpvar_6.xyz;\n        };\n        uAb_11 = tmpvar_27;\n      };\n    };\n    if ((tmpvar_21.w == tmpvar_6.w)) {\n      uBa_10 = tmpvar_21.xyz;\n      uBb_9 = tmpvar_6.xyz;\n    } else {\n      if ((tmpvar_18.w == tmpvar_6.w)) {\n        uBa_10 = tmpvar_6.xyz;\n        uBb_9 = tmpvar_24.xyz;\n      } else {\n        lowp vec3 tmpvar_28;\n        if ((floor((tmpvar_6.w / 4096.0)) == floor((tmpvar_21.w / 4096.0)))) {\n          tmpvar_28 = tmpvar_21.xyz;\n        } else {\n          tmpvar_28 = tmpvar_6.xyz;\n        };\n        uBa_10 = tmpvar_28;\n        lowp vec3 tmpvar_29;\n        if ((floor((tmpvar_6.w / 4096.0)) == floor((tmpvar_24.w / 4096.0)))) {\n          tmpvar_29 = tmpvar_24.xyz;\n        } else {\n          tmpvar_29 = tmpvar_6.xyz;\n        };\n        uBb_9 = tmpvar_29;\n      };\n    };\n    lowp vec3 tmpvar_30;\n    lowp vec3 a_31;\n    a_31 = (uBa_10 - uBb_9);\n    lowp vec3 b_32;\n    b_32 = (uAa_12 - uAb_11);\n    tmpvar_30 = ((a_31.yzx * b_32.zxy) - (a_31.zxy * b_32.yzx));\n    lowp float tmpvar_33;\n    tmpvar_33 = sqrt(dot (tmpvar_30, tmpvar_30));\n    if ((tmpvar_33 < 1e-9)) {\n      vec4 tmpvar_34;\n      tmpvar_34.yzw = vec3(0.0, 0.0, 0.0);\n      tmpvar_34.x = latenormalsred;\n      postxcol = tmpvar_34;\n      xmnormal_4 = vec3(0.0, 0.0, 1.09);\n    } else {\n      lowp vec3 tmpvar_35;\n      tmpvar_35 = normalize(tmpvar_30);\n      xmnormal_4.xz = tmpvar_35.xz;\n      xmnormal_4.y = (tmpvar_35.y + 1e-15);\n    };\n  } else {\n    shapepos_5 = (floor(tmpvar_6) / multifact);\n    xmnormal_4 = ((fract(tmpvar_6) / multiquatfact) - 1.0).xyz;\n  };\n  shapepos_5.w = 1.0;\n  colourid = tmpvar_8;\n  xhornid = tmpvar_8;\n  texpos_1 = shapepos_5.xyz;\n  mat4 tmpvar_36;\n  if ((tmpvar_8 == 2.0)) {\n    tmpvar_36 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  } else {\n    tmpvar_36 = rot4;\n  };\n  lowp vec4 tmpvar_37;\n  tmpvar_37 = (shapepos_5 * tmpvar_36);\n  mediump vec4 tmpvar_38;\n  colourid = tmpvar_8;\n  lowp vec2 tmpvar_39;\n  tmpvar_39.x = 0.34375;\n  tmpvar_39.y = ((tmpvar_8 + 0.5) / 32.0);\n  lowp vec4 tmpvar_40;\n  tmpvar_40 = texture2D (colbuff, tmpvar_39);\n  bool tmpvar_41;\n  if ((tmpvar_40.w != 0.0)) {\n    tmpvar_41 = bool(1);\n  } else {\n    lowp vec2 tmpvar_42;\n    tmpvar_42.x = 0.40625;\n    tmpvar_42.y = ((tmpvar_8 + 0.5) / 32.0);\n    tmpvar_41 = (texture2D (colbuff, tmpvar_42).x != 0.0);\n  };\n  bool tmpvar_43;\n  if (tmpvar_41) {\n    tmpvar_43 = bool(1);\n  } else {\n    lowp vec2 tmpvar_44;\n    tmpvar_44.x = 0.40625;\n    tmpvar_44.y = ((tmpvar_8 + 0.5) / 32.0);\n    tmpvar_43 = (texture2D (colbuff, tmpvar_44).y != 0.0);\n  };\n  if ((tmpvar_43 || (colribs != 0.0))) {\n    highp vec2 P_45;\n    P_45 = (gl_FragCoord.xy * screen);\n    colourid = (tmpvar_8 + (colribs * texture2D (rtopos, P_45).z));\n    colourid = (float(mod (colourid, 32.0)));\n  };\n  lowp vec4 res_46;\n  lowp vec4 col_47;\n  lowp vec3 mmnormal_48;\n  lowp vec3 tmpvar_49;\n  tmpvar_49 = normalize(xmnormal_4);\n  if (!(((ymin <= tmpvar_37.y) && (tmpvar_37.y <= ymax)))) {\n    discard;\n  };\n  mat4 tmpvar_50;\n  if ((colourid == 2.0)) {\n    tmpvar_50 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  } else {\n    tmpvar_50 = rot4;\n  };\n  mat3 tmpvar_51;\n  tmpvar_51[0] = tmpvar_50[0].xyz;\n  tmpvar_51[1] = tmpvar_50[1].xyz;\n  tmpvar_51[2] = tmpvar_50[2].xyz;\n  lowp vec3 tmpvar_52;\n  tmpvar_52 = (-(tmpvar_49) * tmpvar_51);\n  lowp float tmpvar_53;\n  lowp vec3 x_54;\n  x_54 = (cameraPositionModel - tmpvar_37.xyz);\n  tmpvar_53 = sqrt(dot (x_54, x_54));\n  lowp vec3 tmpvar_55;\n  tmpvar_55 = normalize((cameraPositionModel - tmpvar_37.xyz));\n  mmnormal_48 = -(tmpvar_52);\n  if ((xmnormal_4.z == 1.09)) {\n    mmnormal_48 = -(tmpvar_55);\n  } else {\n    lowp float tmpvar_56;\n    tmpvar_56 = dot (tmpvar_55, mmnormal_48);\n    if ((tmpvar_56 < 0.0)) {\n      if ((badnormals == 0.0)) {\n        postxcol = vec4(1.0, 1.0, 0.0, 1.0);\n      } else {\n        if ((badnormals != 1.0)) {\n          if ((badnormals == 2.0)) {\n            mmnormal_48 = (mmnormal_48 - (tmpvar_56 * tmpvar_55));\n          } else {\n            if ((badnormals < 0.0)) {\n              mmnormal_48 = (mmnormal_48 - ((\n                -(badnormals)\n               * tmpvar_56) * tmpvar_55));\n            } else {\n              if ((badnormals == 3.0)) {\n                mmnormal_48 = tmpvar_52;\n              } else {\n                if ((badnormals == 4.0)) {\n                  if ((tmpvar_56 < -0.2)) {\n                    mmnormal_48 = tmpvar_52;\n                  } else {\n                    mmnormal_48 = (mmnormal_48 - (tmpvar_56 * tmpvar_55));\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  highp int i_57;\n  lowp vec4 tmpvar_58;\n  lowp vec4 tmpvar_59;\n  if (((shapepos_5.x - shapepos_5.y) > (-(matskipdiag) / numSegs))) {\n    discard;\n  };\n  tmpvar_58 = vec4(0.5, 0.5, 0.5, 0.0);\n  tmpvar_59 = vec4(0.0, 0.0, 0.0, 0.0);\n  float tmpvar_60;\n  tmpvar_60 = (numSegs + 1.0);\n  lowp vec3 tmpvar_61;\n  tmpvar_61 = floor(((shapepos_5.xyz * numSegs) + 0.5));\n  lowp vec2 tmpvar_62;\n  tmpvar_62.x = 0.0;\n  tmpvar_62.y = ((tmpvar_61.x + 0.5) / numInstancesP2);\n  lowp vec2 tmpvar_63;\n  tmpvar_63.x = 0.0;\n  tmpvar_63.y = ((tmpvar_61.y + 0.5) / numInstancesP2);\n  lowp float tmpvar_64;\n  lowp vec3 x_65;\n  x_65 = (texture2D (posNewvals, tmpvar_63).xyz - texture2D (posNewvals, tmpvar_62).xyz);\n  tmpvar_64 = sqrt(dot (x_65, x_65));\n  vec3 tmpvar_66;\n  tmpvar_66.x = matC00r;\n  tmpvar_66.y = matC00g;\n  tmpvar_66.z = matC00b;\n  vec3 tmpvar_67;\n  tmpvar_67.x = matC11r;\n  tmpvar_67.y = matC11g;\n  tmpvar_67.z = matC11b;\n  lowp vec2 tmpvar_68;\n  tmpvar_68 = (((shapepos_5.xy * numSegs) + 0.5) / tmpvar_60);\n  lowp float tmpvar_69;\n  if ((matintypeA < 1.5)) {\n    tmpvar_69 = matintypeA;\n  } else {\n    if ((matintypeA < 2.5)) {\n      tmpvar_69 = tmpvar_68.x;\n    } else {\n      if ((matintypeA < 3.5)) {\n        tmpvar_69 = tmpvar_68.y;\n      } else {\n        if ((matintypeA < 4.5)) {\n          lowp float tmpvar_70;\n          tmpvar_70 = clamp (((\n            (tmpvar_64 / nonBackboneLen)\n           - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n          tmpvar_69 = (1.0 - (tmpvar_70 * (tmpvar_70 * \n            (3.0 - (2.0 * tmpvar_70))\n          )));\n        } else {\n          if ((matintypeA < 5.5)) {\n            lowp float tmpvar_71;\n            tmpvar_71 = clamp (((\n              (texture2D (matrix2dtexA, tmpvar_68).x / nonBackboneLen)\n             - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n            tmpvar_69 = (1.0 - (tmpvar_71 * (tmpvar_71 * \n              (3.0 - (2.0 * tmpvar_71))\n            )));\n          } else {\n            if ((matintypeA < 6.5)) {\n              lowp float dist_72;\n              lowp float tmpvar_73;\n              tmpvar_73 = max (0.0, texture2D (matrix2dtexA, tmpvar_68).x);\n              if ((contactforcesc != 0.0)) {\n                dist_72 = pow (((\n                  (tmpvar_73 * contactforcesc)\n                 / pushapartforce) * pow (powBaseDist, pushapartpow)), (1.0/((pushapartpow - 1.0))));\n              } else {\n                dist_72 = (m_k * pow ((tmpvar_73 / representativeContact), -(m_alpha)));\n              };\n              lowp float tmpvar_74;\n              tmpvar_74 = clamp (((dist_72 - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n              tmpvar_69 = (1.0 - (tmpvar_74 * (tmpvar_74 * \n                (3.0 - (2.0 * tmpvar_74))\n              )));\n            } else {\n              tmpvar_69 = ((texture2D (matrix2dtexA, tmpvar_68).x - matrixcontactmin) * matrixcontactmult);\n            };\n          };\n        };\n      };\n    };\n  };\n  lowp float tmpvar_75;\n  tmpvar_75 = clamp (tmpvar_69, 0.0, 1.0);\n  if (((matintypeA + matintypeB) != 0.0)) {\n    if ((matcoltypeA == matcoltypeB)) {\n      tmpvar_58.xyz = mix (tmpvar_66, tmpvar_67, tmpvar_75);\n    } else {\n      lowp float tmpvar_76;\n      if ((matintypeB < 1.5)) {\n        tmpvar_76 = matintypeB;\n      } else {\n        if ((matintypeB < 2.5)) {\n          tmpvar_76 = tmpvar_68.x;\n        } else {\n          if ((matintypeB < 3.5)) {\n            tmpvar_76 = tmpvar_68.y;\n          } else {\n            if ((matintypeB < 4.5)) {\n              lowp float tmpvar_77;\n              tmpvar_77 = clamp (((\n                (tmpvar_64 / nonBackboneLen)\n               - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n              tmpvar_76 = (1.0 - (tmpvar_77 * (tmpvar_77 * \n                (3.0 - (2.0 * tmpvar_77))\n              )));\n            } else {\n              if ((matintypeB < 5.5)) {\n                lowp float tmpvar_78;\n                tmpvar_78 = clamp (((\n                  (texture2D (matrix2dtexB, tmpvar_68).x / nonBackboneLen)\n                 - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n                tmpvar_76 = (1.0 - (tmpvar_78 * (tmpvar_78 * \n                  (3.0 - (2.0 * tmpvar_78))\n                )));\n              } else {\n                if ((matintypeB < 6.5)) {\n                  lowp float dist_79;\n                  lowp float tmpvar_80;\n                  tmpvar_80 = max (0.0, texture2D (matrix2dtexB, tmpvar_68).x);\n                  if ((contactforcesc != 0.0)) {\n                    dist_79 = pow (((\n                      (tmpvar_80 * contactforcesc)\n                     / pushapartforce) * pow (powBaseDist, pushapartpow)), (1.0/((pushapartpow - 1.0))));\n                  } else {\n                    dist_79 = (m_k * pow ((tmpvar_80 / representativeContact), -(m_alpha)));\n                  };\n                  lowp float tmpvar_81;\n                  tmpvar_81 = clamp (((dist_79 - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n                  tmpvar_76 = (1.0 - (tmpvar_81 * (tmpvar_81 * \n                    (3.0 - (2.0 * tmpvar_81))\n                  )));\n                } else {\n                  tmpvar_76 = ((texture2D (matrix2dtexB, tmpvar_68).x - matrixcontactmin) * matrixcontactmult);\n                };\n              };\n            };\n          };\n        };\n      };\n      lowp float tmpvar_82;\n      tmpvar_82 = clamp (tmpvar_76, 0.0, 1.0);\n      vec3 tmpvar_83;\n      tmpvar_83.x = matC00r;\n      tmpvar_83.y = matC00g;\n      tmpvar_83.z = matC00b;\n      vec3 tmpvar_84;\n      tmpvar_84.x = matC11r;\n      tmpvar_84.y = matC11g;\n      tmpvar_84.z = matC11b;\n      lowp vec3 tmpvar_85;\n      tmpvar_85 = mix (tmpvar_83, tmpvar_84, max (tmpvar_75, tmpvar_82));\n      vec3 tmpvar_86;\n      if ((tmpvar_75 > tmpvar_82)) {\n        vec3 tmpvar_87;\n        tmpvar_87.x = matC10r;\n        tmpvar_87.y = matC10g;\n        tmpvar_87.z = matC10b;\n        tmpvar_86 = tmpvar_87;\n      } else {\n        vec3 tmpvar_88;\n        tmpvar_88.x = matC01r;\n        tmpvar_88.y = matC01g;\n        tmpvar_88.z = matC01b;\n        tmpvar_86 = tmpvar_88;\n      };\n      tmpvar_58.xyz = mix (tmpvar_85, tmpvar_86, clamp ((matrixTintStrength * \n        abs((tmpvar_75 - tmpvar_82))\n      ), 0.0, 1.0));\n    };\n  };\n  tmpvar_58.xyz = pow (tmpvar_58.xyz, vec3(matgamma));\n  lowp vec3 c_89;\n  c_89 = tmpvar_58.xyz;\n  lowp vec4 tmpvar_90;\n  tmpvar_90.xy = c_89.zy;\n  tmpvar_90.zw = vec2(-1.0, 0.6666667);\n  lowp vec4 tmpvar_91;\n  tmpvar_91.xy = c_89.yz;\n  tmpvar_91.zw = vec2(0.0, -0.3333333);\n  lowp vec4 tmpvar_92;\n  tmpvar_92 = mix (tmpvar_90, tmpvar_91, float((tmpvar_58.y >= tmpvar_58.z)));\n  lowp vec4 tmpvar_93;\n  tmpvar_93.xyz = tmpvar_92.xyw;\n  tmpvar_93.w = c_89.x;\n  lowp vec4 tmpvar_94;\n  tmpvar_94.x = c_89.x;\n  tmpvar_94.yzw = tmpvar_92.yzx;\n  lowp vec4 tmpvar_95;\n  tmpvar_95 = mix (tmpvar_93, tmpvar_94, float((tmpvar_58.x >= tmpvar_92.x)));\n  lowp float tmpvar_96;\n  tmpvar_96 = (tmpvar_95.x - min (tmpvar_95.w, tmpvar_95.y));\n  lowp vec3 tmpvar_97;\n  tmpvar_97.x = abs((tmpvar_95.z + (\n    (tmpvar_95.w - tmpvar_95.y)\n   / \n    ((6.0 * tmpvar_96) + 1e-10)\n  )));\n  tmpvar_97.y = (tmpvar_96 / (tmpvar_95.x + 1e-10));\n  tmpvar_97.z = tmpvar_95.x;\n  tmpvar_59.xyz = tmpvar_97;\n  if ((matrixgridres != 0.0)) {\n    float tmpvar_98;\n    tmpvar_98 = (1.0/(matrixgridsoftw));\n    lowp float tmpvar_99;\n    tmpvar_99 = min (((1.0 - \n      (clamp ((abs(\n        fract(((shapepos_5.x * tmpvar_60) / matrixgridres))\n      ) - matrixgridwidth), 0.0, matrixgridsoftw) * tmpvar_98)\n    ) + (1.0 - \n      (clamp ((abs(\n        fract(((shapepos_5.y * tmpvar_60) / matrixgridres))\n      ) - matrixgridwidth), 0.0, matrixgridsoftw) * tmpvar_98)\n    )), 1.0);\n    tmpvar_58.xyz = (tmpvar_58.xyz + (vec3(0.0, 0.7, 0.7) * tmpvar_99));\n    if ((tmpvar_99 > 0.0)) {\n      lowp vec3 tmpvar_100;\n      tmpvar_100.xy = vec2(0.5, 1.0);\n      tmpvar_100.z = (0.1 * tmpvar_99);\n      tmpvar_59.xyz = tmpvar_100;\n    };\n  };\n  lowp vec2 tmpvar_101;\n  tmpvar_101 = texpos_1.xy;\n  if ((matrixbedtint != 0.0)) {\n    lowp vec2 tmpvar_102;\n    tmpvar_102.y = 0.5;\n    tmpvar_102.x = tmpvar_101.x;\n    lowp vec4 tmpvar_103;\n    tmpvar_103 = texture2D (matrixbed, tmpvar_102);\n    lowp float tmpvar_104;\n    tmpvar_104 = (tmpvar_103.w * 255.0);\n    lowp vec3 tmpvar_105;\n    if (((tmpvar_103.x != tmpvar_103.w) || (tmpvar_103.y != tmpvar_103.w))) {\n      tmpvar_105 = tmpvar_103.xyz;\n    } else {\n      lowp float tmpvar_106;\n      if ((tmpvar_104 == 0.0)) {\n        tmpvar_106 = 0.0;\n      } else {\n        tmpvar_106 = ((float(mod (tmpvar_104, 6.0))) + 1.0);\n      };\n      vec3 col_107;\n      lowp float tmpvar_108;\n      tmpvar_108 = floor((floor(tmpvar_106) + 0.5));\n      if ((tmpvar_108 < 0.0)) {\n        col_107 = vec3(9.5, 0.5, 0.5);\n      } else {\n        if ((tmpvar_108 == 0.0)) {\n          col_107 = vec3(0.5, 0.5, 0.5);\n        } else {\n          if ((tmpvar_108 == 1.0)) {\n            col_107 = vec3(1.0, 0.0, 0.0);\n          } else {\n            if ((tmpvar_108 == 2.0)) {\n              col_107 = vec3(0.0, 1.0, 0.0);\n            } else {\n              if ((tmpvar_108 == 3.0)) {\n                col_107 = vec3(0.0, 0.0, 1.0);\n              } else {\n                if ((tmpvar_108 == 4.0)) {\n                  col_107 = vec3(0.0, 1.0, 1.0);\n                } else {\n                  if ((tmpvar_108 == 5.0)) {\n                    col_107 = vec3(0.0, 1.0, 0.0);\n                  } else {\n                    if ((tmpvar_108 == 6.0)) {\n                      col_107 = vec3(1.0, 1.0, 0.0);\n                    } else {\n                      col_107 = vec3(1.0, 1.0, 1.0);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n      tmpvar_105 = col_107;\n    };\n    tmpvar_58.xyz = (tmpvar_58.xyz + (tmpvar_105 * matrixbedtint));\n    lowp vec2 tmpvar_109;\n    tmpvar_109.y = 0.5;\n    tmpvar_109.x = tmpvar_101.y;\n    lowp vec4 tmpvar_110;\n    tmpvar_110 = texture2D (matrixbed, tmpvar_109);\n    lowp float tmpvar_111;\n    tmpvar_111 = (tmpvar_110.w * 255.0);\n    lowp vec3 tmpvar_112;\n    if (((tmpvar_110.x != tmpvar_110.w) || (tmpvar_110.y != tmpvar_110.w))) {\n      tmpvar_112 = tmpvar_110.xyz;\n    } else {\n      lowp float tmpvar_113;\n      if ((tmpvar_111 == 0.0)) {\n        tmpvar_113 = 0.0;\n      } else {\n        tmpvar_113 = ((float(mod (tmpvar_111, 6.0))) + 1.0);\n      };\n      vec3 col_114;\n      lowp float tmpvar_115;\n      tmpvar_115 = floor((floor(tmpvar_113) + 0.5));\n      if ((tmpvar_115 < 0.0)) {\n        col_114 = vec3(9.5, 0.5, 0.5);\n      } else {\n        if ((tmpvar_115 == 0.0)) {\n          col_114 = vec3(0.5, 0.5, 0.5);\n        } else {\n          if ((tmpvar_115 == 1.0)) {\n            col_114 = vec3(1.0, 0.0, 0.0);\n          } else {\n            if ((tmpvar_115 == 2.0)) {\n              col_114 = vec3(0.0, 1.0, 0.0);\n            } else {\n              if ((tmpvar_115 == 3.0)) {\n                col_114 = vec3(0.0, 0.0, 1.0);\n              } else {\n                if ((tmpvar_115 == 4.0)) {\n                  col_114 = vec3(0.0, 1.0, 1.0);\n                } else {\n                  if ((tmpvar_115 == 5.0)) {\n                    col_114 = vec3(0.0, 1.0, 0.0);\n                  } else {\n                    if ((tmpvar_115 == 6.0)) {\n                      col_114 = vec3(1.0, 1.0, 0.0);\n                    } else {\n                      col_114 = vec3(1.0, 1.0, 1.0);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n      tmpvar_112 = col_114;\n    };\n    tmpvar_58.xyz = (tmpvar_58.xyz + (tmpvar_112 * matrixbedtint));\n  };\n  if (!(((\n    ((minActive <= shapepos_5.x) && (shapepos_5.x <= maxActive))\n   && \n    ((minActive <= shapepos_5.y) && (shapepos_5.y <= maxActive))\n  ) && (\n    (shapepos_5.y - shapepos_5.x)\n   < maxBackboneDist)))) {\n    tmpvar_58.xyz = (tmpvar_58.xyz * 0.5);\n    tmpvar_59.z = (tmpvar_59.z * 0.5);\n  };\n  i_57 = 0;\n//  while (true) {\n//    if ((i_57 >= 32)) {\n//      break;\n//    };\nfor (int i_57 = 0; i_57 < 32; i_57++) {\n    if (!(((\n      ((((\n        (i_57 == 0)\n       || \n        (i_57 == 4)\n      ) || (i_57 == 5)) || (i_57 == 8)) || (i_57 == 12))\n     || \n      (i_57 == 13)\n    ) || (i_57 >= 16)))) {\n//      i_57++;\n      continue;\n    };\n    lowp float tmpvar_116;\n    if ((i_57 == 16)) {\n      tmpvar_116 = userPicks[0];\n    } else {\n      if ((i_57 == 17)) {\n        tmpvar_116 = userPicks[1];\n      } else {\n        if ((i_57 == 18)) {\n          tmpvar_116 = userPicks[2];\n        } else {\n          if ((i_57 == 19)) {\n            tmpvar_116 = userPicks[3];\n          } else {\n            if ((i_57 == 20)) {\n              tmpvar_116 = userPicks[4];\n            } else {\n              if ((i_57 == 21)) {\n                tmpvar_116 = userPicks[5];\n              } else {\n                if ((i_57 == 22)) {\n                  tmpvar_116 = userPicks[6];\n                } else {\n                  if ((i_57 == 23)) {\n                    tmpvar_116 = userPicks[7];\n                  } else {\n                    if ((i_57 == 24)) {\n                      tmpvar_116 = userPicks[8];\n                    } else {\n                      if ((i_57 == 25)) {\n                        tmpvar_116 = userPicks[9];\n                      } else {\n                        if ((i_57 == 26)) {\n                          tmpvar_116 = userPicks[10];\n                        } else {\n                          if ((i_57 == 27)) {\n                            tmpvar_116 = userPicks[11];\n                          } else {\n                            if ((i_57 == 28)) {\n                              tmpvar_116 = userPicks[12];\n                            } else {\n                              if ((i_57 == 29)) {\n                                tmpvar_116 = userPicks[13];\n                              } else {\n                                if ((i_57 == 30)) {\n                                  tmpvar_116 = userPicks[14];\n                                } else {\n                                  if ((i_57 == 31)) {\n                                    tmpvar_116 = userPicks[15];\n                                  } else {\n                                    float tmpvar_117;\n                                    tmpvar_117 = (float(i_57) / 4.0);\n                                    float tmpvar_118;\n                                    tmpvar_118 = floor(tmpvar_117);\n                                    vec2 tmpvar_119;\n                                    tmpvar_119.y = 0.5;\n                                    tmpvar_119.x = (tmpvar_118 / 4.0);\n                                    lowp vec4 tmpvar_120;\n                                    tmpvar_120 = texture2D (pickrt, tmpvar_119);\n                                    highp int tmpvar_121;\n                                    tmpvar_121 = int(floor((\n                                      (tmpvar_117 - tmpvar_118)\n                                     * 4.0)));\n                                    lowp float tmpvar_122;\n                                    if ((tmpvar_121 == 0)) {\n                                      tmpvar_122 = tmpvar_120.x;\n                                    } else {\n                                      lowp float tmpvar_123;\n                                      if ((tmpvar_121 == 1)) {\n                                        tmpvar_123 = tmpvar_120.y;\n                                      } else {\n                                        lowp float tmpvar_124;\n                                        if ((tmpvar_121 == 2)) {\n                                          tmpvar_124 = tmpvar_120.z;\n                                        } else {\n                                          lowp float tmpvar_125;\n                                          if ((tmpvar_121 == 3)) {\n                                            tmpvar_125 = tmpvar_120.w;\n                                          } else {\n                                            tmpvar_125 = 999.0;\n                                          };\n                                          tmpvar_124 = tmpvar_125;\n                                        };\n                                        tmpvar_123 = tmpvar_124;\n                                      };\n                                      tmpvar_122 = tmpvar_123;\n                                    };\n                                    tmpvar_116 = tmpvar_122;\n                                  };\n                                };\n                              };\n                            };\n                          };\n                        };\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n    highp vec2 P_126;\n    P_126 = (gl_FragCoord.xy * screen);\n    lowp float tmpvar_127;\n    tmpvar_127 = abs((texture2D (rtopos, P_126).x - tmpvar_116));\n    bool tmpvar_128;\n    if ((tmpvar_127 < 0.001)) {\n      tmpvar_128 = bool(1);\n    } else {\n      highp vec2 P_129;\n      P_129 = (gl_FragCoord.xy * screen);\n      tmpvar_128 = (abs((texture2D (rtopos, P_129).y - tmpvar_116)) < 0.001);\n    };\n    if (tmpvar_128) {\n      vec3 tmpvar_130;\n      if ((i_57 < 8)) {\n        tmpvar_130 = vec3(1.0, 0.0, 0.0);\n      } else {\n        if ((i_57 < 16)) {\n          tmpvar_130 = vec3(0.0, 1.0, 0.0);\n        } else {\n          if ((i_57 == 16)) {\n            tmpvar_130 = vec3(0.0, 1.0, 1.0);\n          } else {\n            if ((i_57 == 17)) {\n              tmpvar_130 = vec3(1.0, 0.0, 1.0);\n            } else {\n              if ((i_57 == 18)) {\n                tmpvar_130 = vec3(1.0, 1.0, 0.0);\n              } else {\n                if ((i_57 == 19)) {\n                  tmpvar_130 = vec3(1.0, 1.0, 1.0);\n                } else {\n                  if ((i_57 == 20)) {\n                    tmpvar_130 = vec3(0.5, 1.0, 1.0);\n                  } else {\n                    if ((i_57 == 21)) {\n                      tmpvar_130 = vec3(1.0, 0.5, 1.0);\n                    } else {\n                      if ((i_57 == 22)) {\n                        tmpvar_130 = vec3(1.0, 1.0, 0.5);\n                      } else {\n                        if ((i_57 == 23)) {\n                          tmpvar_130 = vec3(1.0, 1.0, 1.0);\n                        } else {\n                          tmpvar_130 = vec3(1.0, 1.0, 1.0);\n                        };\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n      tmpvar_58.xyz = (tmpvar_58.xyz + tmpvar_130);\n      vec4 tmpvar_131;\n      tmpvar_131.xy = tmpvar_130.zy;\n      tmpvar_131.zw = vec2(-1.0, 0.6666667);\n      vec4 tmpvar_132;\n      tmpvar_132.xy = tmpvar_130.yz;\n      tmpvar_132.zw = vec2(0.0, -0.3333333);\n      vec4 tmpvar_133;\n      tmpvar_133 = mix (tmpvar_131, tmpvar_132, float((tmpvar_130.y >= tmpvar_130.z)));\n      vec4 tmpvar_134;\n      tmpvar_134.xyz = tmpvar_133.xyw;\n      tmpvar_134.w = tmpvar_130.x;\n      vec4 tmpvar_135;\n      tmpvar_135.x = tmpvar_130.x;\n      tmpvar_135.yzw = tmpvar_133.yzx;\n      vec4 tmpvar_136;\n      tmpvar_136 = mix (tmpvar_134, tmpvar_135, float((tmpvar_130.x >= tmpvar_133.x)));\n      float tmpvar_137;\n      tmpvar_137 = (tmpvar_136.x - min (tmpvar_136.w, tmpvar_136.y));\n      lowp vec3 tmpvar_138;\n      tmpvar_138.x = abs((tmpvar_136.z + (\n        (tmpvar_136.w - tmpvar_136.y)\n       / \n        ((6.0 * tmpvar_137) + 1e-10)\n      )));\n      tmpvar_138.y = (tmpvar_137 / (tmpvar_136.x + 1e-10));\n      tmpvar_138.z = tmpvar_136.x;\n      tmpvar_59.xyz = tmpvar_138;\n    };\n//    i_57++;\n  };\n  vec3 tmpvar_139;\n  bool tmpvar_140;\n  lowp vec3 tmpvar_141;\n  tmpvar_141 = normalize(tmpvar_55);\n  lowp vec3 tmpvar_142;\n  tmpvar_142 = normalize(mmnormal_48);\n  tmpvar_140 = (light0dirx >= 490.0);\n  vec3 tmpvar_143;\n  tmpvar_143.x = light0dirx;\n  tmpvar_143.y = light0diry;\n  tmpvar_143.z = light0dirz;\n  vec3 tmpvar_144;\n  tmpvar_144 = normalize(tmpvar_143);\n  vec3 tmpvar_145;\n  tmpvar_145.x = light0x;\n  tmpvar_145.y = light0y;\n  tmpvar_145.z = light0z;\n  vec3 tmpvar_146;\n  tmpvar_146.x = light0r;\n  tmpvar_146.y = light0g;\n  tmpvar_146.z = light0b;\n  tmpvar_139 = (vec3(0.6, 0.6, 0.6) * tmpvar_146);\n  lowp vec3 tmpvar_147;\n  vec3 tmpvar_148;\n  tmpvar_148 = tmpvar_139;\n  lowp float normdotlight_149;\n  lowp float lightfall_150;\n  lowp vec3 point2light_151;\n  if (tmpvar_140) {\n    point2light_151 = normalize(tmpvar_145);\n    lightfall_150 = 1.0;\n  } else {\n    lowp float dist_152;\n    lowp vec3 tmpvar_153;\n    tmpvar_153 = normalize((tmpvar_145 - tmpvar_37.xyz));\n    point2light_151 = tmpvar_153;\n    lowp vec3 x_154;\n    x_154 = (tmpvar_37.xyz - tmpvar_145);\n    dist_152 = (sqrt(dot (x_154, x_154)) / light0HalfDist);\n    lightfall_150 = (max (0.0, (\n      ((-(dot (tmpvar_153, tmpvar_144)) + light0Spread) - 1.0)\n     / light0Spread)) * (1.0/((1.0 + \n      (dist_152 * dist_152)\n    ))));\n  };\n  lowp float tmpvar_155;\n  tmpvar_155 = dot (point2light_151, tmpvar_142);\n  normdotlight_149 = tmpvar_155;\n  if ((tmpvar_155 < 0.0)) {\n    normdotlight_149 = -(tmpvar_155);\n    point2light_151 = -(point2light_151);\n    tmpvar_148 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_156;\n  lowp float fresnel_157;\n  lowp vec3 V_158;\n  V_158.xy = tmpvar_141.xy;\n  V_158.z = (tmpvar_141.z + 0.0001);\n  lowp vec3 tmpvar_159;\n  tmpvar_159 = normalize((point2light_151 + V_158));\n  lowp float tmpvar_160;\n  tmpvar_160 = dot (tmpvar_142, tmpvar_159);\n  lowp float tmpvar_161;\n  tmpvar_161 = dot (V_158, tmpvar_159);\n  lowp float tmpvar_162;\n  tmpvar_162 = dot (tmpvar_142, V_158);\n  lowp float tmpvar_163;\n  tmpvar_163 = (tmpvar_160 * tmpvar_160);\n  float tmpvar_164;\n  tmpvar_164 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_165;\n  tmpvar_165 = (tmpvar_164 * tmpvar_164);\n  fresnel_157 = (pow (max (0.0, \n    (1.0 - tmpvar_161)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_157 = (fresnel_157 + fresnel0);\n  specular_156 = (((fresnel_157 * \n    ((1.0/(((4.0 * tmpvar_165) * (tmpvar_163 * tmpvar_163)))) * exp(((tmpvar_163 - 1.0) / (tmpvar_165 * tmpvar_163))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_160) * tmpvar_162) / tmpvar_161), (((2.0 * tmpvar_160) * clamp (\n      dot (tmpvar_142, point2light_151)\n    , 0.0, 1.0)) / tmpvar_161))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_162));\n  if (!(((0.0 <= specular_156) && (specular_156 <= 1e+20)))) {\n    specular_156 = 0.0;\n  };\n  tmpvar_147 = (((\n    (normdotlight_149 * tmpvar_58.xyz)\n   * \n    (tmpvar_148 * lightfall_150)\n  ) * (1.0 - ambient)) * light0s);\n  tmpvar_140 = (light1dirx >= 490.0);\n  vec3 tmpvar_166;\n  tmpvar_166.x = light1dirx;\n  tmpvar_166.y = light1diry;\n  tmpvar_166.z = light1dirz;\n  vec3 tmpvar_167;\n  tmpvar_167 = normalize(tmpvar_166);\n  vec3 tmpvar_168;\n  tmpvar_168.x = light1x;\n  tmpvar_168.y = light1y;\n  tmpvar_168.z = light1z;\n  vec3 tmpvar_169;\n  tmpvar_169.x = light1r;\n  tmpvar_169.y = light1g;\n  tmpvar_169.z = light1b;\n  tmpvar_139 = (vec3(0.6, 0.6, 0.6) * tmpvar_169);\n  lowp vec3 tmpvar_170;\n  vec3 tmpvar_171;\n  tmpvar_171 = tmpvar_139;\n  lowp float normdotlight_172;\n  lowp float lightfall_173;\n  lowp vec3 point2light_174;\n  if (tmpvar_140) {\n    point2light_174 = normalize(tmpvar_168);\n    lightfall_173 = 1.0;\n  } else {\n    lowp float dist_175;\n    lowp vec3 tmpvar_176;\n    tmpvar_176 = normalize((tmpvar_168 - tmpvar_37.xyz));\n    point2light_174 = tmpvar_176;\n    lowp vec3 x_177;\n    x_177 = (tmpvar_37.xyz - tmpvar_168);\n    dist_175 = (sqrt(dot (x_177, x_177)) / light1HalfDist);\n    lightfall_173 = (max (0.0, (\n      ((-(dot (tmpvar_176, tmpvar_167)) + light1Spread) - 1.0)\n     / light1Spread)) * (1.0/((1.0 + \n      (dist_175 * dist_175)\n    ))));\n  };\n  lowp float tmpvar_178;\n  tmpvar_178 = dot (point2light_174, tmpvar_142);\n  normdotlight_172 = tmpvar_178;\n  if ((tmpvar_178 < 0.0)) {\n    normdotlight_172 = -(tmpvar_178);\n    point2light_174 = -(point2light_174);\n    tmpvar_171 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_179;\n  lowp float fresnel_180;\n  lowp vec3 V_181;\n  V_181.xy = tmpvar_141.xy;\n  V_181.z = (tmpvar_141.z + 0.0001);\n  lowp vec3 tmpvar_182;\n  tmpvar_182 = normalize((point2light_174 + V_181));\n  lowp float tmpvar_183;\n  tmpvar_183 = dot (tmpvar_142, tmpvar_182);\n  lowp float tmpvar_184;\n  tmpvar_184 = dot (V_181, tmpvar_182);\n  lowp float tmpvar_185;\n  tmpvar_185 = dot (tmpvar_142, V_181);\n  lowp float tmpvar_186;\n  tmpvar_186 = (tmpvar_183 * tmpvar_183);\n  float tmpvar_187;\n  tmpvar_187 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_188;\n  tmpvar_188 = (tmpvar_187 * tmpvar_187);\n  fresnel_180 = (pow (max (0.0, \n    (1.0 - tmpvar_184)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_180 = (fresnel_180 + fresnel0);\n  specular_179 = (((fresnel_180 * \n    ((1.0/(((4.0 * tmpvar_188) * (tmpvar_186 * tmpvar_186)))) * exp(((tmpvar_186 - 1.0) / (tmpvar_188 * tmpvar_186))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_183) * tmpvar_185) / tmpvar_184), (((2.0 * tmpvar_183) * clamp (\n      dot (tmpvar_142, point2light_174)\n    , 0.0, 1.0)) / tmpvar_184))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_185));\n  if (!(((0.0 <= specular_179) && (specular_179 <= 1e+20)))) {\n    specular_179 = 0.0;\n  };\n  tmpvar_170 = (((\n    (normdotlight_172 * tmpvar_58.xyz)\n   * \n    (tmpvar_171 * lightfall_173)\n  ) * (1.0 - ambient)) * light1s);\n  tmpvar_140 = (light2dirx >= 490.0);\n  vec3 tmpvar_189;\n  tmpvar_189.x = light2dirx;\n  tmpvar_189.y = light2diry;\n  tmpvar_189.z = light2dirz;\n  vec3 tmpvar_190;\n  tmpvar_190 = normalize(tmpvar_189);\n  vec3 tmpvar_191;\n  tmpvar_191.x = light2x;\n  tmpvar_191.y = light2y;\n  tmpvar_191.z = light2z;\n  vec3 tmpvar_192;\n  tmpvar_192.x = light2r;\n  tmpvar_192.y = light2g;\n  tmpvar_192.z = light2b;\n  tmpvar_139 = (vec3(0.6, 0.6, 0.6) * tmpvar_192);\n  vec3 tmpvar_193;\n  tmpvar_193 = tmpvar_139;\n  lowp float normdotlight_194;\n  lowp float lightfall_195;\n  lowp vec3 point2light_196;\n  if (tmpvar_140) {\n    point2light_196 = normalize(tmpvar_191);\n    lightfall_195 = 1.0;\n  } else {\n    lowp float dist_197;\n    lowp vec3 tmpvar_198;\n    tmpvar_198 = normalize((tmpvar_191 - tmpvar_37.xyz));\n    point2light_196 = tmpvar_198;\n    lowp vec3 x_199;\n    x_199 = (tmpvar_37.xyz - tmpvar_191);\n    dist_197 = (sqrt(dot (x_199, x_199)) / light2HalfDist);\n    lightfall_195 = (max (0.0, (\n      ((-(dot (tmpvar_198, tmpvar_190)) + light2Spread) - 1.0)\n     / light2Spread)) * (1.0/((1.0 + \n      (dist_197 * dist_197)\n    ))));\n  };\n  lowp float tmpvar_200;\n  tmpvar_200 = dot (point2light_196, tmpvar_142);\n  normdotlight_194 = tmpvar_200;\n  if ((tmpvar_200 < 0.0)) {\n    normdotlight_194 = -(tmpvar_200);\n    point2light_196 = -(point2light_196);\n    tmpvar_193 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_201;\n  lowp float fresnel_202;\n  lowp vec3 V_203;\n  V_203.xy = tmpvar_141.xy;\n  V_203.z = (tmpvar_141.z + 0.0001);\n  lowp vec3 tmpvar_204;\n  tmpvar_204 = normalize((point2light_196 + V_203));\n  lowp float tmpvar_205;\n  tmpvar_205 = dot (tmpvar_142, tmpvar_204);\n  lowp float tmpvar_206;\n  tmpvar_206 = dot (V_203, tmpvar_204);\n  lowp float tmpvar_207;\n  tmpvar_207 = dot (tmpvar_142, V_203);\n  lowp float tmpvar_208;\n  tmpvar_208 = (tmpvar_205 * tmpvar_205);\n  float tmpvar_209;\n  tmpvar_209 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_210;\n  tmpvar_210 = (tmpvar_209 * tmpvar_209);\n  fresnel_202 = (pow (max (0.0, \n    (1.0 - tmpvar_206)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_202 = (fresnel_202 + fresnel0);\n  specular_201 = (((fresnel_202 * \n    ((1.0/(((4.0 * tmpvar_210) * (tmpvar_208 * tmpvar_208)))) * exp(((tmpvar_208 - 1.0) / (tmpvar_210 * tmpvar_208))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_205) * tmpvar_207) / tmpvar_206), (((2.0 * tmpvar_205) * clamp (\n      dot (tmpvar_142, point2light_196)\n    , 0.0, 1.0)) / tmpvar_206))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_207));\n  if (!(((0.0 <= specular_201) && (specular_201 <= 1e+20)))) {\n    specular_201 = 0.0;\n  };\n  lowp vec4 tmpvar_211;\n  tmpvar_211.w = 1.0;\n  tmpvar_211.xyz = (((tmpvar_147 + tmpvar_170) + (\n    (((normdotlight_194 * tmpvar_58.xyz) * (tmpvar_193 * lightfall_195)) * (1.0 - ambient))\n   * light2s)) + (ambient * tmpvar_58.xyz));\n  col_47.xyz = tmpvar_211.xyz;\n  col_47.w = 1.0;\n  res_46 = col_47;\n  lowp vec2 tmpvar_212;\n  tmpvar_212.x = 0.96875;\n  tmpvar_212.y = ((colourid + 0.5) / 32.0);\n  lowp vec4 tmpvar_213;\n  tmpvar_213 = texture2D (colbuff, tmpvar_212);\n  if ((tmpvar_213.z != 0.0)) {\n    lowp vec2 tmpvar_214;\n    tmpvar_214.x = 0.96875;\n    tmpvar_214.y = ((colourid + 0.5) / 32.0);\n    lowp vec4 tmpvar_215;\n    tmpvar_215 = texture2D (colbuff, tmpvar_214);\n    if ((tmpvar_215.z < 0.0)) {\n      res_46.xyz = (tmpvar_211.xyz + clamp ((tmpvar_59.z * \n        mix (vec3(1.0, 1.0, 1.0), clamp ((abs(\n          ((fract((tmpvar_59.xxx + vec3(1.0, 0.6666667, 0.3333333))) * 6.0) - vec3(3.0, 3.0, 3.0))\n        ) - vec3(1.0, 1.0, 1.0)), 0.0, 1.0), tmpvar_59.y)\n      ), 0.0, 1.0));\n    } else {\n      lowp vec2 tmpvar_216;\n      tmpvar_216.x = 0.96875;\n      tmpvar_216.y = ((colourid + 0.5) / 32.0);\n      lowp vec2 tmpvar_217;\n      tmpvar_217.x = 0.21875;\n      tmpvar_217.y = ((colourid + 0.5) / 32.0);\n      lowp float tmpvar_218;\n      tmpvar_218 = (texture2D (colbuff, tmpvar_216).z / texture2D (colbuff, tmpvar_217).w);\n      lowp float tmpvar_219;\n      tmpvar_219 = (flulow + tmpvar_218);\n      lowp vec4 tmpvar_220;\n      highp vec2 P_221;\n      P_221 = (gl_FragCoord.xy * screen);\n      tmpvar_220 = texture2D (rttexture, P_221);\n      lowp vec4 tmpvar_222;\n      highp vec2 P_223;\n      P_223 = ((gl_FragCoord.xy + vec2(0.0, 1.0)) * screen);\n      tmpvar_222 = texture2D (rttexture, P_223);\n      lowp vec4 tmpvar_224;\n      highp vec2 P_225;\n      P_225 = ((gl_FragCoord.xy + vec2(1.0, 0.0)) * screen);\n      tmpvar_224 = texture2D (rttexture, P_225);\n      lowp vec4 tmpvar_226;\n      highp vec2 P_227;\n      P_227 = ((gl_FragCoord.xy + vec2(1.0, 1.0)) * screen);\n      tmpvar_226 = texture2D (rttexture, P_227);\n      if (!(((\n        (tmpvar_220.w != tmpvar_222.w)\n       || \n        (tmpvar_220.w != tmpvar_224.w)\n      ) || (tmpvar_220.w != tmpvar_226.w)))) {\n        lowp float tmpvar_228;\n        tmpvar_228 = min (min (tmpvar_220.x, tmpvar_222.x), min (tmpvar_224.x, tmpvar_226.x));\n        lowp float tmpvar_229;\n        tmpvar_229 = max (max (tmpvar_220.x, tmpvar_222.x), max (tmpvar_224.x, tmpvar_226.x));\n        if (!(((tmpvar_228 > tmpvar_219) || (tmpvar_229 < flulow)))) {\n          lowp float tmpvar_230;\n          tmpvar_230 = max (tmpvar_228, flulow);\n          lowp float tmpvar_231;\n          tmpvar_231 = min (tmpvar_229, tmpvar_219);\n          lowp float tmpvar_232;\n          if ((tmpvar_229 == tmpvar_228)) {\n            tmpvar_232 = 1.0;\n          } else {\n            tmpvar_232 = ((tmpvar_231 - tmpvar_230) / (tmpvar_229 - tmpvar_228));\n          };\n          res_46.xyz = (res_46.xyz + (clamp (\n            (tmpvar_59.z * mix (vec3(1.0, 1.0, 1.0), clamp ((\n              abs(((fract(\n                (tmpvar_59.xxx + vec3(1.0, 0.6666667, 0.3333333))\n              ) * 6.0) - vec3(3.0, 3.0, 3.0)))\n             - vec3(1.0, 1.0, 1.0)), 0.0, 1.0), tmpvar_59.y))\n          , 0.0, 1.0) * (tmpvar_232 * \n            ((((tmpvar_230 - flulow) / tmpvar_218) + ((tmpvar_231 - flulow) / tmpvar_218)) * 0.5)\n          )));\n        };\n      };\n    };\n  };\n  if ((foghalfdepth != 0.0)) {\n    vec3 tmpvar_233;\n    tmpvar_233.x = fogr;\n    tmpvar_233.y = fogg;\n    tmpvar_233.z = fogb;\n    res_46.xyz = mix (tmpvar_233, res_46.xyz, pow (0.5, (\n      max (0.0, (tmpvar_53 - fogstartdist))\n     / foghalfdepth)));\n  };\n  res_46.xyz = (res_46 + postxcol).xyz;\n  res_46.w = opacity;\n  lowp vec4 tmpvar_234;\n  tmpvar_234.w = 1.0;\n  tmpvar_234.xyz = ((xmnormal_4 + 1.0) * 0.5);\n  lowp vec4 tmpvar_235;\n  tmpvar_235.w = 1.0;\n  tmpvar_235.xyz = ((shapepos_5.xyz + 300.0) / 600.0);\n  lowp vec4 tmpvar_236;\n  tmpvar_236 = (((res_46 * \n    ((1.0 - xxposprop) - xxnormprop)\n  ) + (tmpvar_234 * xxnormprop)) + (tmpvar_235 * xxposprop));\n  tmpvar_38 = tmpvar_236;\n  gl_FragColor = tmpvar_38;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"},"matrix\n    override vec4 tr(const vec4 lopos, out vec3 xmnormal, out vec3 texpos, out float ribnum){\n        pickopos(lopos);\n        vec4 p = lopos;\n        float numInstances = numSegs + 1.;\n        vec3 p1 = histpos((p.x * numInstances + 0.5)/numInstancesP2).xyz;\n        vec3 p2 = histpos((p.y * numInstances + 0.5)/numInstancesP2).xyz;\n        float dist = length(p2 - p1);\n        float d10300 = clamp(map(dist, matMinD, matMaxD, 10., 300.), 10., 300.);// + 0.5;\n        //float id = 1./max(d, 10.);\n        float id = 1./d10300;\n        if (p.x - p.y > (-matskipdiag - 2.)/numSegs) id = 0.;\n\n        #define in(x,l,h) (l <= x && x <= h)\n        if (!(in(p.x, minActive, maxActive) && in(p.y, minActive, maxActive)))\n            id = 0.;\n\n\n        float hd = id; //heightFactor * tanh(id * heightFactor2) / tanh(heightFactor2);\n        p.z = matMaxD == 0. ? 0. : hd;\n        p.x += matX;\n        p.y += matY;\n        p.z += matZ;\n        //p.z = min(0.1, 1./d);\n        //p.xyz *= 8000.;\n        return p;\n    }\n\n    override Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n// #define bimix(a00, a01, a10, a11, x,y) mix( mix(a00,a01, x), mix(a10, a11, x), y)\n        if (texpos.x - texpos.y > -matskipdiag / numSegs) discard;\n        Colsurf c = colsurfd();\n        // float a = clamp(texpos.z/heightFactor, 0., 1.);\n        // a = 0.5 + atan(((2.*a)-1.)*matColCurve) / (2.*atan(matColCurve));\n\n        // recompute distance, info passed in texpos.z not reliable\n        // we should only need to do this where dist is actually used.\n        float numInstances = numSegs + 1.;\n        vec3 pp = round(texpos * numSegs);  // we force lookup of precise position even if posVewVals is using LinearFilter\n        vec3 p1 = histpos((pp.x + 0.5)/numInstancesP2).xyz;\n        vec3 p2 = histpos((pp.y + 0.5)/numInstancesP2).xyz;\n        float dist = length(p2 - p1);\n\n        //''if (texpos.x - texpos.y > (-matskipdiag - 2.)/numSegs) distForCol = 0.;\n\n        //TODO: more structured colour genes\n        //##vec3 col1 = vec3(matcoldr, matcoldg, matcoldb);\n        //##vec3 col2 = vec3(mathotr, mathotg, mathotb);\n        vec3 col1 = vec3(matC00r, matC00g, matC00b);\n        vec3 col2 = vec3(matC11r, matC11g, matC11b);\n    //''c.col.rgb = mix(col1, col2, distForCol);\n        //''c.fluoresc.rgb = rgb2hsv(c.col.rgb);\n\n\n        vec2 tp = (texpos.xy * numSegs + 0.5) / numInstances;\n        float v1 = clamp( nval(matintypeA, matrix2dtexA, tp, dist, matDistNear, matDistFar), 0., 1.);\n        if (matintypeA + matintypeB == 0.) {    // old code\n        } else if (matcoltypeA == matcoltypeB) {\n             c.col.rgb = mix(col1, col2, v1);\n        } else {\n            float v2 = clamp(nval(matintypeB, matrix2dtexB, tp, dist, matDistNear, matDistFar), 0., 1.);\n            /**\n            c.col.rgb = bimix(\n                vec3(matC00r, matC00g, matC00b),\n                vec3(matC01r, matC01g, matC01b),\n                vec3(matC10r, matC10g, matC10b),\n                vec3(matC11r, matC11g, matC11b),\n                clamp(v1, 0., 1.), clamp(v2, 0., 1.));\n            **/\n           // cent is the color down the diagonal\n           // tint is the colour at the off-diagonal corner\n           // overall colour uses amount off-diagonal\n            vec3 cent = mix(vec3(matC00r, matC00g, matC00b), vec3(matC11r, matC11g, matC11b), max(v1, v2));\n\n            vec3 tint = v1 > v2 ? vec3(matC10r, matC10g, matC10b) : vec3(matC01r, matC01g, matC01b);\n            c.col.rgb = mix(cent, tint, clamp(matrixTintStrength*abs(v1-v2), 0.,1.));\n        }\n        c.col.rgb = pow(c.col.rgb, vec3(matgamma));  // better perceptual range\n        c.fluoresc.rgb = rgb2hsv(c.col.rgb);\n\n\n        //TODO uniforms for gridline presentation parameters.\n        //Also need to do something about aliasing. Could consider non-binary logic here.\n        if (matrixgridres != 0.) {\n            float dx = abs(fract(texpos.x*numInstances/matrixgridres));\n            float dy = abs(fract(texpos.y*numInstances/matrixgridres));\n            //dx=dy=1.;  // remove comment to remove the grid bands\n\n            float solidW = matrixgridwidth;\n            float softW = matrixgridsoftw;\n            float softR = 1./softW;\n            float fx = 1. - (clamp(dx - solidW, 0., softW) * softR);\n            float fy = 1. - (clamp(dy - solidW, 0., softW) * softR);\n            float f = min(fx+fy, 1.);\n            c.col.rgb += vec3(0,0.7,0.7) * f;\n            //TODO: think better about how to combine with existing hsv...\n            if (f > 0.) {\n                c.fluoresc.rgb = vec3(0.5, 1., 0.1 * f);\n            }\n        }\n\n        vec2 mtp = texpos.xy;  // texture position for looking up bed.  ? texpos ?\n        if (matrixbedtint != 0.) {\n            vec4 bed = texture2D(matrixbed, vec2(mtp.x, 0.5));\n            float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n            float ti = t * 255. - 0.0;\n            // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n            // but close enough for now (famous last words), closer with test against green as well\n            vec3 bedrgb = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n            c.col.rgb += bedrgb * matrixbedtint;\n\n            // TODO factor bed colour option and use for x and y (and ribbon)\n            vec4 bedy = texture2D(matrixbed, vec2(mtp.y, 0.5));\n            float ty = bedy.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n            float tiy = ty * 255. - 0.0;\n            vec3 bedrgby = bedy.r != ty || bedy.g != ty ? bedy.rgb : stdcol(floor(tiy == 0. ? 0. : (mod(tiy, 6.) + 1.)));\n            c.col.rgb += bedrgby * matrixbedtint;\n        }\n\n\n        // darker for region outside active particles/springs\n#define in(x,l,h) (l <= x && x <= h)\n        if (!(in(texpos.x, minActive, maxActive) && in(texpos.y, minActive, maxActive)\n            && (texpos.y - texpos.x < maxBackboneDist))) {\n            c.col.rgb *= 0.5;\n            c.fluoresc.b *= 0.5;\n        }\n\n//;#if OPMODE != OPPICK  // minor optimization\n        // get Pick for all elements of interest.\n        for (int i=0; i<32; i++) {\n            //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n            if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 || i >= 16 ) ) continue;\n            float p = getPickC(i);\n            if (abs(opos.x-p) < 0.001 || abs(opos.y-p) < 0.001) {\n                vec3 pcol = getPickColor(i);\n                c.col.rgb += pcol;\n                vec3 pcolHSV = rgb2hsv(pcol);\n                c.fluoresc.rgb = pcolHSV.rgb;\n            }\n        }\n//;#endif\n        c.surftype.y = 0.;  // prevent default gloss causing confusion. shininess1gloss1subband1plastic1\n        return c;\n    }\n    ":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nuniform sampler2D matrixbed;\nuniform float matskipdiag;\nuniform float matC00r;\nuniform float matC00g;\nuniform float matC00b;\nuniform float matC01r;\nuniform float matC01g;\nuniform float matC01b;\nuniform float matC10r;\nuniform float matC10g;\nuniform float matC10b;\nuniform float matC11r;\nuniform float matC11g;\nuniform float matC11b;\nuniform float matDistFar;\nuniform float matDistNear;\nuniform float matrixbedtint;\nuniform float matrixgridres;\nuniform float matrixgridwidth;\nuniform float matrixgridsoftw;\nuniform float matrixcontactmin;\nuniform float matrixcontactmult;\nuniform float matgamma;\nuniform sampler2D matrix2dtexA;\nuniform sampler2D matrix2dtexB;\nuniform float matintypeA;\nuniform float matintypeB;\nuniform float matcoltypeA;\nuniform float matcoltypeB;\nuniform float matrixTintStrength;\nuniform float minActive;\nuniform float maxActive;\nuniform float maxBackboneDist;\nuniform float nonBackboneLen;\nuniform float representativeContact;\nuniform float m_k;\nuniform float m_alpha;\nuniform float pushapartforce;\nuniform float pushapartpow;\nuniform float contactforcesc;\nuniform float powBaseDist;\nuniform sampler2D rtopos;\nuniform sampler2D rtshapepos;\nuniform sampler2D colbuff;\nuniform sampler2D pickrt;\nuniform float multifact;\nuniform float multiquatfact;\nuniform float latenormals;\nuniform float latenormalsred;\nuniform float cutx;\nuniform float cuty;\nuniform vec2 screen;\nuniform mat4 rot4;\nlowp float colourid;\nuniform float userPicks[16];\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nlowp float xhornid;\nuniform sampler2D rttexture;\nuniform vec3 cameraPositionModel;\nuniform float ymin;\nuniform float ymax;\nvec4 postxcol;\nuniform float flulow;\nuniform float opacity;\nuniform float badnormals;\nuniform float colribs;\nuniform float fogr;\nuniform float fogg;\nuniform float fogb;\nuniform float fogstartdist;\nuniform float foghalfdepth;\nuniform float xxposprop;\nuniform float xxnormprop;\nuniform float ambient;\nuniform float light0s;\nuniform float light1s;\nuniform float light2s;\nuniform float light0r;\nuniform float light0g;\nuniform float light0b;\nuniform float light1r;\nuniform float light1g;\nuniform float light1b;\nuniform float light2r;\nuniform float light2g;\nuniform float light2b;\nuniform float light0x;\nuniform float light0y;\nuniform float light0z;\nuniform float light1x;\nuniform float light1y;\nuniform float light1z;\nuniform float light2x;\nuniform float light2y;\nuniform float light2z;\nuniform float light0dirx;\nuniform float light0diry;\nuniform float light0dirz;\nuniform float light1dirx;\nuniform float light1diry;\nuniform float light1dirz;\nuniform float light2dirx;\nuniform float light2diry;\nuniform float light2dirz;\nuniform float light0Spread;\nuniform float light1Spread;\nuniform float light2Spread;\nuniform float light0HalfDist;\nuniform float light1HalfDist;\nuniform float light2HalfDist;\nuniform float fresnel0;\nvoid main ()\n{\n  postxcol = vec4(0.0, 0.0, 0.0, 0.0);\n  lowp vec3 texpos_1;\n  vec2 tmpvar_2;\n  tmpvar_2.x = cutx;\n  tmpvar_2.y = cuty;\n  highp vec2 tmpvar_3;\n  tmpvar_3 = (((gl_FragCoord.xy * screen) - 0.5) * tmpvar_2);\n  if ((((tmpvar_3.x * tmpvar_3.x) + (tmpvar_3.y * tmpvar_3.y)) > 1.0)) {\n    discard;\n  };\n  colourid = xhornid;\n  lowp vec3 xmnormal_4;\n  lowp vec4 shapepos_5;\n  lowp vec4 tmpvar_6;\n  highp vec2 P_7;\n  P_7 = (gl_FragCoord.xy * screen);\n  tmpvar_6 = texture2D (rtshapepos, P_7);\n  if ((tmpvar_6.w == 0.0)) {\n    discard;\n  };\n  lowp float tmpvar_8;\n  tmpvar_8 = floor((tmpvar_6.w / 4096.0));\n  if ((latenormals != 0.0)) {\n    lowp vec3 uBb_9;\n    lowp vec3 uBa_10;\n    lowp vec3 uAb_11;\n    lowp vec3 uAa_12;\n    shapepos_5 = tmpvar_6;\n    vec2 tmpvar_13;\n    tmpvar_13.y = 0.0;\n    tmpvar_13.x = latenormals;\n    lowp vec4 tmpvar_14;\n    highp vec2 P_15;\n    P_15 = ((gl_FragCoord.xy + tmpvar_13) * screen);\n    tmpvar_14 = texture2D (rtshapepos, P_15);\n    vec2 tmpvar_16;\n    tmpvar_16.y = 0.0;\n    float tmpvar_17;\n    tmpvar_17 = -(latenormals);\n    tmpvar_16.x = tmpvar_17;\n    lowp vec4 tmpvar_18;\n    highp vec2 P_19;\n    P_19 = ((gl_FragCoord.xy + tmpvar_16) * screen);\n    tmpvar_18 = texture2D (rtshapepos, P_19);\n    vec2 tmpvar_20;\n    tmpvar_20.x = 0.0;\n    tmpvar_20.y = tmpvar_17;\n    lowp vec4 tmpvar_21;\n    highp vec2 P_22;\n    P_22 = ((gl_FragCoord.xy + tmpvar_20) * screen);\n    tmpvar_21 = texture2D (rtshapepos, P_22);\n    vec2 tmpvar_23;\n    tmpvar_23.x = 0.0;\n    tmpvar_23.y = latenormals;\n    lowp vec4 tmpvar_24;\n    highp vec2 P_25;\n    P_25 = ((gl_FragCoord.xy + tmpvar_23) * screen);\n    tmpvar_24 = texture2D (rtshapepos, P_25);\n    if ((tmpvar_14.w == tmpvar_6.w)) {\n      uAa_12 = tmpvar_14.xyz;\n      uAb_11 = tmpvar_6.xyz;\n    } else {\n      if ((tmpvar_18.w == tmpvar_6.w)) {\n        uAa_12 = tmpvar_6.xyz;\n        uAb_11 = tmpvar_18.xyz;\n      } else {\n        lowp vec3 tmpvar_26;\n        if ((floor((tmpvar_6.w / 4096.0)) == floor((tmpvar_14.w / 4096.0)))) {\n          tmpvar_26 = tmpvar_14.xyz;\n        } else {\n          tmpvar_26 = tmpvar_6.xyz;\n        };\n        uAa_12 = tmpvar_26;\n        lowp vec3 tmpvar_27;\n        if ((floor((tmpvar_6.w / 4096.0)) == floor((tmpvar_18.w / 4096.0)))) {\n          tmpvar_27 = tmpvar_18.xyz;\n        } else {\n          tmpvar_27 = tmpvar_6.xyz;\n        };\n        uAb_11 = tmpvar_27;\n      };\n    };\n    if ((tmpvar_21.w == tmpvar_6.w)) {\n      uBa_10 = tmpvar_21.xyz;\n      uBb_9 = tmpvar_6.xyz;\n    } else {\n      if ((tmpvar_18.w == tmpvar_6.w)) {\n        uBa_10 = tmpvar_6.xyz;\n        uBb_9 = tmpvar_24.xyz;\n      } else {\n        lowp vec3 tmpvar_28;\n        if ((floor((tmpvar_6.w / 4096.0)) == floor((tmpvar_21.w / 4096.0)))) {\n          tmpvar_28 = tmpvar_21.xyz;\n        } else {\n          tmpvar_28 = tmpvar_6.xyz;\n        };\n        uBa_10 = tmpvar_28;\n        lowp vec3 tmpvar_29;\n        if ((floor((tmpvar_6.w / 4096.0)) == floor((tmpvar_24.w / 4096.0)))) {\n          tmpvar_29 = tmpvar_24.xyz;\n        } else {\n          tmpvar_29 = tmpvar_6.xyz;\n        };\n        uBb_9 = tmpvar_29;\n      };\n    };\n    lowp vec3 tmpvar_30;\n    lowp vec3 a_31;\n    a_31 = (uBa_10 - uBb_9);\n    lowp vec3 b_32;\n    b_32 = (uAa_12 - uAb_11);\n    tmpvar_30 = ((a_31.yzx * b_32.zxy) - (a_31.zxy * b_32.yzx));\n    lowp float tmpvar_33;\n    tmpvar_33 = sqrt(dot (tmpvar_30, tmpvar_30));\n    if ((tmpvar_33 < 1e-9)) {\n      vec4 tmpvar_34;\n      tmpvar_34.yzw = vec3(0.0, 0.0, 0.0);\n      tmpvar_34.x = latenormalsred;\n      postxcol = tmpvar_34;\n      xmnormal_4 = vec3(0.0, 0.0, 1.09);\n    } else {\n      lowp vec3 tmpvar_35;\n      tmpvar_35 = normalize(tmpvar_30);\n      xmnormal_4.xz = tmpvar_35.xz;\n      xmnormal_4.y = (tmpvar_35.y + 1e-15);\n    };\n  } else {\n    shapepos_5 = (floor(tmpvar_6) / multifact);\n    xmnormal_4 = ((fract(tmpvar_6) / multiquatfact) - 1.0).xyz;\n  };\n  shapepos_5.w = 1.0;\n  colourid = tmpvar_8;\n  xhornid = tmpvar_8;\n  texpos_1 = shapepos_5.xyz;\n  mat4 tmpvar_36;\n  if ((tmpvar_8 == 2.0)) {\n    tmpvar_36 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  } else {\n    tmpvar_36 = rot4;\n  };\n  lowp vec4 tmpvar_37;\n  tmpvar_37 = (shapepos_5 * tmpvar_36);\n  mediump vec4 tmpvar_38;\n  colourid = tmpvar_8;\n  lowp vec2 tmpvar_39;\n  tmpvar_39.x = 0.34375;\n  tmpvar_39.y = ((tmpvar_8 + 0.5) / 32.0);\n  lowp vec4 tmpvar_40;\n  tmpvar_40 = texture2D (colbuff, tmpvar_39);\n  bool tmpvar_41;\n  if ((tmpvar_40.w != 0.0)) {\n    tmpvar_41 = bool(1);\n  } else {\n    lowp vec2 tmpvar_42;\n    tmpvar_42.x = 0.40625;\n    tmpvar_42.y = ((tmpvar_8 + 0.5) / 32.0);\n    tmpvar_41 = (texture2D (colbuff, tmpvar_42).x != 0.0);\n  };\n  bool tmpvar_43;\n  if (tmpvar_41) {\n    tmpvar_43 = bool(1);\n  } else {\n    lowp vec2 tmpvar_44;\n    tmpvar_44.x = 0.40625;\n    tmpvar_44.y = ((tmpvar_8 + 0.5) / 32.0);\n    tmpvar_43 = (texture2D (colbuff, tmpvar_44).y != 0.0);\n  };\n  if ((tmpvar_43 || (colribs != 0.0))) {\n    highp vec2 P_45;\n    P_45 = (gl_FragCoord.xy * screen);\n    colourid = (tmpvar_8 + (colribs * texture2D (rtopos, P_45).z));\n    colourid = (float(mod (colourid, 32.0)));\n  };\n  lowp vec4 res_46;\n  lowp vec4 col_47;\n  lowp vec3 mmnormal_48;\n  lowp vec3 tmpvar_49;\n  tmpvar_49 = normalize(xmnormal_4);\n  if (!(((ymin <= tmpvar_37.y) && (tmpvar_37.y <= ymax)))) {\n    discard;\n  };\n  mat4 tmpvar_50;\n  if ((colourid == 2.0)) {\n    tmpvar_50 = mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  } else {\n    tmpvar_50 = rot4;\n  };\n  mat3 tmpvar_51;\n  tmpvar_51[0] = tmpvar_50[0].xyz;\n  tmpvar_51[1] = tmpvar_50[1].xyz;\n  tmpvar_51[2] = tmpvar_50[2].xyz;\n  lowp vec3 tmpvar_52;\n  tmpvar_52 = (-(tmpvar_49) * tmpvar_51);\n  lowp float tmpvar_53;\n  lowp vec3 x_54;\n  x_54 = (cameraPositionModel - tmpvar_37.xyz);\n  tmpvar_53 = sqrt(dot (x_54, x_54));\n  lowp vec3 tmpvar_55;\n  tmpvar_55 = normalize((cameraPositionModel - tmpvar_37.xyz));\n  mmnormal_48 = -(tmpvar_52);\n  if ((xmnormal_4.z == 1.09)) {\n    mmnormal_48 = -(tmpvar_55);\n  } else {\n    lowp float tmpvar_56;\n    tmpvar_56 = dot (tmpvar_55, mmnormal_48);\n    if ((tmpvar_56 < 0.0)) {\n      if ((badnormals == 0.0)) {\n        postxcol = vec4(1.0, 1.0, 0.0, 1.0);\n      } else {\n        if ((badnormals != 1.0)) {\n          if ((badnormals == 2.0)) {\n            mmnormal_48 = (mmnormal_48 - (tmpvar_56 * tmpvar_55));\n          } else {\n            if ((badnormals < 0.0)) {\n              mmnormal_48 = (mmnormal_48 - ((\n                -(badnormals)\n               * tmpvar_56) * tmpvar_55));\n            } else {\n              if ((badnormals == 3.0)) {\n                mmnormal_48 = tmpvar_52;\n              } else {\n                if ((badnormals == 4.0)) {\n                  if ((tmpvar_56 < -0.2)) {\n                    mmnormal_48 = tmpvar_52;\n                  } else {\n                    mmnormal_48 = (mmnormal_48 - (tmpvar_56 * tmpvar_55));\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  highp int i_57;\n  lowp vec4 tmpvar_58;\n  lowp vec4 tmpvar_59;\n  if (((shapepos_5.x - shapepos_5.y) > (-(matskipdiag) / numSegs))) {\n    discard;\n  };\n  tmpvar_58 = vec4(0.5, 0.5, 0.5, 0.0);\n  tmpvar_59 = vec4(0.0, 0.0, 0.0, 0.0);\n  float tmpvar_60;\n  tmpvar_60 = (numSegs + 1.0);\n  lowp vec3 tmpvar_61;\n  tmpvar_61 = floor(((shapepos_5.xyz * numSegs) + 0.5));\n  lowp vec2 tmpvar_62;\n  tmpvar_62.x = 0.0;\n  tmpvar_62.y = ((tmpvar_61.x + 0.5) / numInstancesP2);\n  lowp vec2 tmpvar_63;\n  tmpvar_63.x = 0.0;\n  tmpvar_63.y = ((tmpvar_61.y + 0.5) / numInstancesP2);\n  lowp float tmpvar_64;\n  lowp vec3 x_65;\n  x_65 = (texture2D (posNewvals, tmpvar_63).xyz - texture2D (posNewvals, tmpvar_62).xyz);\n  tmpvar_64 = sqrt(dot (x_65, x_65));\n  vec3 tmpvar_66;\n  tmpvar_66.x = matC00r;\n  tmpvar_66.y = matC00g;\n  tmpvar_66.z = matC00b;\n  vec3 tmpvar_67;\n  tmpvar_67.x = matC11r;\n  tmpvar_67.y = matC11g;\n  tmpvar_67.z = matC11b;\n  lowp vec2 tmpvar_68;\n  tmpvar_68 = (((shapepos_5.xy * numSegs) + 0.5) / tmpvar_60);\n  lowp float tmpvar_69;\n  if ((matintypeA < 1.5)) {\n    tmpvar_69 = matintypeA;\n  } else {\n    if ((matintypeA < 2.5)) {\n      tmpvar_69 = tmpvar_68.x;\n    } else {\n      if ((matintypeA < 3.5)) {\n        tmpvar_69 = tmpvar_68.y;\n      } else {\n        if ((matintypeA < 4.5)) {\n          lowp float tmpvar_70;\n          tmpvar_70 = clamp (((\n            (tmpvar_64 / nonBackboneLen)\n           - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n          tmpvar_69 = (1.0 - (tmpvar_70 * (tmpvar_70 * \n            (3.0 - (2.0 * tmpvar_70))\n          )));\n        } else {\n          if ((matintypeA < 5.5)) {\n            lowp float tmpvar_71;\n            tmpvar_71 = clamp (((\n              (texture2D (matrix2dtexA, tmpvar_68).x / nonBackboneLen)\n             - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n            tmpvar_69 = (1.0 - (tmpvar_71 * (tmpvar_71 * \n              (3.0 - (2.0 * tmpvar_71))\n            )));\n          } else {\n            if ((matintypeA < 6.5)) {\n              lowp float dist_72;\n              lowp float tmpvar_73;\n              tmpvar_73 = max (0.0, texture2D (matrix2dtexA, tmpvar_68).x);\n              if ((contactforcesc != 0.0)) {\n                dist_72 = pow (((\n                  (tmpvar_73 * contactforcesc)\n                 / pushapartforce) * pow (powBaseDist, pushapartpow)), (1.0/((pushapartpow - 1.0))));\n              } else {\n                dist_72 = (m_k * pow ((tmpvar_73 / representativeContact), -(m_alpha)));\n              };\n              lowp float tmpvar_74;\n              tmpvar_74 = clamp (((dist_72 - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n              tmpvar_69 = (1.0 - (tmpvar_74 * (tmpvar_74 * \n                (3.0 - (2.0 * tmpvar_74))\n              )));\n            } else {\n              tmpvar_69 = ((texture2D (matrix2dtexA, tmpvar_68).x - matrixcontactmin) * matrixcontactmult);\n            };\n          };\n        };\n      };\n    };\n  };\n  lowp float tmpvar_75;\n  tmpvar_75 = clamp (tmpvar_69, 0.0, 1.0);\n  if (((matintypeA + matintypeB) != 0.0)) {\n    if ((matcoltypeA == matcoltypeB)) {\n      tmpvar_58.xyz = mix (tmpvar_66, tmpvar_67, tmpvar_75);\n    } else {\n      lowp float tmpvar_76;\n      if ((matintypeB < 1.5)) {\n        tmpvar_76 = matintypeB;\n      } else {\n        if ((matintypeB < 2.5)) {\n          tmpvar_76 = tmpvar_68.x;\n        } else {\n          if ((matintypeB < 3.5)) {\n            tmpvar_76 = tmpvar_68.y;\n          } else {\n            if ((matintypeB < 4.5)) {\n              lowp float tmpvar_77;\n              tmpvar_77 = clamp (((\n                (tmpvar_64 / nonBackboneLen)\n               - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n              tmpvar_76 = (1.0 - (tmpvar_77 * (tmpvar_77 * \n                (3.0 - (2.0 * tmpvar_77))\n              )));\n            } else {\n              if ((matintypeB < 5.5)) {\n                lowp float tmpvar_78;\n                tmpvar_78 = clamp (((\n                  (texture2D (matrix2dtexB, tmpvar_68).x / nonBackboneLen)\n                 - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n                tmpvar_76 = (1.0 - (tmpvar_78 * (tmpvar_78 * \n                  (3.0 - (2.0 * tmpvar_78))\n                )));\n              } else {\n                if ((matintypeB < 6.5)) {\n                  lowp float dist_79;\n                  lowp float tmpvar_80;\n                  tmpvar_80 = max (0.0, texture2D (matrix2dtexB, tmpvar_68).x);\n                  if ((contactforcesc != 0.0)) {\n                    dist_79 = pow (((\n                      (tmpvar_80 * contactforcesc)\n                     / pushapartforce) * pow (powBaseDist, pushapartpow)), (1.0/((pushapartpow - 1.0))));\n                  } else {\n                    dist_79 = (m_k * pow ((tmpvar_80 / representativeContact), -(m_alpha)));\n                  };\n                  lowp float tmpvar_81;\n                  tmpvar_81 = clamp (((dist_79 - matDistNear) / (matDistFar - matDistNear)), 0.0, 1.0);\n                  tmpvar_76 = (1.0 - (tmpvar_81 * (tmpvar_81 * \n                    (3.0 - (2.0 * tmpvar_81))\n                  )));\n                } else {\n                  tmpvar_76 = ((texture2D (matrix2dtexB, tmpvar_68).x - matrixcontactmin) * matrixcontactmult);\n                };\n              };\n            };\n          };\n        };\n      };\n      lowp float tmpvar_82;\n      tmpvar_82 = clamp (tmpvar_76, 0.0, 1.0);\n      vec3 tmpvar_83;\n      tmpvar_83.x = matC00r;\n      tmpvar_83.y = matC00g;\n      tmpvar_83.z = matC00b;\n      vec3 tmpvar_84;\n      tmpvar_84.x = matC11r;\n      tmpvar_84.y = matC11g;\n      tmpvar_84.z = matC11b;\n      lowp vec3 tmpvar_85;\n      tmpvar_85 = mix (tmpvar_83, tmpvar_84, max (tmpvar_75, tmpvar_82));\n      vec3 tmpvar_86;\n      if ((tmpvar_75 > tmpvar_82)) {\n        vec3 tmpvar_87;\n        tmpvar_87.x = matC10r;\n        tmpvar_87.y = matC10g;\n        tmpvar_87.z = matC10b;\n        tmpvar_86 = tmpvar_87;\n      } else {\n        vec3 tmpvar_88;\n        tmpvar_88.x = matC01r;\n        tmpvar_88.y = matC01g;\n        tmpvar_88.z = matC01b;\n        tmpvar_86 = tmpvar_88;\n      };\n      tmpvar_58.xyz = mix (tmpvar_85, tmpvar_86, clamp ((matrixTintStrength * \n        abs((tmpvar_75 - tmpvar_82))\n      ), 0.0, 1.0));\n    };\n  };\n  tmpvar_58.xyz = pow (tmpvar_58.xyz, vec3(matgamma));\n  lowp vec3 c_89;\n  c_89 = tmpvar_58.xyz;\n  lowp vec4 tmpvar_90;\n  tmpvar_90.xy = c_89.zy;\n  tmpvar_90.zw = vec2(-1.0, 0.6666667);\n  lowp vec4 tmpvar_91;\n  tmpvar_91.xy = c_89.yz;\n  tmpvar_91.zw = vec2(0.0, -0.3333333);\n  lowp vec4 tmpvar_92;\n  tmpvar_92 = mix (tmpvar_90, tmpvar_91, float((tmpvar_58.y >= tmpvar_58.z)));\n  lowp vec4 tmpvar_93;\n  tmpvar_93.xyz = tmpvar_92.xyw;\n  tmpvar_93.w = c_89.x;\n  lowp vec4 tmpvar_94;\n  tmpvar_94.x = c_89.x;\n  tmpvar_94.yzw = tmpvar_92.yzx;\n  lowp vec4 tmpvar_95;\n  tmpvar_95 = mix (tmpvar_93, tmpvar_94, float((tmpvar_58.x >= tmpvar_92.x)));\n  lowp float tmpvar_96;\n  tmpvar_96 = (tmpvar_95.x - min (tmpvar_95.w, tmpvar_95.y));\n  lowp vec3 tmpvar_97;\n  tmpvar_97.x = abs((tmpvar_95.z + (\n    (tmpvar_95.w - tmpvar_95.y)\n   / \n    ((6.0 * tmpvar_96) + 1e-10)\n  )));\n  tmpvar_97.y = (tmpvar_96 / (tmpvar_95.x + 1e-10));\n  tmpvar_97.z = tmpvar_95.x;\n  tmpvar_59.xyz = tmpvar_97;\n  if ((matrixgridres != 0.0)) {\n    float tmpvar_98;\n    tmpvar_98 = (1.0/(matrixgridsoftw));\n    lowp float tmpvar_99;\n    tmpvar_99 = min (((1.0 - \n      (clamp ((abs(\n        fract(((shapepos_5.x * tmpvar_60) / matrixgridres))\n      ) - matrixgridwidth), 0.0, matrixgridsoftw) * tmpvar_98)\n    ) + (1.0 - \n      (clamp ((abs(\n        fract(((shapepos_5.y * tmpvar_60) / matrixgridres))\n      ) - matrixgridwidth), 0.0, matrixgridsoftw) * tmpvar_98)\n    )), 1.0);\n    tmpvar_58.xyz = (tmpvar_58.xyz + (vec3(0.0, 0.7, 0.7) * tmpvar_99));\n    if ((tmpvar_99 > 0.0)) {\n      lowp vec3 tmpvar_100;\n      tmpvar_100.xy = vec2(0.5, 1.0);\n      tmpvar_100.z = (0.1 * tmpvar_99);\n      tmpvar_59.xyz = tmpvar_100;\n    };\n  };\n  lowp vec2 tmpvar_101;\n  tmpvar_101 = texpos_1.xy;\n  if ((matrixbedtint != 0.0)) {\n    lowp vec2 tmpvar_102;\n    tmpvar_102.y = 0.5;\n    tmpvar_102.x = tmpvar_101.x;\n    lowp vec4 tmpvar_103;\n    tmpvar_103 = texture2D (matrixbed, tmpvar_102);\n    lowp float tmpvar_104;\n    tmpvar_104 = (tmpvar_103.w * 255.0);\n    lowp vec3 tmpvar_105;\n    if (((tmpvar_103.x != tmpvar_103.w) || (tmpvar_103.y != tmpvar_103.w))) {\n      tmpvar_105 = tmpvar_103.xyz;\n    } else {\n      lowp float tmpvar_106;\n      if ((tmpvar_104 == 0.0)) {\n        tmpvar_106 = 0.0;\n      } else {\n        tmpvar_106 = ((float(mod (tmpvar_104, 6.0))) + 1.0);\n      };\n      vec3 col_107;\n      lowp float tmpvar_108;\n      tmpvar_108 = floor((floor(tmpvar_106) + 0.5));\n      if ((tmpvar_108 < 0.0)) {\n        col_107 = vec3(9.5, 0.5, 0.5);\n      } else {\n        if ((tmpvar_108 == 0.0)) {\n          col_107 = vec3(0.5, 0.5, 0.5);\n        } else {\n          if ((tmpvar_108 == 1.0)) {\n            col_107 = vec3(1.0, 0.0, 0.0);\n          } else {\n            if ((tmpvar_108 == 2.0)) {\n              col_107 = vec3(0.0, 1.0, 0.0);\n            } else {\n              if ((tmpvar_108 == 3.0)) {\n                col_107 = vec3(0.0, 0.0, 1.0);\n              } else {\n                if ((tmpvar_108 == 4.0)) {\n                  col_107 = vec3(0.0, 1.0, 1.0);\n                } else {\n                  if ((tmpvar_108 == 5.0)) {\n                    col_107 = vec3(0.0, 1.0, 0.0);\n                  } else {\n                    if ((tmpvar_108 == 6.0)) {\n                      col_107 = vec3(1.0, 1.0, 0.0);\n                    } else {\n                      col_107 = vec3(1.0, 1.0, 1.0);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n      tmpvar_105 = col_107;\n    };\n    tmpvar_58.xyz = (tmpvar_58.xyz + (tmpvar_105 * matrixbedtint));\n    lowp vec2 tmpvar_109;\n    tmpvar_109.y = 0.5;\n    tmpvar_109.x = tmpvar_101.y;\n    lowp vec4 tmpvar_110;\n    tmpvar_110 = texture2D (matrixbed, tmpvar_109);\n    lowp float tmpvar_111;\n    tmpvar_111 = (tmpvar_110.w * 255.0);\n    lowp vec3 tmpvar_112;\n    if (((tmpvar_110.x != tmpvar_110.w) || (tmpvar_110.y != tmpvar_110.w))) {\n      tmpvar_112 = tmpvar_110.xyz;\n    } else {\n      lowp float tmpvar_113;\n      if ((tmpvar_111 == 0.0)) {\n        tmpvar_113 = 0.0;\n      } else {\n        tmpvar_113 = ((float(mod (tmpvar_111, 6.0))) + 1.0);\n      };\n      vec3 col_114;\n      lowp float tmpvar_115;\n      tmpvar_115 = floor((floor(tmpvar_113) + 0.5));\n      if ((tmpvar_115 < 0.0)) {\n        col_114 = vec3(9.5, 0.5, 0.5);\n      } else {\n        if ((tmpvar_115 == 0.0)) {\n          col_114 = vec3(0.5, 0.5, 0.5);\n        } else {\n          if ((tmpvar_115 == 1.0)) {\n            col_114 = vec3(1.0, 0.0, 0.0);\n          } else {\n            if ((tmpvar_115 == 2.0)) {\n              col_114 = vec3(0.0, 1.0, 0.0);\n            } else {\n              if ((tmpvar_115 == 3.0)) {\n                col_114 = vec3(0.0, 0.0, 1.0);\n              } else {\n                if ((tmpvar_115 == 4.0)) {\n                  col_114 = vec3(0.0, 1.0, 1.0);\n                } else {\n                  if ((tmpvar_115 == 5.0)) {\n                    col_114 = vec3(0.0, 1.0, 0.0);\n                  } else {\n                    if ((tmpvar_115 == 6.0)) {\n                      col_114 = vec3(1.0, 1.0, 0.0);\n                    } else {\n                      col_114 = vec3(1.0, 1.0, 1.0);\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n      tmpvar_112 = col_114;\n    };\n    tmpvar_58.xyz = (tmpvar_58.xyz + (tmpvar_112 * matrixbedtint));\n  };\n  if (!(((\n    ((minActive <= shapepos_5.x) && (shapepos_5.x <= maxActive))\n   && \n    ((minActive <= shapepos_5.y) && (shapepos_5.y <= maxActive))\n  ) && (\n    (shapepos_5.y - shapepos_5.x)\n   < maxBackboneDist)))) {\n    tmpvar_58.xyz = (tmpvar_58.xyz * 0.5);\n    tmpvar_59.z = (tmpvar_59.z * 0.5);\n  };\n  i_57 = 0;\n//  while (true) {\n//    if ((i_57 >= 32)) {\n//      break;\n//    };\nfor (int i_57 = 0; i_57 < 32; i_57++) {\n    if (!(((\n      ((((\n        (i_57 == 0)\n       || \n        (i_57 == 4)\n      ) || (i_57 == 5)) || (i_57 == 8)) || (i_57 == 12))\n     || \n      (i_57 == 13)\n    ) || (i_57 >= 16)))) {\n//      i_57++;\n      continue;\n    };\n    lowp float tmpvar_116;\n    if ((i_57 == 16)) {\n      tmpvar_116 = userPicks[0];\n    } else {\n      if ((i_57 == 17)) {\n        tmpvar_116 = userPicks[1];\n      } else {\n        if ((i_57 == 18)) {\n          tmpvar_116 = userPicks[2];\n        } else {\n          if ((i_57 == 19)) {\n            tmpvar_116 = userPicks[3];\n          } else {\n            if ((i_57 == 20)) {\n              tmpvar_116 = userPicks[4];\n            } else {\n              if ((i_57 == 21)) {\n                tmpvar_116 = userPicks[5];\n              } else {\n                if ((i_57 == 22)) {\n                  tmpvar_116 = userPicks[6];\n                } else {\n                  if ((i_57 == 23)) {\n                    tmpvar_116 = userPicks[7];\n                  } else {\n                    if ((i_57 == 24)) {\n                      tmpvar_116 = userPicks[8];\n                    } else {\n                      if ((i_57 == 25)) {\n                        tmpvar_116 = userPicks[9];\n                      } else {\n                        if ((i_57 == 26)) {\n                          tmpvar_116 = userPicks[10];\n                        } else {\n                          if ((i_57 == 27)) {\n                            tmpvar_116 = userPicks[11];\n                          } else {\n                            if ((i_57 == 28)) {\n                              tmpvar_116 = userPicks[12];\n                            } else {\n                              if ((i_57 == 29)) {\n                                tmpvar_116 = userPicks[13];\n                              } else {\n                                if ((i_57 == 30)) {\n                                  tmpvar_116 = userPicks[14];\n                                } else {\n                                  if ((i_57 == 31)) {\n                                    tmpvar_116 = userPicks[15];\n                                  } else {\n                                    float tmpvar_117;\n                                    tmpvar_117 = (float(i_57) / 4.0);\n                                    float tmpvar_118;\n                                    tmpvar_118 = floor(tmpvar_117);\n                                    vec2 tmpvar_119;\n                                    tmpvar_119.y = 0.5;\n                                    tmpvar_119.x = (tmpvar_118 / 4.0);\n                                    lowp vec4 tmpvar_120;\n                                    tmpvar_120 = texture2D (pickrt, tmpvar_119);\n                                    highp int tmpvar_121;\n                                    tmpvar_121 = int(floor((\n                                      (tmpvar_117 - tmpvar_118)\n                                     * 4.0)));\n                                    lowp float tmpvar_122;\n                                    if ((tmpvar_121 == 0)) {\n                                      tmpvar_122 = tmpvar_120.x;\n                                    } else {\n                                      lowp float tmpvar_123;\n                                      if ((tmpvar_121 == 1)) {\n                                        tmpvar_123 = tmpvar_120.y;\n                                      } else {\n                                        lowp float tmpvar_124;\n                                        if ((tmpvar_121 == 2)) {\n                                          tmpvar_124 = tmpvar_120.z;\n                                        } else {\n                                          lowp float tmpvar_125;\n                                          if ((tmpvar_121 == 3)) {\n                                            tmpvar_125 = tmpvar_120.w;\n                                          } else {\n                                            tmpvar_125 = 999.0;\n                                          };\n                                          tmpvar_124 = tmpvar_125;\n                                        };\n                                        tmpvar_123 = tmpvar_124;\n                                      };\n                                      tmpvar_122 = tmpvar_123;\n                                    };\n                                    tmpvar_116 = tmpvar_122;\n                                  };\n                                };\n                              };\n                            };\n                          };\n                        };\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n    };\n    highp vec2 P_126;\n    P_126 = (gl_FragCoord.xy * screen);\n    lowp float tmpvar_127;\n    tmpvar_127 = abs((texture2D (rtopos, P_126).x - tmpvar_116));\n    bool tmpvar_128;\n    if ((tmpvar_127 < 0.001)) {\n      tmpvar_128 = bool(1);\n    } else {\n      highp vec2 P_129;\n      P_129 = (gl_FragCoord.xy * screen);\n      tmpvar_128 = (abs((texture2D (rtopos, P_129).y - tmpvar_116)) < 0.001);\n    };\n    if (tmpvar_128) {\n      vec3 tmpvar_130;\n      if ((i_57 < 8)) {\n        tmpvar_130 = vec3(1.0, 0.0, 0.0);\n      } else {\n        if ((i_57 < 16)) {\n          tmpvar_130 = vec3(0.0, 1.0, 0.0);\n        } else {\n          if ((i_57 == 16)) {\n            tmpvar_130 = vec3(0.0, 1.0, 1.0);\n          } else {\n            if ((i_57 == 17)) {\n              tmpvar_130 = vec3(1.0, 0.0, 1.0);\n            } else {\n              if ((i_57 == 18)) {\n                tmpvar_130 = vec3(1.0, 1.0, 0.0);\n              } else {\n                if ((i_57 == 19)) {\n                  tmpvar_130 = vec3(1.0, 1.0, 1.0);\n                } else {\n                  if ((i_57 == 20)) {\n                    tmpvar_130 = vec3(0.5, 1.0, 1.0);\n                  } else {\n                    if ((i_57 == 21)) {\n                      tmpvar_130 = vec3(1.0, 0.5, 1.0);\n                    } else {\n                      if ((i_57 == 22)) {\n                        tmpvar_130 = vec3(1.0, 1.0, 0.5);\n                      } else {\n                        if ((i_57 == 23)) {\n                          tmpvar_130 = vec3(1.0, 1.0, 1.0);\n                        } else {\n                          tmpvar_130 = vec3(1.0, 1.0, 1.0);\n                        };\n                      };\n                    };\n                  };\n                };\n              };\n            };\n          };\n        };\n      };\n      tmpvar_58.xyz = (tmpvar_58.xyz + tmpvar_130);\n      vec4 tmpvar_131;\n      tmpvar_131.xy = tmpvar_130.zy;\n      tmpvar_131.zw = vec2(-1.0, 0.6666667);\n      vec4 tmpvar_132;\n      tmpvar_132.xy = tmpvar_130.yz;\n      tmpvar_132.zw = vec2(0.0, -0.3333333);\n      vec4 tmpvar_133;\n      tmpvar_133 = mix (tmpvar_131, tmpvar_132, float((tmpvar_130.y >= tmpvar_130.z)));\n      vec4 tmpvar_134;\n      tmpvar_134.xyz = tmpvar_133.xyw;\n      tmpvar_134.w = tmpvar_130.x;\n      vec4 tmpvar_135;\n      tmpvar_135.x = tmpvar_130.x;\n      tmpvar_135.yzw = tmpvar_133.yzx;\n      vec4 tmpvar_136;\n      tmpvar_136 = mix (tmpvar_134, tmpvar_135, float((tmpvar_130.x >= tmpvar_133.x)));\n      float tmpvar_137;\n      tmpvar_137 = (tmpvar_136.x - min (tmpvar_136.w, tmpvar_136.y));\n      lowp vec3 tmpvar_138;\n      tmpvar_138.x = abs((tmpvar_136.z + (\n        (tmpvar_136.w - tmpvar_136.y)\n       / \n        ((6.0 * tmpvar_137) + 1e-10)\n      )));\n      tmpvar_138.y = (tmpvar_137 / (tmpvar_136.x + 1e-10));\n      tmpvar_138.z = tmpvar_136.x;\n      tmpvar_59.xyz = tmpvar_138;\n    };\n//    i_57++;\n  };\n  vec3 tmpvar_139;\n  bool tmpvar_140;\n  lowp vec3 tmpvar_141;\n  tmpvar_141 = normalize(tmpvar_55);\n  lowp vec3 tmpvar_142;\n  tmpvar_142 = normalize(mmnormal_48);\n  tmpvar_140 = (light0dirx >= 490.0);\n  vec3 tmpvar_143;\n  tmpvar_143.x = light0dirx;\n  tmpvar_143.y = light0diry;\n  tmpvar_143.z = light0dirz;\n  vec3 tmpvar_144;\n  tmpvar_144 = normalize(tmpvar_143);\n  vec3 tmpvar_145;\n  tmpvar_145.x = light0x;\n  tmpvar_145.y = light0y;\n  tmpvar_145.z = light0z;\n  vec3 tmpvar_146;\n  tmpvar_146.x = light0r;\n  tmpvar_146.y = light0g;\n  tmpvar_146.z = light0b;\n  tmpvar_139 = (vec3(0.6, 0.6, 0.6) * tmpvar_146);\n  lowp vec3 tmpvar_147;\n  vec3 tmpvar_148;\n  tmpvar_148 = tmpvar_139;\n  lowp float normdotlight_149;\n  lowp float lightfall_150;\n  lowp vec3 point2light_151;\n  if (tmpvar_140) {\n    point2light_151 = normalize(tmpvar_145);\n    lightfall_150 = 1.0;\n  } else {\n    lowp float dist_152;\n    lowp vec3 tmpvar_153;\n    tmpvar_153 = normalize((tmpvar_145 - tmpvar_37.xyz));\n    point2light_151 = tmpvar_153;\n    lowp vec3 x_154;\n    x_154 = (tmpvar_37.xyz - tmpvar_145);\n    dist_152 = (sqrt(dot (x_154, x_154)) / light0HalfDist);\n    lightfall_150 = (max (0.0, (\n      ((-(dot (tmpvar_153, tmpvar_144)) + light0Spread) - 1.0)\n     / light0Spread)) * (1.0/((1.0 + \n      (dist_152 * dist_152)\n    ))));\n  };\n  lowp float tmpvar_155;\n  tmpvar_155 = dot (point2light_151, tmpvar_142);\n  normdotlight_149 = tmpvar_155;\n  if ((tmpvar_155 < 0.0)) {\n    normdotlight_149 = -(tmpvar_155);\n    point2light_151 = -(point2light_151);\n    tmpvar_148 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_156;\n  lowp float fresnel_157;\n  lowp vec3 V_158;\n  V_158.xy = tmpvar_141.xy;\n  V_158.z = (tmpvar_141.z + 0.0001);\n  lowp vec3 tmpvar_159;\n  tmpvar_159 = normalize((point2light_151 + V_158));\n  lowp float tmpvar_160;\n  tmpvar_160 = dot (tmpvar_142, tmpvar_159);\n  lowp float tmpvar_161;\n  tmpvar_161 = dot (V_158, tmpvar_159);\n  lowp float tmpvar_162;\n  tmpvar_162 = dot (tmpvar_142, V_158);\n  lowp float tmpvar_163;\n  tmpvar_163 = (tmpvar_160 * tmpvar_160);\n  float tmpvar_164;\n  tmpvar_164 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_165;\n  tmpvar_165 = (tmpvar_164 * tmpvar_164);\n  fresnel_157 = (pow (max (0.0, \n    (1.0 - tmpvar_161)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_157 = (fresnel_157 + fresnel0);\n  specular_156 = (((fresnel_157 * \n    ((1.0/(((4.0 * tmpvar_165) * (tmpvar_163 * tmpvar_163)))) * exp(((tmpvar_163 - 1.0) / (tmpvar_165 * tmpvar_163))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_160) * tmpvar_162) / tmpvar_161), (((2.0 * tmpvar_160) * clamp (\n      dot (tmpvar_142, point2light_151)\n    , 0.0, 1.0)) / tmpvar_161))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_162));\n  if (!(((0.0 <= specular_156) && (specular_156 <= 1e+20)))) {\n    specular_156 = 0.0;\n  };\n  tmpvar_147 = (((\n    (normdotlight_149 * tmpvar_58.xyz)\n   * \n    (tmpvar_148 * lightfall_150)\n  ) * (1.0 - ambient)) * light0s);\n  tmpvar_140 = (light1dirx >= 490.0);\n  vec3 tmpvar_166;\n  tmpvar_166.x = light1dirx;\n  tmpvar_166.y = light1diry;\n  tmpvar_166.z = light1dirz;\n  vec3 tmpvar_167;\n  tmpvar_167 = normalize(tmpvar_166);\n  vec3 tmpvar_168;\n  tmpvar_168.x = light1x;\n  tmpvar_168.y = light1y;\n  tmpvar_168.z = light1z;\n  vec3 tmpvar_169;\n  tmpvar_169.x = light1r;\n  tmpvar_169.y = light1g;\n  tmpvar_169.z = light1b;\n  tmpvar_139 = (vec3(0.6, 0.6, 0.6) * tmpvar_169);\n  lowp vec3 tmpvar_170;\n  vec3 tmpvar_171;\n  tmpvar_171 = tmpvar_139;\n  lowp float normdotlight_172;\n  lowp float lightfall_173;\n  lowp vec3 point2light_174;\n  if (tmpvar_140) {\n    point2light_174 = normalize(tmpvar_168);\n    lightfall_173 = 1.0;\n  } else {\n    lowp float dist_175;\n    lowp vec3 tmpvar_176;\n    tmpvar_176 = normalize((tmpvar_168 - tmpvar_37.xyz));\n    point2light_174 = tmpvar_176;\n    lowp vec3 x_177;\n    x_177 = (tmpvar_37.xyz - tmpvar_168);\n    dist_175 = (sqrt(dot (x_177, x_177)) / light1HalfDist);\n    lightfall_173 = (max (0.0, (\n      ((-(dot (tmpvar_176, tmpvar_167)) + light1Spread) - 1.0)\n     / light1Spread)) * (1.0/((1.0 + \n      (dist_175 * dist_175)\n    ))));\n  };\n  lowp float tmpvar_178;\n  tmpvar_178 = dot (point2light_174, tmpvar_142);\n  normdotlight_172 = tmpvar_178;\n  if ((tmpvar_178 < 0.0)) {\n    normdotlight_172 = -(tmpvar_178);\n    point2light_174 = -(point2light_174);\n    tmpvar_171 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_179;\n  lowp float fresnel_180;\n  lowp vec3 V_181;\n  V_181.xy = tmpvar_141.xy;\n  V_181.z = (tmpvar_141.z + 0.0001);\n  lowp vec3 tmpvar_182;\n  tmpvar_182 = normalize((point2light_174 + V_181));\n  lowp float tmpvar_183;\n  tmpvar_183 = dot (tmpvar_142, tmpvar_182);\n  lowp float tmpvar_184;\n  tmpvar_184 = dot (V_181, tmpvar_182);\n  lowp float tmpvar_185;\n  tmpvar_185 = dot (tmpvar_142, V_181);\n  lowp float tmpvar_186;\n  tmpvar_186 = (tmpvar_183 * tmpvar_183);\n  float tmpvar_187;\n  tmpvar_187 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_188;\n  tmpvar_188 = (tmpvar_187 * tmpvar_187);\n  fresnel_180 = (pow (max (0.0, \n    (1.0 - tmpvar_184)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_180 = (fresnel_180 + fresnel0);\n  specular_179 = (((fresnel_180 * \n    ((1.0/(((4.0 * tmpvar_188) * (tmpvar_186 * tmpvar_186)))) * exp(((tmpvar_186 - 1.0) / (tmpvar_188 * tmpvar_186))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_183) * tmpvar_185) / tmpvar_184), (((2.0 * tmpvar_183) * clamp (\n      dot (tmpvar_142, point2light_174)\n    , 0.0, 1.0)) / tmpvar_184))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_185));\n  if (!(((0.0 <= specular_179) && (specular_179 <= 1e+20)))) {\n    specular_179 = 0.0;\n  };\n  tmpvar_170 = (((\n    (normdotlight_172 * tmpvar_58.xyz)\n   * \n    (tmpvar_171 * lightfall_173)\n  ) * (1.0 - ambient)) * light1s);\n  tmpvar_140 = (light2dirx >= 490.0);\n  vec3 tmpvar_189;\n  tmpvar_189.x = light2dirx;\n  tmpvar_189.y = light2diry;\n  tmpvar_189.z = light2dirz;\n  vec3 tmpvar_190;\n  tmpvar_190 = normalize(tmpvar_189);\n  vec3 tmpvar_191;\n  tmpvar_191.x = light2x;\n  tmpvar_191.y = light2y;\n  tmpvar_191.z = light2z;\n  vec3 tmpvar_192;\n  tmpvar_192.x = light2r;\n  tmpvar_192.y = light2g;\n  tmpvar_192.z = light2b;\n  tmpvar_139 = (vec3(0.6, 0.6, 0.6) * tmpvar_192);\n  vec3 tmpvar_193;\n  tmpvar_193 = tmpvar_139;\n  lowp float normdotlight_194;\n  lowp float lightfall_195;\n  lowp vec3 point2light_196;\n  if (tmpvar_140) {\n    point2light_196 = normalize(tmpvar_191);\n    lightfall_195 = 1.0;\n  } else {\n    lowp float dist_197;\n    lowp vec3 tmpvar_198;\n    tmpvar_198 = normalize((tmpvar_191 - tmpvar_37.xyz));\n    point2light_196 = tmpvar_198;\n    lowp vec3 x_199;\n    x_199 = (tmpvar_37.xyz - tmpvar_191);\n    dist_197 = (sqrt(dot (x_199, x_199)) / light2HalfDist);\n    lightfall_195 = (max (0.0, (\n      ((-(dot (tmpvar_198, tmpvar_190)) + light2Spread) - 1.0)\n     / light2Spread)) * (1.0/((1.0 + \n      (dist_197 * dist_197)\n    ))));\n  };\n  lowp float tmpvar_200;\n  tmpvar_200 = dot (point2light_196, tmpvar_142);\n  normdotlight_194 = tmpvar_200;\n  if ((tmpvar_200 < 0.0)) {\n    normdotlight_194 = -(tmpvar_200);\n    point2light_196 = -(point2light_196);\n    tmpvar_193 = vec3(0.0, 0.0, 0.0);\n  };\n  lowp float specular_201;\n  lowp float fresnel_202;\n  lowp vec3 V_203;\n  V_203.xy = tmpvar_141.xy;\n  V_203.z = (tmpvar_141.z + 0.0001);\n  lowp vec3 tmpvar_204;\n  tmpvar_204 = normalize((point2light_196 + V_203));\n  lowp float tmpvar_205;\n  tmpvar_205 = dot (tmpvar_142, tmpvar_204);\n  lowp float tmpvar_206;\n  tmpvar_206 = dot (V_203, tmpvar_204);\n  lowp float tmpvar_207;\n  tmpvar_207 = dot (tmpvar_142, V_203);\n  lowp float tmpvar_208;\n  tmpvar_208 = (tmpvar_205 * tmpvar_205);\n  float tmpvar_209;\n  tmpvar_209 = clamp (0.2, 0.05, 0.95);\n  float tmpvar_210;\n  tmpvar_210 = (tmpvar_209 * tmpvar_209);\n  fresnel_202 = (pow (max (0.0, \n    (1.0 - tmpvar_206)\n  ), 5.0) * (1.0 - fresnel0));\n  fresnel_202 = (fresnel_202 + fresnel0);\n  specular_201 = (((fresnel_202 * \n    ((1.0/(((4.0 * tmpvar_210) * (tmpvar_208 * tmpvar_208)))) * exp(((tmpvar_208 - 1.0) / (tmpvar_210 * tmpvar_208))))\n  ) * clamp (\n    min ((((2.0 * tmpvar_205) * tmpvar_207) / tmpvar_206), (((2.0 * tmpvar_205) * clamp (\n      dot (tmpvar_142, point2light_196)\n    , 0.0, 1.0)) / tmpvar_206))\n  , 0.0, 1.0)) / max (1e-10, tmpvar_207));\n  if (!(((0.0 <= specular_201) && (specular_201 <= 1e+20)))) {\n    specular_201 = 0.0;\n  };\n  lowp vec4 tmpvar_211;\n  tmpvar_211.w = 1.0;\n  tmpvar_211.xyz = (((tmpvar_147 + tmpvar_170) + (\n    (((normdotlight_194 * tmpvar_58.xyz) * (tmpvar_193 * lightfall_195)) * (1.0 - ambient))\n   * light2s)) + (ambient * tmpvar_58.xyz));\n  col_47.xyz = tmpvar_211.xyz;\n  col_47.w = 1.0;\n  res_46 = col_47;\n  lowp vec2 tmpvar_212;\n  tmpvar_212.x = 0.96875;\n  tmpvar_212.y = ((colourid + 0.5) / 32.0);\n  lowp vec4 tmpvar_213;\n  tmpvar_213 = texture2D (colbuff, tmpvar_212);\n  if ((tmpvar_213.z != 0.0)) {\n    lowp vec2 tmpvar_214;\n    tmpvar_214.x = 0.96875;\n    tmpvar_214.y = ((colourid + 0.5) / 32.0);\n    lowp vec4 tmpvar_215;\n    tmpvar_215 = texture2D (colbuff, tmpvar_214);\n    if ((tmpvar_215.z < 0.0)) {\n      res_46.xyz = (tmpvar_211.xyz + clamp ((tmpvar_59.z * \n        mix (vec3(1.0, 1.0, 1.0), clamp ((abs(\n          ((fract((tmpvar_59.xxx + vec3(1.0, 0.6666667, 0.3333333))) * 6.0) - vec3(3.0, 3.0, 3.0))\n        ) - vec3(1.0, 1.0, 1.0)), 0.0, 1.0), tmpvar_59.y)\n      ), 0.0, 1.0));\n    } else {\n      lowp vec2 tmpvar_216;\n      tmpvar_216.x = 0.96875;\n      tmpvar_216.y = ((colourid + 0.5) / 32.0);\n      lowp vec2 tmpvar_217;\n      tmpvar_217.x = 0.21875;\n      tmpvar_217.y = ((colourid + 0.5) / 32.0);\n      lowp float tmpvar_218;\n      tmpvar_218 = (texture2D (colbuff, tmpvar_216).z / texture2D (colbuff, tmpvar_217).w);\n      lowp float tmpvar_219;\n      tmpvar_219 = (flulow + tmpvar_218);\n      lowp vec4 tmpvar_220;\n      highp vec2 P_221;\n      P_221 = (gl_FragCoord.xy * screen);\n      tmpvar_220 = texture2D (rttexture, P_221);\n      lowp vec4 tmpvar_222;\n      highp vec2 P_223;\n      P_223 = ((gl_FragCoord.xy + vec2(0.0, 1.0)) * screen);\n      tmpvar_222 = texture2D (rttexture, P_223);\n      lowp vec4 tmpvar_224;\n      highp vec2 P_225;\n      P_225 = ((gl_FragCoord.xy + vec2(1.0, 0.0)) * screen);\n      tmpvar_224 = texture2D (rttexture, P_225);\n      lowp vec4 tmpvar_226;\n      highp vec2 P_227;\n      P_227 = ((gl_FragCoord.xy + vec2(1.0, 1.0)) * screen);\n      tmpvar_226 = texture2D (rttexture, P_227);\n      if (!(((\n        (tmpvar_220.w != tmpvar_222.w)\n       || \n        (tmpvar_220.w != tmpvar_224.w)\n      ) || (tmpvar_220.w != tmpvar_226.w)))) {\n        lowp float tmpvar_228;\n        tmpvar_228 = min (min (tmpvar_220.x, tmpvar_222.x), min (tmpvar_224.x, tmpvar_226.x));\n        lowp float tmpvar_229;\n        tmpvar_229 = max (max (tmpvar_220.x, tmpvar_222.x), max (tmpvar_224.x, tmpvar_226.x));\n        if (!(((tmpvar_228 > tmpvar_219) || (tmpvar_229 < flulow)))) {\n          lowp float tmpvar_230;\n          tmpvar_230 = max (tmpvar_228, flulow);\n          lowp float tmpvar_231;\n          tmpvar_231 = min (tmpvar_229, tmpvar_219);\n          lowp float tmpvar_232;\n          if ((tmpvar_229 == tmpvar_228)) {\n            tmpvar_232 = 1.0;\n          } else {\n            tmpvar_232 = ((tmpvar_231 - tmpvar_230) / (tmpvar_229 - tmpvar_228));\n          };\n          res_46.xyz = (res_46.xyz + (clamp (\n            (tmpvar_59.z * mix (vec3(1.0, 1.0, 1.0), clamp ((\n              abs(((fract(\n                (tmpvar_59.xxx + vec3(1.0, 0.6666667, 0.3333333))\n              ) * 6.0) - vec3(3.0, 3.0, 3.0)))\n             - vec3(1.0, 1.0, 1.0)), 0.0, 1.0), tmpvar_59.y))\n          , 0.0, 1.0) * (tmpvar_232 * \n            ((((tmpvar_230 - flulow) / tmpvar_218) + ((tmpvar_231 - flulow) / tmpvar_218)) * 0.5)\n          )));\n        };\n      };\n    };\n  };\n  if ((foghalfdepth != 0.0)) {\n    vec3 tmpvar_233;\n    tmpvar_233.x = fogr;\n    tmpvar_233.y = fogg;\n    tmpvar_233.z = fogb;\n    res_46.xyz = mix (tmpvar_233, res_46.xyz, pow (0.5, (\n      max (0.0, (tmpvar_53 - fogstartdist))\n     / foghalfdepth)));\n  };\n  res_46.xyz = (res_46 + postxcol).xyz;\n  res_46.w = opacity;\n  lowp vec4 tmpvar_234;\n  tmpvar_234.w = 1.0;\n  tmpvar_234.xyz = ((xmnormal_4 + 1.0) * 0.5);\n  lowp vec4 tmpvar_235;\n  tmpvar_235.w = 1.0;\n  tmpvar_235.xyz = ((shapepos_5.xyz + 300.0) / 600.0);\n  lowp vec4 tmpvar_236;\n  tmpvar_236 = (((res_46 * \n    ((1.0 - xxposprop) - xxnormprop)\n  ) + (tmpvar_234 * xxnormprop)) + (tmpvar_235 * xxposprop));\n  tmpvar_38 = tmpvar_236;\n  gl_FragColor = tmpvar_38;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nattribute float instanceID;\nuniform float fakeinstanceID;\nvoid main ()\n{\n  highp vec4 tmpvar_1;\n  tmpvar_1.w = 1.0;\n  tmpvar_1.xy = position.xy;\n  tmpvar_1.z = (instanceID + fakeinstanceID);\n  gl_Position = tmpvar_1;\n}\n\n"}},"pick":{"// CSynth ribbon\n//(gn, s, min, max, delta, step, help, tag, free, useuniform)\ngene('wigmult', 500., 0, 2000, 10, 1, 'multiplier for wig radius', 'geom', 1);\ngene('colmix', 0., 0, 1, 0.1, 0.01, 'proportion of rainbow to use', 'geom', 1);\ngene('scaleFactor', 30., 1., 100., 10, 1, 'scaling factor for 3d ribbon etc', 'geom', 1);\ngene('ribbonPickWidth', 0.04, 0,1, 0.01, 0.01, 'how much of ribbon will have increased radius around selected particles', 'geom', 1 );\ngene('ribbonPickExtra', 0, 0,40, 0.1, 0.1, 'amount by which to increase ribbon diameter around selected particles', 'geom', 1 );\n\ngene('endblobs', 3., 0., 20., 1, 1, 'number of blobs at endc', 'geom', 1);\ngene('endbloblen', 0.01, 0., 0.1, 0.001, 0.0001, 'length of blobby end', 'geom', 1);\n\ngene('killradwidth', 0, 0, 10, 1, 1, 'numer of particles to kill each side of killrad points', 'geom', 1);\n\n\n//gene('numSegs', 87, 0,1023, 1,1, 'number of segments, numInstances-1', 'system', 0);\n//gene('numInstancesP2', 87, 0,1023, 1,1, 'power of 2 to hold all instances', 'system', 0);\nhorn('R').ribs(20).radius(80)\n  .code('vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;') // nb, r set below in skerad\n  .code('#define SKELPICK')\n;\nmainhorn='R';\nonframe(checkvr, 5);\nonframe(checkvr, 25);\nextradefines = `\n  uniform sampler2D t_ribboncol, t_ribbonrad;\n  #define KILLRADLEN 4\n  uniform float killrads[KILLRADLEN];\n`;\noverrides= //gl //comment serves as a tag to start a glsl section\n`\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) { \\\n    float p = getPickC(i);\\\n    float xtra = 1. - abs(p-rp) / ribbonPickWidth;\\\n    rx = max(rx, xtra);\\\n  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n`; ///gl  //comment closes the glsl section\nCSynth.startdemo();\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nvarying vec4 pickVary0;\nvarying vec4 pickVary1;\nvarying vec4 pickVary2;\nvarying vec4 pickVary3;\nvoid main ()\n{\n  highp int tmpvar_1;\n  tmpvar_1 = int(floor(gl_FragCoord.x));\n  mediump vec4 tmpvar_2;\n  if ((tmpvar_1 == 0)) {\n    tmpvar_2 = pickVary0;\n  } else {\n    mediump vec4 tmpvar_3;\n    if ((tmpvar_1 == 1)) {\n      tmpvar_3 = pickVary1;\n    } else {\n      mediump vec4 tmpvar_4;\n      if ((tmpvar_1 == 2)) {\n        tmpvar_4 = pickVary2;\n      } else {\n        tmpvar_4 = pickVary3;\n      };\n      tmpvar_3 = tmpvar_4;\n    };\n    tmpvar_2 = tmpvar_3;\n  };\n  gl_FragColor = tmpvar_2;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform sampler2D t_ribbonrad;\nuniform float killrads[4];\nuniform vec3 awayvec;\nuniform vec4 _camd;\nuniform vec3 clearposA0;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nfloat ribs;\nuniform float nstar;\nuniform float stardepth;\nuniform float ribdepth;\nuniform float R_ribs;\nuniform float R_radius;\nfloat R_active;\nfloat R_rpbase;\nvec4 R_para;\nvec4 R_parb;\nuniform float cumcount3;\nuniform float wigmult;\nuniform float scaleFactor;\nuniform float ribbonPickWidth;\nuniform float ribbonPickExtra;\nuniform float endblobs;\nuniform float endbloblen;\nuniform float killradwidth;\nuniform mat4 rot4;\nuniform float pointSize;\nattribute float instanceID;\nuniform float fakeinstanceID;\nuniform float capres;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nvarying vec4 pickVary0;\nvarying vec4 pickVary1;\nvarying vec4 pickVary2;\nvarying vec4 pickVary3;\nuniform highp int pickxslot;\nuniform float lennum;\nuniform float skelnum;\nuniform float skelends;\nuniform vec2 skelbufferRes;\nuniform sampler2D skelbuffer;\nuniform sampler2D scaleDampTarget;\nuniform float NORMTYPE;\nuniform float USELOGDEPTH;\nvoid main ()\n{\n  lowp vec4 ooo_1;\n  vec4 p_2;\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xy = position.xy;\n  tmpvar_3.z = (instanceID + fakeinstanceID);\n  p_2.zw = tmpvar_3.zw;\n  p_2.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_2.y = (p_2.y * 0.5);\n  };\n  if ((tmpvar_3.z < cumcount3)) {\n    ribs = R_ribs;\n  } else {\n    ribs = 77.0;\n  };\n  pickVary0 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary1 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary2 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary3 = vec4(999.0, 999.0, 999.0, 999.0);\n  float v_4;\n  v_4 = p_2.x;\n  if ((pickxslot == 0)) {\n    pickVary0.x = v_4;\n  };\n  if ((pickxslot == 1)) {\n    pickVary0.y = v_4;\n  };\n  if ((pickxslot == 2)) {\n    pickVary0.z = v_4;\n  };\n  if ((pickxslot == 3)) {\n    pickVary0.w = v_4;\n  };\n  if ((pickxslot == 4)) {\n    pickVary1.x = v_4;\n  };\n  if ((pickxslot == 5)) {\n    pickVary1.y = v_4;\n  };\n  if ((pickxslot == 6)) {\n    pickVary1.z = v_4;\n  };\n  if ((pickxslot == 7)) {\n    pickVary1.w = v_4;\n  };\n  if ((pickxslot == 8)) {\n    pickVary2.x = v_4;\n  };\n  if ((pickxslot == 9)) {\n    pickVary2.y = v_4;\n  };\n  if ((pickxslot == 10)) {\n    pickVary2.z = v_4;\n  };\n  if ((pickxslot == 11)) {\n    pickVary2.w = v_4;\n  };\n  if ((pickxslot == 12)) {\n    pickVary3.x = v_4;\n  };\n  if ((pickxslot == 13)) {\n    pickVary3.y = v_4;\n  };\n  if ((pickxslot == 14)) {\n    pickVary3.z = v_4;\n  };\n  if ((pickxslot == 15)) {\n    pickVary3.w = v_4;\n  };\n  highp int num_5;\n  float v_6;\n  v_6 = p_2.y;\n  num_5 = (1 + pickxslot);\n  if ((num_5 == 0)) {\n    pickVary0.x = v_6;\n  };\n  if ((num_5 == 1)) {\n    pickVary0.y = v_6;\n  };\n  if ((num_5 == 2)) {\n    pickVary0.z = v_6;\n  };\n  if ((num_5 == 3)) {\n    pickVary0.w = v_6;\n  };\n  if ((num_5 == 4)) {\n    pickVary1.x = v_6;\n  };\n  if ((num_5 == 5)) {\n    pickVary1.y = v_6;\n  };\n  if ((num_5 == 6)) {\n    pickVary1.z = v_6;\n  };\n  if ((num_5 == 7)) {\n    pickVary1.w = v_6;\n  };\n  if ((num_5 == 8)) {\n    pickVary2.x = v_6;\n  };\n  if ((num_5 == 9)) {\n    pickVary2.y = v_6;\n  };\n  if ((num_5 == 10)) {\n    pickVary2.z = v_6;\n  };\n  if ((num_5 == 11)) {\n    pickVary2.w = v_6;\n  };\n  if ((num_5 == 12)) {\n    pickVary3.x = v_6;\n  };\n  if ((num_5 == 13)) {\n    pickVary3.y = v_6;\n  };\n  if ((num_5 == 14)) {\n    pickVary3.z = v_6;\n  };\n  if ((num_5 == 15)) {\n    pickVary3.w = v_6;\n  };\n  lowp vec3 xmnormal_7;\n  lowp vec3 surfpos_8;\n  float fac_9;\n  float lk_10;\n  lowp float xrscalea_11;\n  float sss_12;\n  float star1_13;\n  vec4 tmpvar_14;\n  vec4 tmpvar_15;\n  tmpvar_14.x = p_2.z;\n  float tmpvar_16;\n  tmpvar_16 = floor(((lennum * capres) * 0.5));\n  float tmpvar_17;\n  tmpvar_17 = (lennum - (2.0 * tmpvar_16));\n  float tmpvar_18;\n  tmpvar_18 = -(tmpvar_16);\n  float tmpvar_19;\n  tmpvar_19 = (tmpvar_18 + (p_2.x * (\n    (tmpvar_17 + tmpvar_16)\n   - tmpvar_18)));\n  float tmpvar_20;\n  tmpvar_20 = clamp ((tmpvar_19 / tmpvar_17), 0.0, 1.0);\n  lowp vec3 rad1a_21;\n  lowp vec3 skela3_22;\n  lowp vec3 step_23;\n  float tmpvar_24;\n  tmpvar_24 = floor((tmpvar_20 * skelnum));\n  float tmpvar_25;\n  tmpvar_25 = ((tmpvar_20 * skelnum) - tmpvar_24);\n  float tmpvar_26;\n  tmpvar_26 = (skelnum + (2.0 * skelends));\n  vec2 tmpvar_27;\n  tmpvar_27.x = (floor((\n    (min (tmpvar_26, (tmpvar_24 - 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_27.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_28;\n  tmpvar_28 = texture2D (skelbuffer, (tmpvar_27 / skelbufferRes));\n  vec2 tmpvar_29;\n  tmpvar_29.x = (floor((\n    (min (tmpvar_26, tmpvar_24) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_29.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_30;\n  tmpvar_30 = texture2D (skelbuffer, (tmpvar_29 / skelbufferRes));\n  vec2 tmpvar_31;\n  tmpvar_31.x = (floor((\n    (min (tmpvar_26, (tmpvar_24 + 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_31.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_32;\n  tmpvar_32 = texture2D (skelbuffer, (tmpvar_31 / skelbufferRes));\n  vec2 tmpvar_33;\n  tmpvar_33.x = (floor((\n    (min (tmpvar_26, (tmpvar_24 + 2.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_33.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_34;\n  tmpvar_34 = texture2D (skelbuffer, (tmpvar_33 / skelbufferRes));\n  lowp vec4 tmpvar_35;\n  tmpvar_35 = (((\n    (-0.5 * tmpvar_28)\n   + \n    (1.5 * tmpvar_30)\n  ) - (1.5 * tmpvar_32)) + (0.5 * tmpvar_34));\n  lowp vec4 tmpvar_36;\n  tmpvar_36 = (((tmpvar_28 - \n    (2.5 * tmpvar_30)\n  ) + (2.0 * tmpvar_32)) - (0.5 * tmpvar_34));\n  lowp vec4 tmpvar_37;\n  tmpvar_37 = ((-0.5 * tmpvar_28) + (0.5 * tmpvar_32));\n  step_23 = (((\n    (3.0 * tmpvar_35)\n   * \n    (tmpvar_25 * tmpvar_25)\n  ) + (\n    (2.0 * tmpvar_36)\n   * tmpvar_25)) + tmpvar_37).xyz;\n  skela3_22 = (((\n    ((tmpvar_35 * tmpvar_25) * (tmpvar_25 * tmpvar_25))\n   + \n    ((tmpvar_36 * tmpvar_25) * tmpvar_25)\n  ) + (tmpvar_37 * tmpvar_25)) + tmpvar_30).xyz;\n  lowp float r_38;\n  vec2 tmpvar_39;\n  tmpvar_39.y = 0.5;\n  tmpvar_39.x = tmpvar_20;\n  lowp vec4 tmpvar_40;\n  tmpvar_40 = texture2D (t_ribbonrad, tmpvar_39);\n  r_38 = (scaleFactor * (R_radius + (tmpvar_40.x * wigmult)));\n  if (((wigmult < 0.0) && (tmpvar_40.x != 0.0))) {\n    r_38 = -0.1;\n  };\n  if ((ribbonPickExtra != 0.0)) {\n    r_38 = (r_38 + (ribbonPickExtra * max (\n      max (max (max (max (\n        max (0.0, (1.0 - (abs(\n          (-999.0 - tmpvar_20)\n        ) / ribbonPickWidth)))\n      , \n        (1.0 - (abs((-999.0 - tmpvar_20)) / ribbonPickWidth))\n      ), (1.0 - \n        (abs((-999.0 - tmpvar_20)) / ribbonPickWidth)\n      )), (1.0 - (\n        abs((-999.0 - tmpvar_20))\n       / ribbonPickWidth))), (1.0 - (abs(\n        (-999.0 - tmpvar_20)\n      ) / ribbonPickWidth)))\n    , \n      (1.0 - (abs((-999.0 - tmpvar_20)) / ribbonPickWidth))\n    )));\n  };\n  float tmpvar_41;\n  tmpvar_41 = abs(((tmpvar_20 * \n    (numSegs + 1.0)\n  ) - killrads[0]));\n  if ((tmpvar_41 <= killradwidth)) {\n    r_38 = -0.1;\n  };\n  float tmpvar_42;\n  tmpvar_42 = abs(((tmpvar_20 * \n    (numSegs + 1.0)\n  ) - killrads[1]));\n  if ((tmpvar_42 <= killradwidth)) {\n    r_38 = -0.1;\n  };\n  float tmpvar_43;\n  tmpvar_43 = abs(((tmpvar_20 * \n    (numSegs + 1.0)\n  ) - killrads[2]));\n  if ((tmpvar_43 <= killradwidth)) {\n    r_38 = -0.1;\n  };\n  float tmpvar_44;\n  tmpvar_44 = abs(((tmpvar_20 * \n    (numSegs + 1.0)\n  ) - killrads[3]));\n  if ((tmpvar_44 <= killradwidth)) {\n    r_38 = -0.1;\n  };\n  float tmpvar_45;\n  tmpvar_45 = (max ((endbloblen - tmpvar_20), (\n    (-1.0 + endbloblen)\n   + tmpvar_20)) / endbloblen);\n  if ((tmpvar_45 > 0.0)) {\n    r_38 = (r_38 * sqrt(max (0.0, \n      (((1.0 + cos(\n        (((1.0 - tmpvar_45) * 6.28318) * endblobs)\n      )) * 0.5) * (1.0 - tmpvar_45))\n    )));\n  };\n  lowp float tmpvar_46;\n  tmpvar_46 = sqrt(dot (step_23, step_23));\n  lowp vec3 tmpvar_47;\n  if ((tmpvar_46 == 0.0)) {\n    tmpvar_47 = vec3(0.0, 1.0, 0.0);\n  } else {\n    tmpvar_47 = (step_23 / tmpvar_46);\n  };\n  lowp vec4 tmpvar_48;\n  tmpvar_48.w = 1.0;\n  tmpvar_48.xyz = skela3_22;\n  if (((tmpvar_46 == 0.0) || (NORMTYPE == 0.0))) {\n    rad1a_21 = vec3(1.0, 0.0, 0.0);\n  } else {\n    if ((NORMTYPE == 1.0)) {\n      rad1a_21 = ((tmpvar_47.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_47.zxy * vec3(1.3, 2.1, 1.0)));\n    } else {\n      if ((NORMTYPE == 2.0)) {\n        float ppx_49;\n        ppx_49 = (tmpvar_20 - 0.09);\n        lowp float z_50;\n        lowp float y_51;\n        lowp float x_52;\n        float tmpvar_53;\n        tmpvar_53 = (((R_active * ppx_49) + R_rpbase) + (dot (R_para, tmpvar_14) + dot (R_parb, tmpvar_15)));\n        vec2 tmpvar_54;\n        tmpvar_54.x = 0.5;\n        tmpvar_54.y = (((ppx_49 * numSegs) + 0.5) / numInstancesP2);\n        lowp vec4 tmpvar_55;\n        tmpvar_55 = (texture2D (posNewvals, tmpvar_54) * scaleFactor);\n        lowp vec4 tmpvar_56;\n        tmpvar_56 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n        x_52 = (tmpvar_55.x - tmpvar_56.x);\n        y_51 = (tmpvar_55.y - tmpvar_56.y);\n        z_50 = (tmpvar_55.z - tmpvar_56.z);\n        highp int num_57;\n        num_57 = (2 + pickxslot);\n        if ((num_57 == 0)) {\n          pickVary0.x = tmpvar_53;\n        };\n        if ((num_57 == 1)) {\n          pickVary0.y = tmpvar_53;\n        };\n        if ((num_57 == 2)) {\n          pickVary0.z = tmpvar_53;\n        };\n        if ((num_57 == 3)) {\n          pickVary0.w = tmpvar_53;\n        };\n        if ((num_57 == 4)) {\n          pickVary1.x = tmpvar_53;\n        };\n        if ((num_57 == 5)) {\n          pickVary1.y = tmpvar_53;\n        };\n        if ((num_57 == 6)) {\n          pickVary1.z = tmpvar_53;\n        };\n        if ((num_57 == 7)) {\n          pickVary1.w = tmpvar_53;\n        };\n        if ((num_57 == 8)) {\n          pickVary2.x = tmpvar_53;\n        };\n        if ((num_57 == 9)) {\n          pickVary2.y = tmpvar_53;\n        };\n        if ((num_57 == 10)) {\n          pickVary2.z = tmpvar_53;\n        };\n        if ((num_57 == 11)) {\n          pickVary2.w = tmpvar_53;\n        };\n        if ((num_57 == 12)) {\n          pickVary3.x = tmpvar_53;\n        };\n        if ((num_57 == 13)) {\n          pickVary3.y = tmpvar_53;\n        };\n        if ((num_57 == 14)) {\n          pickVary3.z = tmpvar_53;\n        };\n        if ((num_57 == 15)) {\n          pickVary3.w = tmpvar_53;\n        };\n        lowp vec4 tmpvar_58;\n        tmpvar_58.x = x_52;\n        tmpvar_58.y = y_51;\n        tmpvar_58.z = z_50;\n        tmpvar_58.w = 1.0;\n        lowp vec3 b_59;\n        b_59 = (tmpvar_58.xyz - skela3_22);\n        rad1a_21 = ((tmpvar_47.yzx * b_59.zxy) - (tmpvar_47.zxy * b_59.yzx));\n      } else {\n        if ((NORMTYPE == 3.0)) {\n          float ppx_60;\n          ppx_60 = (tmpvar_20 - 0.09);\n          lowp float z_61;\n          lowp float y_62;\n          lowp float x_63;\n          float tmpvar_64;\n          tmpvar_64 = (((R_active * ppx_60) + R_rpbase) + (dot (R_para, tmpvar_14) + dot (R_parb, tmpvar_15)));\n          vec2 tmpvar_65;\n          tmpvar_65.x = 0.5;\n          tmpvar_65.y = (((ppx_60 * numSegs) + 0.5) / numInstancesP2);\n          lowp vec4 tmpvar_66;\n          tmpvar_66 = (texture2D (posNewvals, tmpvar_65) * scaleFactor);\n          lowp vec4 tmpvar_67;\n          tmpvar_67 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n          x_63 = (tmpvar_66.x - tmpvar_67.x);\n          y_62 = (tmpvar_66.y - tmpvar_67.y);\n          z_61 = (tmpvar_66.z - tmpvar_67.z);\n          highp int num_68;\n          num_68 = (2 + pickxslot);\n          if ((num_68 == 0)) {\n            pickVary0.x = tmpvar_64;\n          };\n          if ((num_68 == 1)) {\n            pickVary0.y = tmpvar_64;\n          };\n          if ((num_68 == 2)) {\n            pickVary0.z = tmpvar_64;\n          };\n          if ((num_68 == 3)) {\n            pickVary0.w = tmpvar_64;\n          };\n          if ((num_68 == 4)) {\n            pickVary1.x = tmpvar_64;\n          };\n          if ((num_68 == 5)) {\n            pickVary1.y = tmpvar_64;\n          };\n          if ((num_68 == 6)) {\n            pickVary1.z = tmpvar_64;\n          };\n          if ((num_68 == 7)) {\n            pickVary1.w = tmpvar_64;\n          };\n          if ((num_68 == 8)) {\n            pickVary2.x = tmpvar_64;\n          };\n          if ((num_68 == 9)) {\n            pickVary2.y = tmpvar_64;\n          };\n          if ((num_68 == 10)) {\n            pickVary2.z = tmpvar_64;\n          };\n          if ((num_68 == 11)) {\n            pickVary2.w = tmpvar_64;\n          };\n          if ((num_68 == 12)) {\n            pickVary3.x = tmpvar_64;\n          };\n          if ((num_68 == 13)) {\n            pickVary3.y = tmpvar_64;\n          };\n          if ((num_68 == 14)) {\n            pickVary3.z = tmpvar_64;\n          };\n          if ((num_68 == 15)) {\n            pickVary3.w = tmpvar_64;\n          };\n          lowp vec4 tmpvar_69;\n          tmpvar_69.x = x_63;\n          tmpvar_69.y = y_62;\n          tmpvar_69.z = z_61;\n          tmpvar_69.w = 1.0;\n          lowp vec3 tmpvar_70;\n          lowp vec3 b_71;\n          b_71 = (tmpvar_69.xyz - skela3_22);\n          tmpvar_70 = ((tmpvar_47.yzx * b_71.zxy) - (tmpvar_47.zxy * b_71.yzx));\n          rad1a_21 = tmpvar_70;\n          lowp float tmpvar_72;\n          tmpvar_72 = dot (tmpvar_70, tmpvar_70);\n          if ((tmpvar_72 < 1e-6)) {\n            rad1a_21 = ((tmpvar_47.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_47.zxy * vec3(1.3, 2.1, 1.0)));\n          };\n        } else {\n          if ((NORMTYPE == 4.0)) {\n            lowp float z_73;\n            lowp float y_74;\n            lowp float x_75;\n            float tmpvar_76;\n            tmpvar_76 = (((R_active * tmpvar_20) + R_rpbase) + (dot (R_para, tmpvar_14) + dot (R_parb, tmpvar_15)));\n            vec2 tmpvar_77;\n            tmpvar_77.x = 0.5;\n            tmpvar_77.y = (((tmpvar_20 * numSegs) + 0.5) / numInstancesP2);\n            lowp vec4 tmpvar_78;\n            tmpvar_78 = (texture2D (posNewvals, tmpvar_77) * scaleFactor);\n            x_75 = (0.013 + tmpvar_78.x);\n            z_73 = (0.017 + tmpvar_78.z);\n            lowp vec4 tmpvar_79;\n            tmpvar_79 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n            x_75 = (x_75 - tmpvar_79.x);\n            y_74 = (tmpvar_78.y - tmpvar_79.y);\n            z_73 = (z_73 - tmpvar_79.z);\n            highp int num_80;\n            num_80 = (2 + pickxslot);\n            if ((num_80 == 0)) {\n              pickVary0.x = tmpvar_76;\n            };\n            if ((num_80 == 1)) {\n              pickVary0.y = tmpvar_76;\n            };\n            if ((num_80 == 2)) {\n              pickVary0.z = tmpvar_76;\n            };\n            if ((num_80 == 3)) {\n              pickVary0.w = tmpvar_76;\n            };\n            if ((num_80 == 4)) {\n              pickVary1.x = tmpvar_76;\n            };\n            if ((num_80 == 5)) {\n              pickVary1.y = tmpvar_76;\n            };\n            if ((num_80 == 6)) {\n              pickVary1.z = tmpvar_76;\n            };\n            if ((num_80 == 7)) {\n              pickVary1.w = tmpvar_76;\n            };\n            if ((num_80 == 8)) {\n              pickVary2.x = tmpvar_76;\n            };\n            if ((num_80 == 9)) {\n              pickVary2.y = tmpvar_76;\n            };\n            if ((num_80 == 10)) {\n              pickVary2.z = tmpvar_76;\n            };\n            if ((num_80 == 11)) {\n              pickVary2.w = tmpvar_76;\n            };\n            if ((num_80 == 12)) {\n              pickVary3.x = tmpvar_76;\n            };\n            if ((num_80 == 13)) {\n              pickVary3.y = tmpvar_76;\n            };\n            if ((num_80 == 14)) {\n              pickVary3.z = tmpvar_76;\n            };\n            if ((num_80 == 15)) {\n              pickVary3.w = tmpvar_76;\n            };\n            lowp vec4 tmpvar_81;\n            tmpvar_81.x = x_75;\n            tmpvar_81.y = y_74;\n            tmpvar_81.z = z_73;\n            tmpvar_81.w = 1.0;\n            lowp vec3 b_82;\n            b_82 = (tmpvar_81.xyz - skela3_22);\n            rad1a_21 = ((tmpvar_47.yzx * b_82.zxy) - (tmpvar_47.zxy * b_82.yzx));\n          } else {\n            if ((NORMTYPE == 5.0)) {\n              mat3 tmpvar_83;\n              tmpvar_83[0] = rot4[0].xyz;\n              tmpvar_83[1] = rot4[1].xyz;\n              tmpvar_83[2] = rot4[2].xyz;\n              lowp vec3 tmpvar_84;\n              tmpvar_84 = normalize((tmpvar_83 * (clearposA0 - \n                (tmpvar_48 * rot4)\n              .xyz)));\n              rad1a_21 = ((tmpvar_84.yzx * tmpvar_47.zxy) - (tmpvar_84.zxy * tmpvar_47.yzx));\n            } else {\n              if ((NORMTYPE == 6.0)) {\n                rad1a_21 = ((awayvec.yzx * tmpvar_47.zxy) - (awayvec.zxy * tmpvar_47.yzx));\n              } else {\n                rad1a_21 = vec3(0.0, 0.0, 1.0);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  float tmpvar_85;\n  tmpvar_85 = (p_2.y * nstar);\n  star1_13 = tmpvar_85;\n  sss_12 = 1.0;\n  float tmpvar_86;\n  tmpvar_86 = floor(nstar);\n  if ((tmpvar_85 > tmpvar_86)) {\n    float tmpvar_87;\n    tmpvar_87 = fract(nstar);\n    sss_12 = tmpvar_87;\n    float tmpvar_88;\n    tmpvar_88 = floor(nstar);\n    star1_13 = (tmpvar_88 + ((tmpvar_85 - tmpvar_88) / tmpvar_87));\n  };\n  lowp float tmpvar_89;\n  tmpvar_89 = (r_38 * (1.0 - (\n    (1.0 - (((1.0 - \n      cos((6.28318 * star1_13))\n    ) * sss_12) * sss_12))\n   * stardepth)));\n  xrscalea_11 = tmpvar_89;\n  lk_10 = 0.0;\n  fac_9 = 1.0;\n  if (((0.0 < tmpvar_19) && (tmpvar_19 < tmpvar_17))) {\n    lk_10 = ((p_2.x * ribs) + 0.5);\n    float tmpvar_90;\n    tmpvar_90 = abs((fract(lk_10) - 0.5));\n    lk_10 = tmpvar_90;\n    float tmpvar_91;\n    tmpvar_91 = sqrt((1.0 - (\n      (ribdepth * tmpvar_90)\n     * tmpvar_90)));\n    fac_9 = tmpvar_91;\n    xrscalea_11 = (tmpvar_89 * tmpvar_91);\n  };\n  lowp vec3 tmpvar_92;\n  tmpvar_92 = normalize(rad1a_21);\n  xmnormal_7 = ((-(\n    sin((6.28318 * p_2.y))\n  ) * -(\n    normalize(((tmpvar_47.yzx * tmpvar_92.zxy) - (tmpvar_47.zxy * tmpvar_92.yzx)))\n  )) + (cos(\n    (6.28318 * p_2.y)\n  ) * tmpvar_92));\n  surfpos_8 = (skela3_22 + (xrscalea_11 * xmnormal_7));\n  xmnormal_7 = (xmnormal_7 + (tmpvar_47 * (\n    (ribdepth * lk_10)\n   / fac_9)));\n  lowp vec3 tmpvar_93;\n  tmpvar_93 = normalize(xmnormal_7);\n  xmnormal_7 = tmpvar_93;\n  if ((tmpvar_19 > tmpvar_17)) {\n    float tmpvar_94;\n    tmpvar_94 = (((\n      (tmpvar_19 - tmpvar_17)\n     / tmpvar_16) * 3.14159) / 2.0);\n    surfpos_8 = (skela3_22 + (xrscalea_11 * (\n      (sin(tmpvar_94) * tmpvar_47)\n     + \n      (cos(tmpvar_94) * tmpvar_93)\n    )));\n  };\n  if ((tmpvar_19 < 0.0)) {\n    float tmpvar_95;\n    tmpvar_95 = (((tmpvar_19 / tmpvar_16) * 3.14159) / 2.0);\n    surfpos_8 = (skela3_22 + (xrscalea_11 * (\n      (sin(tmpvar_95) * tmpvar_47)\n     + \n      (cos(tmpvar_95) * tmpvar_93)\n    )));\n  };\n  xmnormal_7 = tmpvar_93;\n  lowp vec4 tmpvar_96;\n  tmpvar_96.xyz = surfpos_8;\n  tmpvar_96.w = 1.0;\n  gl_PointSize = pointSize;\n  lowp vec4 tmpvar_97;\n  tmpvar_97.w = 1.0;\n  tmpvar_97.xyz = (tmpvar_96 * rot4).xyz;\n  ooo_1 = (projectionMatrix * (modelViewMatrix * tmpvar_97));\n  lowp vec4 ooo_98;\n  ooo_98 = ooo_1;\n  if ((USELOGDEPTH > 0.0)) {\n    ooo_98.xy = (ooo_1.xy / ooo_1.w);\n    ooo_98.w = 1.0;\n    ooo_98.z = (((\n      (log(ooo_1.w) - _camd.z)\n     * _camd.w) * 2.0) - 1.0);\n  } else {\n    if ((USELOGDEPTH < 0.0)) {\n      ooo_98.z = (log2(max (1e-6, \n        (ooo_98.w + 1.0)\n      )) * 0.15);\n      ooo_98.z = ((ooo_98.z - 1.0) * ooo_98.w);\n    };\n  };\n  ooo_1 = ooo_98;\n  gl_Position = ooo_98;\n}\n\n"},"horn(\"R\").ribs(#R_ribs#).radius(#R_radius#).code(\"vec4 q=ppos((rp*numSegs + 0.5)/numInstancesP2)*scaleFactor; x+=q.x; y+=q.y; z+=q.z;\").code(\"#define SKELPICK\");\nmainhorn=\"R\";\n\noverride float skelrad(float r, float rp, float oposz) {\n  // note no sqrt for wig, already arranged in layout of the textre\n  float wigg = texture2D(t_ribbonrad, vec2(rp, 0.5)).x;\n  r = scaleFactor * (R_radius +  wigg * wigmult);\n  if (wigmult < 0. && wigg != 0.) r = -0.1;\n\n  // boost radius for pick item i\n  #define xrad(i) {     float p = getPickC(i);    float xtra = 1. - abs(p-rp) / ribbonPickWidth;    rx = max(rx, xtra);  }\n  // boost ribbon radius based on matrix picks\n  //PJT adding other pick slots (0 & 8), as per VALID_PICK_INDEX\n  if (ribbonPickExtra != 0.) {\n    float rx = 0.;\n    xrad(0) xrad(4) xrad(5) xrad(8) xrad(12) xrad(13)\n    r += ribbonPickExtra * rx;\n  }\n\n  // killrads in particles\n  for (int i=0; i < KILLRADLEN; i++)\n    if (abs(rp * (numSegs + 1.) - killrads[i]) <= killradwidth) r = -0.1;\n\n  float pi = 3.141592;\n  float tr = max(endbloblen-rp, -1. + endbloblen + rp)/endbloblen;\n  if (tr > 0.) { float dr = max(0.00, (1. + cos( (1.-tr) * 6.28318 * endblobs)) * 0.5 * (1.- tr)); r *= sqrt(dr); }\n  return r;\n}\n\noverride Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n    Colsurf cs = colsurfd();\n    float p = opos.x;\n    // vec3 rbow = vec3(p,1.-p,0); // rainbow colouring, also to verify opos.x correct\n    // TODO use bedColor from commonFragmentShaderCode\n    vec3 rbow = hsv2rgb(vec3(p, 1., 1.));\n\n    //vec3 col = cs.col.rgb;\n    // using opos.x instead of p below gives wrong answers!\n    // Maybe compiler can't cope with texture call within texture call? opos is macro for texture call\n    vec4 bed = texture2D(t_ribboncol, vec2(p, 0.5));\n    float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n    float ti = t * 255. - 0.0;\n    // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n    // but close enough for now (famous last words), closer with test against green as well\n    vec3 col = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n    // for helix striping\n    // if (fract(opos.x*5000. + opos.y) < 0.1) col = stdcol(6.);\n    col = mix(col, rbow, colmix);\n\n    // now overlay preselection highlights\n    float op = (opos.x - capres*0.5) / (1. - capres);\n    for (int i=0; i<16; i++) {\n      //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n      if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 )) continue;\n      float p = getPickC(i);\n      float k = 10. * (1. - clamp(abs(op-p) * 400., 0., 1.));\n      float k1 = abs(op-p) * 14000. < 1. ? 0. : k;\n      col += vec3(k,k1,k1) * getPickColor(i)*0.1;\n    }\n\n    cs.col.rgb = col;\n    return cs;\n}\n\n//over ride vec4 lightingxNOT(const vec3 xmnormal, const vec4 trpos, const vec3 texpos) {\n//    // needs usemask = -1; mmm = material.regular[G.tranrule];  mmm.transparent=true; mmm.side = THREE.DoubleSide\n//    vec4 col = lightingx_base(xmnormal, trpos, texpos);\n//    if (fract(opos.x*5000. + opos.y) > 0.1) col.a = 0.2;\n//    return col;\n//}\n\n":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nvarying vec4 pickVary0;\nvarying vec4 pickVary1;\nvarying vec4 pickVary2;\nvarying vec4 pickVary3;\nvoid main ()\n{\n  highp int tmpvar_1;\n  tmpvar_1 = int(floor(gl_FragCoord.x));\n  mediump vec4 tmpvar_2;\n  if ((tmpvar_1 == 0)) {\n    tmpvar_2 = pickVary0;\n  } else {\n    mediump vec4 tmpvar_3;\n    if ((tmpvar_1 == 1)) {\n      tmpvar_3 = pickVary1;\n    } else {\n      mediump vec4 tmpvar_4;\n      if ((tmpvar_1 == 2)) {\n        tmpvar_4 = pickVary2;\n      } else {\n        tmpvar_4 = pickVary3;\n      };\n      tmpvar_3 = tmpvar_4;\n    };\n    tmpvar_2 = tmpvar_3;\n  };\n  gl_FragColor = tmpvar_2;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform sampler2D t_ribbonrad;\nuniform float killrads[4];\nuniform vec3 awayvec;\nuniform vec4 _camd;\nuniform vec3 clearposA0;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nfloat ribs;\nuniform float nstar;\nuniform float stardepth;\nuniform float ribdepth;\nuniform float R_ribs;\nuniform float R_radius;\nfloat R_active;\nfloat R_rpbase;\nvec4 R_para;\nvec4 R_parb;\nuniform float cumcount3;\nuniform float wigmult;\nuniform float scaleFactor;\nuniform float ribbonPickWidth;\nuniform float ribbonPickExtra;\nuniform float endblobs;\nuniform float endbloblen;\nuniform float killradwidth;\nuniform mat4 rot4;\nuniform float pointSize;\nattribute float instanceID;\nuniform float fakeinstanceID;\nuniform float capres;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nvarying vec4 pickVary0;\nvarying vec4 pickVary1;\nvarying vec4 pickVary2;\nvarying vec4 pickVary3;\nuniform highp int pickxslot;\nuniform float lennum;\nuniform float skelnum;\nuniform float skelends;\nuniform vec2 skelbufferRes;\nuniform sampler2D skelbuffer;\nuniform sampler2D scaleDampTarget;\nuniform float NORMTYPE;\nuniform float USELOGDEPTH;\nvoid main ()\n{\n  lowp vec4 ooo_1;\n  vec4 p_2;\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xy = position.xy;\n  tmpvar_3.z = (instanceID + fakeinstanceID);\n  p_2.zw = tmpvar_3.zw;\n  p_2.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_2.y = (p_2.y * 0.5);\n  };\n  if ((tmpvar_3.z < cumcount3)) {\n    ribs = R_ribs;\n  } else {\n    ribs = 77.0;\n  };\n  pickVary0 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary1 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary2 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary3 = vec4(999.0, 999.0, 999.0, 999.0);\n  float v_4;\n  v_4 = p_2.x;\n  if ((pickxslot == 0)) {\n    pickVary0.x = v_4;\n  };\n  if ((pickxslot == 1)) {\n    pickVary0.y = v_4;\n  };\n  if ((pickxslot == 2)) {\n    pickVary0.z = v_4;\n  };\n  if ((pickxslot == 3)) {\n    pickVary0.w = v_4;\n  };\n  if ((pickxslot == 4)) {\n    pickVary1.x = v_4;\n  };\n  if ((pickxslot == 5)) {\n    pickVary1.y = v_4;\n  };\n  if ((pickxslot == 6)) {\n    pickVary1.z = v_4;\n  };\n  if ((pickxslot == 7)) {\n    pickVary1.w = v_4;\n  };\n  if ((pickxslot == 8)) {\n    pickVary2.x = v_4;\n  };\n  if ((pickxslot == 9)) {\n    pickVary2.y = v_4;\n  };\n  if ((pickxslot == 10)) {\n    pickVary2.z = v_4;\n  };\n  if ((pickxslot == 11)) {\n    pickVary2.w = v_4;\n  };\n  if ((pickxslot == 12)) {\n    pickVary3.x = v_4;\n  };\n  if ((pickxslot == 13)) {\n    pickVary3.y = v_4;\n  };\n  if ((pickxslot == 14)) {\n    pickVary3.z = v_4;\n  };\n  if ((pickxslot == 15)) {\n    pickVary3.w = v_4;\n  };\n  highp int num_5;\n  float v_6;\n  v_6 = p_2.y;\n  num_5 = (1 + pickxslot);\n  if ((num_5 == 0)) {\n    pickVary0.x = v_6;\n  };\n  if ((num_5 == 1)) {\n    pickVary0.y = v_6;\n  };\n  if ((num_5 == 2)) {\n    pickVary0.z = v_6;\n  };\n  if ((num_5 == 3)) {\n    pickVary0.w = v_6;\n  };\n  if ((num_5 == 4)) {\n    pickVary1.x = v_6;\n  };\n  if ((num_5 == 5)) {\n    pickVary1.y = v_6;\n  };\n  if ((num_5 == 6)) {\n    pickVary1.z = v_6;\n  };\n  if ((num_5 == 7)) {\n    pickVary1.w = v_6;\n  };\n  if ((num_5 == 8)) {\n    pickVary2.x = v_6;\n  };\n  if ((num_5 == 9)) {\n    pickVary2.y = v_6;\n  };\n  if ((num_5 == 10)) {\n    pickVary2.z = v_6;\n  };\n  if ((num_5 == 11)) {\n    pickVary2.w = v_6;\n  };\n  if ((num_5 == 12)) {\n    pickVary3.x = v_6;\n  };\n  if ((num_5 == 13)) {\n    pickVary3.y = v_6;\n  };\n  if ((num_5 == 14)) {\n    pickVary3.z = v_6;\n  };\n  if ((num_5 == 15)) {\n    pickVary3.w = v_6;\n  };\n  lowp vec3 xmnormal_7;\n  lowp vec3 surfpos_8;\n  float fac_9;\n  float lk_10;\n  lowp float xrscalea_11;\n  float sss_12;\n  float star1_13;\n  vec4 tmpvar_14;\n  vec4 tmpvar_15;\n  tmpvar_14.x = p_2.z;\n  float tmpvar_16;\n  tmpvar_16 = floor(((lennum * capres) * 0.5));\n  float tmpvar_17;\n  tmpvar_17 = (lennum - (2.0 * tmpvar_16));\n  float tmpvar_18;\n  tmpvar_18 = -(tmpvar_16);\n  float tmpvar_19;\n  tmpvar_19 = (tmpvar_18 + (p_2.x * (\n    (tmpvar_17 + tmpvar_16)\n   - tmpvar_18)));\n  float tmpvar_20;\n  tmpvar_20 = clamp ((tmpvar_19 / tmpvar_17), 0.0, 1.0);\n  lowp vec3 rad1a_21;\n  lowp vec3 skela3_22;\n  lowp vec3 step_23;\n  float tmpvar_24;\n  tmpvar_24 = floor((tmpvar_20 * skelnum));\n  float tmpvar_25;\n  tmpvar_25 = ((tmpvar_20 * skelnum) - tmpvar_24);\n  float tmpvar_26;\n  tmpvar_26 = (skelnum + (2.0 * skelends));\n  vec2 tmpvar_27;\n  tmpvar_27.x = (floor((\n    (min (tmpvar_26, (tmpvar_24 - 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_27.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_28;\n  tmpvar_28 = texture2D (skelbuffer, (tmpvar_27 / skelbufferRes));\n  vec2 tmpvar_29;\n  tmpvar_29.x = (floor((\n    (min (tmpvar_26, tmpvar_24) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_29.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_30;\n  tmpvar_30 = texture2D (skelbuffer, (tmpvar_29 / skelbufferRes));\n  vec2 tmpvar_31;\n  tmpvar_31.x = (floor((\n    (min (tmpvar_26, (tmpvar_24 + 1.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_31.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_32;\n  tmpvar_32 = texture2D (skelbuffer, (tmpvar_31 / skelbufferRes));\n  vec2 tmpvar_33;\n  tmpvar_33.x = (floor((\n    (min (tmpvar_26, (tmpvar_24 + 2.0)) + skelends)\n   + 0.5)) + 0.5);\n  tmpvar_33.y = (tmpvar_3.z + 0.5);\n  lowp vec4 tmpvar_34;\n  tmpvar_34 = texture2D (skelbuffer, (tmpvar_33 / skelbufferRes));\n  lowp vec4 tmpvar_35;\n  tmpvar_35 = (((\n    (-0.5 * tmpvar_28)\n   + \n    (1.5 * tmpvar_30)\n  ) - (1.5 * tmpvar_32)) + (0.5 * tmpvar_34));\n  lowp vec4 tmpvar_36;\n  tmpvar_36 = (((tmpvar_28 - \n    (2.5 * tmpvar_30)\n  ) + (2.0 * tmpvar_32)) - (0.5 * tmpvar_34));\n  lowp vec4 tmpvar_37;\n  tmpvar_37 = ((-0.5 * tmpvar_28) + (0.5 * tmpvar_32));\n  step_23 = (((\n    (3.0 * tmpvar_35)\n   * \n    (tmpvar_25 * tmpvar_25)\n  ) + (\n    (2.0 * tmpvar_36)\n   * tmpvar_25)) + tmpvar_37).xyz;\n  skela3_22 = (((\n    ((tmpvar_35 * tmpvar_25) * (tmpvar_25 * tmpvar_25))\n   + \n    ((tmpvar_36 * tmpvar_25) * tmpvar_25)\n  ) + (tmpvar_37 * tmpvar_25)) + tmpvar_30).xyz;\n  lowp float r_38;\n  vec2 tmpvar_39;\n  tmpvar_39.y = 0.5;\n  tmpvar_39.x = tmpvar_20;\n  lowp vec4 tmpvar_40;\n  tmpvar_40 = texture2D (t_ribbonrad, tmpvar_39);\n  r_38 = (scaleFactor * (R_radius + (tmpvar_40.x * wigmult)));\n  if (((wigmult < 0.0) && (tmpvar_40.x != 0.0))) {\n    r_38 = -0.1;\n  };\n  if ((ribbonPickExtra != 0.0)) {\n    r_38 = (r_38 + (ribbonPickExtra * max (\n      max (max (max (max (\n        max (0.0, (1.0 - (abs(\n          (-999.0 - tmpvar_20)\n        ) / ribbonPickWidth)))\n      , \n        (1.0 - (abs((-999.0 - tmpvar_20)) / ribbonPickWidth))\n      ), (1.0 - \n        (abs((-999.0 - tmpvar_20)) / ribbonPickWidth)\n      )), (1.0 - (\n        abs((-999.0 - tmpvar_20))\n       / ribbonPickWidth))), (1.0 - (abs(\n        (-999.0 - tmpvar_20)\n      ) / ribbonPickWidth)))\n    , \n      (1.0 - (abs((-999.0 - tmpvar_20)) / ribbonPickWidth))\n    )));\n  };\n  float tmpvar_41;\n  tmpvar_41 = abs(((tmpvar_20 * \n    (numSegs + 1.0)\n  ) - killrads[0]));\n  if ((tmpvar_41 <= killradwidth)) {\n    r_38 = -0.1;\n  };\n  float tmpvar_42;\n  tmpvar_42 = abs(((tmpvar_20 * \n    (numSegs + 1.0)\n  ) - killrads[1]));\n  if ((tmpvar_42 <= killradwidth)) {\n    r_38 = -0.1;\n  };\n  float tmpvar_43;\n  tmpvar_43 = abs(((tmpvar_20 * \n    (numSegs + 1.0)\n  ) - killrads[2]));\n  if ((tmpvar_43 <= killradwidth)) {\n    r_38 = -0.1;\n  };\n  float tmpvar_44;\n  tmpvar_44 = abs(((tmpvar_20 * \n    (numSegs + 1.0)\n  ) - killrads[3]));\n  if ((tmpvar_44 <= killradwidth)) {\n    r_38 = -0.1;\n  };\n  float tmpvar_45;\n  tmpvar_45 = (max ((endbloblen - tmpvar_20), (\n    (-1.0 + endbloblen)\n   + tmpvar_20)) / endbloblen);\n  if ((tmpvar_45 > 0.0)) {\n    r_38 = (r_38 * sqrt(max (0.0, \n      (((1.0 + cos(\n        (((1.0 - tmpvar_45) * 6.28318) * endblobs)\n      )) * 0.5) * (1.0 - tmpvar_45))\n    )));\n  };\n  lowp float tmpvar_46;\n  tmpvar_46 = sqrt(dot (step_23, step_23));\n  lowp vec3 tmpvar_47;\n  if ((tmpvar_46 == 0.0)) {\n    tmpvar_47 = vec3(0.0, 1.0, 0.0);\n  } else {\n    tmpvar_47 = (step_23 / tmpvar_46);\n  };\n  lowp vec4 tmpvar_48;\n  tmpvar_48.w = 1.0;\n  tmpvar_48.xyz = skela3_22;\n  if (((tmpvar_46 == 0.0) || (NORMTYPE == 0.0))) {\n    rad1a_21 = vec3(1.0, 0.0, 0.0);\n  } else {\n    if ((NORMTYPE == 1.0)) {\n      rad1a_21 = ((tmpvar_47.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_47.zxy * vec3(1.3, 2.1, 1.0)));\n    } else {\n      if ((NORMTYPE == 2.0)) {\n        float ppx_49;\n        ppx_49 = (tmpvar_20 - 0.09);\n        lowp float z_50;\n        lowp float y_51;\n        lowp float x_52;\n        float tmpvar_53;\n        tmpvar_53 = (((R_active * ppx_49) + R_rpbase) + (dot (R_para, tmpvar_14) + dot (R_parb, tmpvar_15)));\n        vec2 tmpvar_54;\n        tmpvar_54.x = 0.5;\n        tmpvar_54.y = (((ppx_49 * numSegs) + 0.5) / numInstancesP2);\n        lowp vec4 tmpvar_55;\n        tmpvar_55 = (texture2D (posNewvals, tmpvar_54) * scaleFactor);\n        lowp vec4 tmpvar_56;\n        tmpvar_56 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n        x_52 = (tmpvar_55.x - tmpvar_56.x);\n        y_51 = (tmpvar_55.y - tmpvar_56.y);\n        z_50 = (tmpvar_55.z - tmpvar_56.z);\n        highp int num_57;\n        num_57 = (2 + pickxslot);\n        if ((num_57 == 0)) {\n          pickVary0.x = tmpvar_53;\n        };\n        if ((num_57 == 1)) {\n          pickVary0.y = tmpvar_53;\n        };\n        if ((num_57 == 2)) {\n          pickVary0.z = tmpvar_53;\n        };\n        if ((num_57 == 3)) {\n          pickVary0.w = tmpvar_53;\n        };\n        if ((num_57 == 4)) {\n          pickVary1.x = tmpvar_53;\n        };\n        if ((num_57 == 5)) {\n          pickVary1.y = tmpvar_53;\n        };\n        if ((num_57 == 6)) {\n          pickVary1.z = tmpvar_53;\n        };\n        if ((num_57 == 7)) {\n          pickVary1.w = tmpvar_53;\n        };\n        if ((num_57 == 8)) {\n          pickVary2.x = tmpvar_53;\n        };\n        if ((num_57 == 9)) {\n          pickVary2.y = tmpvar_53;\n        };\n        if ((num_57 == 10)) {\n          pickVary2.z = tmpvar_53;\n        };\n        if ((num_57 == 11)) {\n          pickVary2.w = tmpvar_53;\n        };\n        if ((num_57 == 12)) {\n          pickVary3.x = tmpvar_53;\n        };\n        if ((num_57 == 13)) {\n          pickVary3.y = tmpvar_53;\n        };\n        if ((num_57 == 14)) {\n          pickVary3.z = tmpvar_53;\n        };\n        if ((num_57 == 15)) {\n          pickVary3.w = tmpvar_53;\n        };\n        lowp vec4 tmpvar_58;\n        tmpvar_58.x = x_52;\n        tmpvar_58.y = y_51;\n        tmpvar_58.z = z_50;\n        tmpvar_58.w = 1.0;\n        lowp vec3 b_59;\n        b_59 = (tmpvar_58.xyz - skela3_22);\n        rad1a_21 = ((tmpvar_47.yzx * b_59.zxy) - (tmpvar_47.zxy * b_59.yzx));\n      } else {\n        if ((NORMTYPE == 3.0)) {\n          float ppx_60;\n          ppx_60 = (tmpvar_20 - 0.09);\n          lowp float z_61;\n          lowp float y_62;\n          lowp float x_63;\n          float tmpvar_64;\n          tmpvar_64 = (((R_active * ppx_60) + R_rpbase) + (dot (R_para, tmpvar_14) + dot (R_parb, tmpvar_15)));\n          vec2 tmpvar_65;\n          tmpvar_65.x = 0.5;\n          tmpvar_65.y = (((ppx_60 * numSegs) + 0.5) / numInstancesP2);\n          lowp vec4 tmpvar_66;\n          tmpvar_66 = (texture2D (posNewvals, tmpvar_65) * scaleFactor);\n          lowp vec4 tmpvar_67;\n          tmpvar_67 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n          x_63 = (tmpvar_66.x - tmpvar_67.x);\n          y_62 = (tmpvar_66.y - tmpvar_67.y);\n          z_61 = (tmpvar_66.z - tmpvar_67.z);\n          highp int num_68;\n          num_68 = (2 + pickxslot);\n          if ((num_68 == 0)) {\n            pickVary0.x = tmpvar_64;\n          };\n          if ((num_68 == 1)) {\n            pickVary0.y = tmpvar_64;\n          };\n          if ((num_68 == 2)) {\n            pickVary0.z = tmpvar_64;\n          };\n          if ((num_68 == 3)) {\n            pickVary0.w = tmpvar_64;\n          };\n          if ((num_68 == 4)) {\n            pickVary1.x = tmpvar_64;\n          };\n          if ((num_68 == 5)) {\n            pickVary1.y = tmpvar_64;\n          };\n          if ((num_68 == 6)) {\n            pickVary1.z = tmpvar_64;\n          };\n          if ((num_68 == 7)) {\n            pickVary1.w = tmpvar_64;\n          };\n          if ((num_68 == 8)) {\n            pickVary2.x = tmpvar_64;\n          };\n          if ((num_68 == 9)) {\n            pickVary2.y = tmpvar_64;\n          };\n          if ((num_68 == 10)) {\n            pickVary2.z = tmpvar_64;\n          };\n          if ((num_68 == 11)) {\n            pickVary2.w = tmpvar_64;\n          };\n          if ((num_68 == 12)) {\n            pickVary3.x = tmpvar_64;\n          };\n          if ((num_68 == 13)) {\n            pickVary3.y = tmpvar_64;\n          };\n          if ((num_68 == 14)) {\n            pickVary3.z = tmpvar_64;\n          };\n          if ((num_68 == 15)) {\n            pickVary3.w = tmpvar_64;\n          };\n          lowp vec4 tmpvar_69;\n          tmpvar_69.x = x_63;\n          tmpvar_69.y = y_62;\n          tmpvar_69.z = z_61;\n          tmpvar_69.w = 1.0;\n          lowp vec3 tmpvar_70;\n          lowp vec3 b_71;\n          b_71 = (tmpvar_69.xyz - skela3_22);\n          tmpvar_70 = ((tmpvar_47.yzx * b_71.zxy) - (tmpvar_47.zxy * b_71.yzx));\n          rad1a_21 = tmpvar_70;\n          lowp float tmpvar_72;\n          tmpvar_72 = dot (tmpvar_70, tmpvar_70);\n          if ((tmpvar_72 < 1e-6)) {\n            rad1a_21 = ((tmpvar_47.yzx * vec3(2.1, 1.0, 1.3)) - (tmpvar_47.zxy * vec3(1.3, 2.1, 1.0)));\n          };\n        } else {\n          if ((NORMTYPE == 4.0)) {\n            lowp float z_73;\n            lowp float y_74;\n            lowp float x_75;\n            float tmpvar_76;\n            tmpvar_76 = (((R_active * tmpvar_20) + R_rpbase) + (dot (R_para, tmpvar_14) + dot (R_parb, tmpvar_15)));\n            vec2 tmpvar_77;\n            tmpvar_77.x = 0.5;\n            tmpvar_77.y = (((tmpvar_20 * numSegs) + 0.5) / numInstancesP2);\n            lowp vec4 tmpvar_78;\n            tmpvar_78 = (texture2D (posNewvals, tmpvar_77) * scaleFactor);\n            x_75 = (0.013 + tmpvar_78.x);\n            z_73 = (0.017 + tmpvar_78.z);\n            lowp vec4 tmpvar_79;\n            tmpvar_79 = texture2D (scaleDampTarget, vec2(0.5, 0.5));\n            x_75 = (x_75 - tmpvar_79.x);\n            y_74 = (tmpvar_78.y - tmpvar_79.y);\n            z_73 = (z_73 - tmpvar_79.z);\n            highp int num_80;\n            num_80 = (2 + pickxslot);\n            if ((num_80 == 0)) {\n              pickVary0.x = tmpvar_76;\n            };\n            if ((num_80 == 1)) {\n              pickVary0.y = tmpvar_76;\n            };\n            if ((num_80 == 2)) {\n              pickVary0.z = tmpvar_76;\n            };\n            if ((num_80 == 3)) {\n              pickVary0.w = tmpvar_76;\n            };\n            if ((num_80 == 4)) {\n              pickVary1.x = tmpvar_76;\n            };\n            if ((num_80 == 5)) {\n              pickVary1.y = tmpvar_76;\n            };\n            if ((num_80 == 6)) {\n              pickVary1.z = tmpvar_76;\n            };\n            if ((num_80 == 7)) {\n              pickVary1.w = tmpvar_76;\n            };\n            if ((num_80 == 8)) {\n              pickVary2.x = tmpvar_76;\n            };\n            if ((num_80 == 9)) {\n              pickVary2.y = tmpvar_76;\n            };\n            if ((num_80 == 10)) {\n              pickVary2.z = tmpvar_76;\n            };\n            if ((num_80 == 11)) {\n              pickVary2.w = tmpvar_76;\n            };\n            if ((num_80 == 12)) {\n              pickVary3.x = tmpvar_76;\n            };\n            if ((num_80 == 13)) {\n              pickVary3.y = tmpvar_76;\n            };\n            if ((num_80 == 14)) {\n              pickVary3.z = tmpvar_76;\n            };\n            if ((num_80 == 15)) {\n              pickVary3.w = tmpvar_76;\n            };\n            lowp vec4 tmpvar_81;\n            tmpvar_81.x = x_75;\n            tmpvar_81.y = y_74;\n            tmpvar_81.z = z_73;\n            tmpvar_81.w = 1.0;\n            lowp vec3 b_82;\n            b_82 = (tmpvar_81.xyz - skela3_22);\n            rad1a_21 = ((tmpvar_47.yzx * b_82.zxy) - (tmpvar_47.zxy * b_82.yzx));\n          } else {\n            if ((NORMTYPE == 5.0)) {\n              mat3 tmpvar_83;\n              tmpvar_83[0] = rot4[0].xyz;\n              tmpvar_83[1] = rot4[1].xyz;\n              tmpvar_83[2] = rot4[2].xyz;\n              lowp vec3 tmpvar_84;\n              tmpvar_84 = normalize((tmpvar_83 * (clearposA0 - \n                (tmpvar_48 * rot4)\n              .xyz)));\n              rad1a_21 = ((tmpvar_84.yzx * tmpvar_47.zxy) - (tmpvar_84.zxy * tmpvar_47.yzx));\n            } else {\n              if ((NORMTYPE == 6.0)) {\n                rad1a_21 = ((awayvec.yzx * tmpvar_47.zxy) - (awayvec.zxy * tmpvar_47.yzx));\n              } else {\n                rad1a_21 = vec3(0.0, 0.0, 1.0);\n              };\n            };\n          };\n        };\n      };\n    };\n  };\n  float tmpvar_85;\n  tmpvar_85 = (p_2.y * nstar);\n  star1_13 = tmpvar_85;\n  sss_12 = 1.0;\n  float tmpvar_86;\n  tmpvar_86 = floor(nstar);\n  if ((tmpvar_85 > tmpvar_86)) {\n    float tmpvar_87;\n    tmpvar_87 = fract(nstar);\n    sss_12 = tmpvar_87;\n    float tmpvar_88;\n    tmpvar_88 = floor(nstar);\n    star1_13 = (tmpvar_88 + ((tmpvar_85 - tmpvar_88) / tmpvar_87));\n  };\n  lowp float tmpvar_89;\n  tmpvar_89 = (r_38 * (1.0 - (\n    (1.0 - (((1.0 - \n      cos((6.28318 * star1_13))\n    ) * sss_12) * sss_12))\n   * stardepth)));\n  xrscalea_11 = tmpvar_89;\n  lk_10 = 0.0;\n  fac_9 = 1.0;\n  if (((0.0 < tmpvar_19) && (tmpvar_19 < tmpvar_17))) {\n    lk_10 = ((p_2.x * ribs) + 0.5);\n    float tmpvar_90;\n    tmpvar_90 = abs((fract(lk_10) - 0.5));\n    lk_10 = tmpvar_90;\n    float tmpvar_91;\n    tmpvar_91 = sqrt((1.0 - (\n      (ribdepth * tmpvar_90)\n     * tmpvar_90)));\n    fac_9 = tmpvar_91;\n    xrscalea_11 = (tmpvar_89 * tmpvar_91);\n  };\n  lowp vec3 tmpvar_92;\n  tmpvar_92 = normalize(rad1a_21);\n  xmnormal_7 = ((-(\n    sin((6.28318 * p_2.y))\n  ) * -(\n    normalize(((tmpvar_47.yzx * tmpvar_92.zxy) - (tmpvar_47.zxy * tmpvar_92.yzx)))\n  )) + (cos(\n    (6.28318 * p_2.y)\n  ) * tmpvar_92));\n  surfpos_8 = (skela3_22 + (xrscalea_11 * xmnormal_7));\n  xmnormal_7 = (xmnormal_7 + (tmpvar_47 * (\n    (ribdepth * lk_10)\n   / fac_9)));\n  lowp vec3 tmpvar_93;\n  tmpvar_93 = normalize(xmnormal_7);\n  xmnormal_7 = tmpvar_93;\n  if ((tmpvar_19 > tmpvar_17)) {\n    float tmpvar_94;\n    tmpvar_94 = (((\n      (tmpvar_19 - tmpvar_17)\n     / tmpvar_16) * 3.14159) / 2.0);\n    surfpos_8 = (skela3_22 + (xrscalea_11 * (\n      (sin(tmpvar_94) * tmpvar_47)\n     + \n      (cos(tmpvar_94) * tmpvar_93)\n    )));\n  };\n  if ((tmpvar_19 < 0.0)) {\n    float tmpvar_95;\n    tmpvar_95 = (((tmpvar_19 / tmpvar_16) * 3.14159) / 2.0);\n    surfpos_8 = (skela3_22 + (xrscalea_11 * (\n      (sin(tmpvar_95) * tmpvar_47)\n     + \n      (cos(tmpvar_95) * tmpvar_93)\n    )));\n  };\n  xmnormal_7 = tmpvar_93;\n  lowp vec4 tmpvar_96;\n  tmpvar_96.xyz = surfpos_8;\n  tmpvar_96.w = 1.0;\n  gl_PointSize = pointSize;\n  lowp vec4 tmpvar_97;\n  tmpvar_97.w = 1.0;\n  tmpvar_97.xyz = (tmpvar_96 * rot4).xyz;\n  ooo_1 = (projectionMatrix * (modelViewMatrix * tmpvar_97));\n  lowp vec4 ooo_98;\n  ooo_98 = ooo_1;\n  if ((USELOGDEPTH > 0.0)) {\n    ooo_98.xy = (ooo_1.xy / ooo_1.w);\n    ooo_98.w = 1.0;\n    ooo_98.z = (((\n      (log(ooo_1.w) - _camd.z)\n     * _camd.w) * 2.0) - 1.0);\n  } else {\n    if ((USELOGDEPTH < 0.0)) {\n      ooo_98.z = (log2(max (1e-6, \n        (ooo_98.w + 1.0)\n      )) * 0.15);\n      ooo_98.z = ((ooo_98.z - 1.0) * ooo_98.w);\n    };\n  };\n  ooo_1 = ooo_98;\n  gl_Position = ooo_98;\n}\n\n"},"matrix":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nvarying vec4 pickVary0;\nvarying vec4 pickVary1;\nvarying vec4 pickVary2;\nvarying vec4 pickVary3;\nvoid main ()\n{\n  highp int tmpvar_1;\n  tmpvar_1 = int(floor(gl_FragCoord.x));\n  mediump vec4 tmpvar_2;\n  if ((tmpvar_1 == 0)) {\n    tmpvar_2 = pickVary0;\n  } else {\n    mediump vec4 tmpvar_3;\n    if ((tmpvar_1 == 1)) {\n      tmpvar_3 = pickVary1;\n    } else {\n      mediump vec4 tmpvar_4;\n      if ((tmpvar_1 == 2)) {\n        tmpvar_4 = pickVary2;\n      } else {\n        tmpvar_4 = pickVary3;\n      };\n      tmpvar_3 = tmpvar_4;\n    };\n    tmpvar_2 = tmpvar_3;\n  };\n  gl_FragColor = tmpvar_2;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform float matskipdiag;\nuniform float matX;\nuniform float matY;\nuniform float matZ;\nuniform float matMinD;\nuniform float matMaxD;\nuniform float minActive;\nuniform float maxActive;\nuniform vec4 _camd;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 rot4;\nuniform float pointSize;\nattribute float instanceID;\nuniform float fakeinstanceID;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nvarying vec4 pickVary0;\nvarying vec4 pickVary1;\nvarying vec4 pickVary2;\nvarying vec4 pickVary3;\nuniform highp int pickxslot;\nuniform float NORMTYPE;\nuniform float USELOGDEPTH;\nvoid main ()\n{\n  lowp vec4 ooo_1;\n  vec4 p_2;\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xy = position.xy;\n  tmpvar_3.z = (instanceID + fakeinstanceID);\n  p_2.zw = tmpvar_3.zw;\n  p_2.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_2.y = (p_2.y * 0.5);\n  };\n  lowp float id_4;\n  lowp vec4 p_5;\n  pickVary0 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary1 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary2 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary3 = vec4(999.0, 999.0, 999.0, 999.0);\n  float v_6;\n  v_6 = p_2.x;\n  if ((pickxslot == 0)) {\n    pickVary0.x = v_6;\n  };\n  if ((pickxslot == 1)) {\n    pickVary0.y = v_6;\n  };\n  if ((pickxslot == 2)) {\n    pickVary0.z = v_6;\n  };\n  if ((pickxslot == 3)) {\n    pickVary0.w = v_6;\n  };\n  if ((pickxslot == 4)) {\n    pickVary1.x = v_6;\n  };\n  if ((pickxslot == 5)) {\n    pickVary1.y = v_6;\n  };\n  if ((pickxslot == 6)) {\n    pickVary1.z = v_6;\n  };\n  if ((pickxslot == 7)) {\n    pickVary1.w = v_6;\n  };\n  if ((pickxslot == 8)) {\n    pickVary2.x = v_6;\n  };\n  if ((pickxslot == 9)) {\n    pickVary2.y = v_6;\n  };\n  if ((pickxslot == 10)) {\n    pickVary2.z = v_6;\n  };\n  if ((pickxslot == 11)) {\n    pickVary2.w = v_6;\n  };\n  if ((pickxslot == 12)) {\n    pickVary3.x = v_6;\n  };\n  if ((pickxslot == 13)) {\n    pickVary3.y = v_6;\n  };\n  if ((pickxslot == 14)) {\n    pickVary3.z = v_6;\n  };\n  if ((pickxslot == 15)) {\n    pickVary3.w = v_6;\n  };\n  highp int num_7;\n  float v_8;\n  v_8 = p_2.y;\n  num_7 = (1 + pickxslot);\n  if ((num_7 == 0)) {\n    pickVary0.x = v_8;\n  };\n  if ((num_7 == 1)) {\n    pickVary0.y = v_8;\n  };\n  if ((num_7 == 2)) {\n    pickVary0.z = v_8;\n  };\n  if ((num_7 == 3)) {\n    pickVary0.w = v_8;\n  };\n  if ((num_7 == 4)) {\n    pickVary1.x = v_8;\n  };\n  if ((num_7 == 5)) {\n    pickVary1.y = v_8;\n  };\n  if ((num_7 == 6)) {\n    pickVary1.z = v_8;\n  };\n  if ((num_7 == 7)) {\n    pickVary1.w = v_8;\n  };\n  if ((num_7 == 8)) {\n    pickVary2.x = v_8;\n  };\n  if ((num_7 == 9)) {\n    pickVary2.y = v_8;\n  };\n  if ((num_7 == 10)) {\n    pickVary2.z = v_8;\n  };\n  if ((num_7 == 11)) {\n    pickVary2.w = v_8;\n  };\n  if ((num_7 == 12)) {\n    pickVary3.x = v_8;\n  };\n  if ((num_7 == 13)) {\n    pickVary3.y = v_8;\n  };\n  if ((num_7 == 14)) {\n    pickVary3.z = v_8;\n  };\n  if ((num_7 == 15)) {\n    pickVary3.w = v_8;\n  };\n  p_5 = p_2;\n  float tmpvar_9;\n  tmpvar_9 = (numSegs + 1.0);\n  lowp vec2 tmpvar_10;\n  tmpvar_10.x = 0.0;\n  tmpvar_10.y = (((p_2.x * tmpvar_9) + 0.5) / numInstancesP2);\n  lowp vec2 tmpvar_11;\n  tmpvar_11.x = 0.0;\n  tmpvar_11.y = (((p_2.y * tmpvar_9) + 0.5) / numInstancesP2);\n  lowp vec3 x_12;\n  x_12 = (texture2D (posNewvals, tmpvar_11).xyz - texture2D (posNewvals, tmpvar_10).xyz);\n  id_4 = (1.0/(clamp ((10.0 + \n    (((sqrt(\n      dot (x_12, x_12)\n    ) - matMinD) * 290.0) / (matMaxD - matMinD))\n  ), 10.0, 300.0)));\n  if (((p_2.x - p_2.y) > ((\n    -(matskipdiag)\n   - 2.0) / numSegs))) {\n    id_4 = 0.0;\n  };\n  if (!(((\n    (minActive <= p_2.x)\n   && \n    (p_2.x <= maxActive)\n  ) && (\n    (minActive <= p_2.y)\n   && \n    (p_2.y <= maxActive)\n  )))) {\n    id_4 = 0.0;\n  };\n  lowp float tmpvar_13;\n  if ((matMaxD == 0.0)) {\n    tmpvar_13 = 0.0;\n  } else {\n    tmpvar_13 = id_4;\n  };\n  p_5.x = (p_2.x + matX);\n  p_5.y = (p_2.y + matY);\n  p_5.z = (tmpvar_13 + matZ);\n  gl_PointSize = pointSize;\n  lowp vec4 tmpvar_14;\n  tmpvar_14.w = 1.0;\n  tmpvar_14.xyz = (p_5 * rot4).xyz;\n  ooo_1 = (projectionMatrix * (modelViewMatrix * tmpvar_14));\n  lowp vec4 ooo_15;\n  ooo_15 = ooo_1;\n  if ((USELOGDEPTH > 0.0)) {\n    ooo_15.xy = (ooo_1.xy / ooo_1.w);\n    ooo_15.w = 1.0;\n    ooo_15.z = (((\n      (log(ooo_1.w) - _camd.z)\n     * _camd.w) * 2.0) - 1.0);\n  } else {\n    if ((USELOGDEPTH < 0.0)) {\n      ooo_15.z = (log2(max (1e-6, \n        (ooo_15.w + 1.0)\n      )) * 0.15);\n      ooo_15.z = ((ooo_15.z - 1.0) * ooo_15.w);\n    };\n  };\n  ooo_1 = ooo_15;\n  gl_Position = ooo_15;\n}\n\n"},"matrix\n    override vec4 tr(const vec4 lopos, out vec3 xmnormal, out vec3 texpos, out float ribnum){\n        pickopos(lopos);\n        vec4 p = lopos;\n        float numInstances = numSegs + 1.;\n        vec3 p1 = histpos((p.x * numInstances + 0.5)/numInstancesP2).xyz;\n        vec3 p2 = histpos((p.y * numInstances + 0.5)/numInstancesP2).xyz;\n        float dist = length(p2 - p1);\n        float d10300 = clamp(map(dist, matMinD, matMaxD, 10., 300.), 10., 300.);// + 0.5;\n        //float id = 1./max(d, 10.);\n        float id = 1./d10300;\n        if (p.x - p.y > (-matskipdiag - 2.)/numSegs) id = 0.;\n\n        #define in(x,l,h) (l <= x && x <= h)\n        if (!(in(p.x, minActive, maxActive) && in(p.y, minActive, maxActive)))\n            id = 0.;\n\n\n        float hd = id; //heightFactor * tanh(id * heightFactor2) / tanh(heightFactor2);\n        p.z = matMaxD == 0. ? 0. : hd;\n        p.x += matX;\n        p.y += matY;\n        p.z += matZ;\n        //p.z = min(0.1, 1./d);\n        //p.xyz *= 8000.;\n        return p;\n    }\n\n    override Colsurf iridescentTexcol(in vec3 texpos, in vec3 viewDir, in vec3 normal) {\n// #define bimix(a00, a01, a10, a11, x,y) mix( mix(a00,a01, x), mix(a10, a11, x), y)\n        if (texpos.x - texpos.y > -matskipdiag / numSegs) discard;\n        Colsurf c = colsurfd();\n        // float a = clamp(texpos.z/heightFactor, 0., 1.);\n        // a = 0.5 + atan(((2.*a)-1.)*matColCurve) / (2.*atan(matColCurve));\n\n        // recompute distance, info passed in texpos.z not reliable\n        // we should only need to do this where dist is actually used.\n        float numInstances = numSegs + 1.;\n        vec3 pp = round(texpos * numSegs);  // we force lookup of precise position even if posVewVals is using LinearFilter\n        vec3 p1 = histpos((pp.x + 0.5)/numInstancesP2).xyz;\n        vec3 p2 = histpos((pp.y + 0.5)/numInstancesP2).xyz;\n        float dist = length(p2 - p1);\n\n        //''if (texpos.x - texpos.y > (-matskipdiag - 2.)/numSegs) distForCol = 0.;\n\n        //TODO: more structured colour genes\n        //##vec3 col1 = vec3(matcoldr, matcoldg, matcoldb);\n        //##vec3 col2 = vec3(mathotr, mathotg, mathotb);\n        vec3 col1 = vec3(matC00r, matC00g, matC00b);\n        vec3 col2 = vec3(matC11r, matC11g, matC11b);\n    //''c.col.rgb = mix(col1, col2, distForCol);\n        //''c.fluoresc.rgb = rgb2hsv(c.col.rgb);\n\n\n        vec2 tp = (texpos.xy * numSegs + 0.5) / numInstances;\n        float v1 = clamp( nval(matintypeA, matrix2dtexA, tp, dist, matDistNear, matDistFar), 0., 1.);\n        if (matintypeA + matintypeB == 0.) {    // old code\n        } else if (matcoltypeA == matcoltypeB) {\n             c.col.rgb = mix(col1, col2, v1);\n        } else {\n            float v2 = clamp(nval(matintypeB, matrix2dtexB, tp, dist, matDistNear, matDistFar), 0., 1.);\n            /**\n            c.col.rgb = bimix(\n                vec3(matC00r, matC00g, matC00b),\n                vec3(matC01r, matC01g, matC01b),\n                vec3(matC10r, matC10g, matC10b),\n                vec3(matC11r, matC11g, matC11b),\n                clamp(v1, 0., 1.), clamp(v2, 0., 1.));\n            **/\n           // cent is the color down the diagonal\n           // tint is the colour at the off-diagonal corner\n           // overall colour uses amount off-diagonal\n            vec3 cent = mix(vec3(matC00r, matC00g, matC00b), vec3(matC11r, matC11g, matC11b), max(v1, v2));\n\n            vec3 tint = v1 > v2 ? vec3(matC10r, matC10g, matC10b) : vec3(matC01r, matC01g, matC01b);\n            c.col.rgb = mix(cent, tint, clamp(matrixTintStrength*abs(v1-v2), 0.,1.));\n        }\n        c.col.rgb = pow(c.col.rgb, vec3(matgamma));  // better perceptual range\n        c.fluoresc.rgb = rgb2hsv(c.col.rgb);\n\n\n        //TODO uniforms for gridline presentation parameters.\n        //Also need to do something about aliasing. Could consider non-binary logic here.\n        if (matrixgridres != 0.) {\n            float dx = abs(fract(texpos.x*numInstances/matrixgridres));\n            float dy = abs(fract(texpos.y*numInstances/matrixgridres));\n            //dx=dy=1.;  // remove comment to remove the grid bands\n\n            float solidW = matrixgridwidth;\n            float softW = matrixgridsoftw;\n            float softR = 1./softW;\n            float fx = 1. - (clamp(dx - solidW, 0., softW) * softR);\n            float fy = 1. - (clamp(dy - solidW, 0., softW) * softR);\n            float f = min(fx+fy, 1.);\n            c.col.rgb += vec3(0,0.7,0.7) * f;\n            //TODO: think better about how to combine with existing hsv...\n            if (f > 0.) {\n                c.fluoresc.rgb = vec3(0.5, 1., 0.1 * f);\n            }\n        }\n\n        vec2 mtp = texpos.xy;  // texture position for looking up bed.  ? texpos ?\n        if (matrixbedtint != 0.) {\n            vec4 bed = texture2D(matrixbed, vec2(mtp.x, 0.5));\n            float t = bed.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n            float ti = t * 255. - 0.0;\n            // when BED doesn't have explicit colour, then all elements will be same... that doesn't make this logic right\n            // but close enough for now (famous last words), closer with test against green as well\n            vec3 bedrgb = bed.r != t || bed.g != t ? bed.rgb : stdcol(floor(ti == 0. ? 0. : (mod(ti, 6.) + 1.)));\n            c.col.rgb += bedrgb * matrixbedtint;\n\n            // TODO factor bed colour option and use for x and y (and ribbon)\n            vec4 bedy = texture2D(matrixbed, vec2(mtp.y, 0.5));\n            float ty = bedy.w;  // t_ribboncol is bed texture, small 'integer' values for now, but mapped to range 0..1\n            float tiy = ty * 255. - 0.0;\n            vec3 bedrgby = bedy.r != ty || bedy.g != ty ? bedy.rgb : stdcol(floor(tiy == 0. ? 0. : (mod(tiy, 6.) + 1.)));\n            c.col.rgb += bedrgby * matrixbedtint;\n        }\n\n\n        // darker for region outside active particles/springs\n#define in(x,l,h) (l <= x && x <= h)\n        if (!(in(texpos.x, minActive, maxActive) && in(texpos.y, minActive, maxActive)\n            && (texpos.y - texpos.x < maxBackboneDist))) {\n            c.col.rgb *= 0.5;\n            c.fluoresc.b *= 0.5;\n        }\n\n//;#if OPMODE != OPPICK  // minor optimization\n        // get Pick for all elements of interest.\n        for (int i=0; i<32; i++) {\n            //yuck.  Ignore the elements that aren't wanted. Will need to change later.\n            if (!(i==0 || i==4 || i==5 || i==8 || i==12 || i==13 || i >= 16 ) ) continue;\n            float p = getPickC(i);\n            if (abs(opos.x-p) < 0.001 || abs(opos.y-p) < 0.001) {\n                vec3 pcol = getPickColor(i);\n                c.col.rgb += pcol;\n                vec3 pcolHSV = rgb2hsv(pcol);\n                c.fluoresc.rgb = pcolHSV.rgb;\n            }\n        }\n//;#endif\n        c.surftype.y = 0.;  // prevent default gloss causing confusion. shininess1gloss1subband1plastic1\n        return c;\n    }\n    ":{"fragmentShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nvarying vec4 pickVary0;\nvarying vec4 pickVary1;\nvarying vec4 pickVary2;\nvarying vec4 pickVary3;\nvoid main ()\n{\n  highp int tmpvar_1;\n  tmpvar_1 = int(floor(gl_FragCoord.x));\n  mediump vec4 tmpvar_2;\n  if ((tmpvar_1 == 0)) {\n    tmpvar_2 = pickVary0;\n  } else {\n    mediump vec4 tmpvar_3;\n    if ((tmpvar_1 == 1)) {\n      tmpvar_3 = pickVary1;\n    } else {\n      mediump vec4 tmpvar_4;\n      if ((tmpvar_1 == 2)) {\n        tmpvar_4 = pickVary2;\n      } else {\n        tmpvar_4 = pickVary3;\n      };\n      tmpvar_3 = tmpvar_4;\n    };\n    tmpvar_2 = tmpvar_3;\n  };\n  gl_FragColor = tmpvar_2;\n}\n\n","vertexShader":"precision highp float;\nprecision highp float;\nprecision highp sampler2D;\nattribute vec3 position;\nuniform float matskipdiag;\nuniform float matX;\nuniform float matY;\nuniform float matZ;\nuniform float matMinD;\nuniform float matMaxD;\nuniform float minActive;\nuniform float maxActive;\nuniform vec4 _camd;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 rot4;\nuniform float pointSize;\nattribute float instanceID;\nuniform float fakeinstanceID;\nuniform float numSegs;\nuniform float numInstancesP2;\nuniform sampler2D posNewvals;\nvarying vec4 pickVary0;\nvarying vec4 pickVary1;\nvarying vec4 pickVary2;\nvarying vec4 pickVary3;\nuniform highp int pickxslot;\nuniform float NORMTYPE;\nuniform float USELOGDEPTH;\nvoid main ()\n{\n  lowp vec4 ooo_1;\n  vec4 p_2;\n  vec4 tmpvar_3;\n  tmpvar_3.w = 1.0;\n  tmpvar_3.xy = position.xy;\n  tmpvar_3.z = (instanceID + fakeinstanceID);\n  p_2.zw = tmpvar_3.zw;\n  p_2.xy = (position.xy + vec2(0.5, 0.5));\n  if ((NORMTYPE >= 5.0)) {\n    p_2.y = (p_2.y * 0.5);\n  };\n  lowp float id_4;\n  lowp vec4 p_5;\n  pickVary0 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary1 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary2 = vec4(999.0, 999.0, 999.0, 999.0);\n  pickVary3 = vec4(999.0, 999.0, 999.0, 999.0);\n  float v_6;\n  v_6 = p_2.x;\n  if ((pickxslot == 0)) {\n    pickVary0.x = v_6;\n  };\n  if ((pickxslot == 1)) {\n    pickVary0.y = v_6;\n  };\n  if ((pickxslot == 2)) {\n    pickVary0.z = v_6;\n  };\n  if ((pickxslot == 3)) {\n    pickVary0.w = v_6;\n  };\n  if ((pickxslot == 4)) {\n    pickVary1.x = v_6;\n  };\n  if ((pickxslot == 5)) {\n    pickVary1.y = v_6;\n  };\n  if ((pickxslot == 6)) {\n    pickVary1.z = v_6;\n  };\n  if ((pickxslot == 7)) {\n    pickVary1.w = v_6;\n  };\n  if ((pickxslot == 8)) {\n    pickVary2.x = v_6;\n  };\n  if ((pickxslot == 9)) {\n    pickVary2.y = v_6;\n  };\n  if ((pickxslot == 10)) {\n    pickVary2.z = v_6;\n  };\n  if ((pickxslot == 11)) {\n    pickVary2.w = v_6;\n  };\n  if ((pickxslot == 12)) {\n    pickVary3.x = v_6;\n  };\n  if ((pickxslot == 13)) {\n    pickVary3.y = v_6;\n  };\n  if ((pickxslot == 14)) {\n    pickVary3.z = v_6;\n  };\n  if ((pickxslot == 15)) {\n    pickVary3.w = v_6;\n  };\n  highp int num_7;\n  float v_8;\n  v_8 = p_2.y;\n  num_7 = (1 + pickxslot);\n  if ((num_7 == 0)) {\n    pickVary0.x = v_8;\n  };\n  if ((num_7 == 1)) {\n    pickVary0.y = v_8;\n  };\n  if ((num_7 == 2)) {\n    pickVary0.z = v_8;\n  };\n  if ((num_7 == 3)) {\n    pickVary0.w = v_8;\n  };\n  if ((num_7 == 4)) {\n    pickVary1.x = v_8;\n  };\n  if ((num_7 == 5)) {\n    pickVary1.y = v_8;\n  };\n  if ((num_7 == 6)) {\n    pickVary1.z = v_8;\n  };\n  if ((num_7 == 7)) {\n    pickVary1.w = v_8;\n  };\n  if ((num_7 == 8)) {\n    pickVary2.x = v_8;\n  };\n  if ((num_7 == 9)) {\n    pickVary2.y = v_8;\n  };\n  if ((num_7 == 10)) {\n    pickVary2.z = v_8;\n  };\n  if ((num_7 == 11)) {\n    pickVary2.w = v_8;\n  };\n  if ((num_7 == 12)) {\n    pickVary3.x = v_8;\n  };\n  if ((num_7 == 13)) {\n    pickVary3.y = v_8;\n  };\n  if ((num_7 == 14)) {\n    pickVary3.z = v_8;\n  };\n  if ((num_7 == 15)) {\n    pickVary3.w = v_8;\n  };\n  p_5 = p_2;\n  float tmpvar_9;\n  tmpvar_9 = (numSegs + 1.0);\n  lowp vec2 tmpvar_10;\n  tmpvar_10.x = 0.0;\n  tmpvar_10.y = (((p_2.x * tmpvar_9) + 0.5) / numInstancesP2);\n  lowp vec2 tmpvar_11;\n  tmpvar_11.x = 0.0;\n  tmpvar_11.y = (((p_2.y * tmpvar_9) + 0.5) / numInstancesP2);\n  lowp vec3 x_12;\n  x_12 = (texture2D (posNewvals, tmpvar_11).xyz - texture2D (posNewvals, tmpvar_10).xyz);\n  id_4 = (1.0/(clamp ((10.0 + \n    (((sqrt(\n      dot (x_12, x_12)\n    ) - matMinD) * 290.0) / (matMaxD - matMinD))\n  ), 10.0, 300.0)));\n  if (((p_2.x - p_2.y) > ((\n    -(matskipdiag)\n   - 2.0) / numSegs))) {\n    id_4 = 0.0;\n  };\n  if (!(((\n    (minActive <= p_2.x)\n   && \n    (p_2.x <= maxActive)\n  ) && (\n    (minActive <= p_2.y)\n   && \n    (p_2.y <= maxActive)\n  )))) {\n    id_4 = 0.0;\n  };\n  lowp float tmpvar_13;\n  if ((matMaxD == 0.0)) {\n    tmpvar_13 = 0.0;\n  } else {\n    tmpvar_13 = id_4;\n  };\n  p_5.x = (p_2.x + matX);\n  p_5.y = (p_2.y + matY);\n  p_5.z = (tmpvar_13 + matZ);\n  gl_PointSize = pointSize;\n  lowp vec4 tmpvar_14;\n  tmpvar_14.w = 1.0;\n  tmpvar_14.xyz = (p_5 * rot4).xyz;\n  ooo_1 = (projectionMatrix * (modelViewMatrix * tmpvar_14));\n  lowp vec4 ooo_15;\n  ooo_15 = ooo_1;\n  if ((USELOGDEPTH > 0.0)) {\n    ooo_15.xy = (ooo_1.xy / ooo_1.w);\n    ooo_15.w = 1.0;\n    ooo_15.z = (((\n      (log(ooo_1.w) - _camd.z)\n     * _camd.w) * 2.0) - 1.0);\n  } else {\n    if ((USELOGDEPTH < 0.0)) {\n      ooo_15.z = (log2(max (1e-6, \n        (ooo_15.w + 1.0)\n      )) * 0.15);\n      ooo_15.z = ((ooo_15.z - 1.0) * ooo_15.w);\n    };\n  };\n  ooo_1 = ooo_15;\n  gl_Position = ooo_15;\n}\n\n"}}}
